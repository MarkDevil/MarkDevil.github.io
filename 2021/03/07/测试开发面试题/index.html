<!DOCTYPE html>
<html lang="">
    <!-- title -->




<!-- keywords -->




<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="author" content="Mark M">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="Mark M">
    
    <meta name="keywords" content="autotest,测试开发,测试,自动化测试">
    
    <meta name="description" content>
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>测试开发面试题 · Mark&#39;s Studio</title><meta name="robots" content="noindex">
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href="/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="stylesheet" href="/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href="/assets/favicon.ico">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script">
    <link rel="preload" href="/scripts/main.js" as="script">
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
    <script>
        (function (i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
        (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date(); a = s.createElement(o),
        m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
        })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
        ga('create', 'true', 'auto');
        ga('send', 'pageview');
    </script>
    
</head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >Mark&#39;s Blog.</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">测试开发面试题</a>
            </div>
    </div>
    
    <a class="home-link" href=/>Mark's Blog.</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:50vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            测试开发面试题
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                
                    <div class="post-intro-read">
                        <span>字数统计: <span class="post-count word-count">74.2k</span>阅读时长: <span class="post-count reading-time">276 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2021/03/07</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <h1 id="1-测试理论"><a href="#1-测试理论" class="headerlink" title="1. 测试理论"></a>1. 测试理论</h1><p>Q.描述下上个公司的测试流程？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 产品tapd提出需求进行需求评审</span><br><span class="line">2. 评审完成后测试进行测试用例编写并与产品，开发确认</span><br><span class="line">3. 开发完成后，开发发邮件提测并提供git代码地址，版本号，以及改动说明</span><br><span class="line">4. 测试按照测试用例进行提测，有问题提到bug平台jira</span><br><span class="line">5. 开发修复完bug后，测试进行验证，验证通过后关闭bug</span><br><span class="line">6. 测试按用例测试完成后，发测试报告抄送相关人员。业务人员进行uat测试</span><br><span class="line">7. uat通过之后，开发人员准备上线脚本，进入上线流程</span><br></pre></td></tr></table></figure></p>
<p>Q.请描述下bug的几个要素？<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编号，严重级别，现象描述，测试时间，测试版本，测试人</span><br></pre></td></tr></table></figure></p>
<p>Q.白盒，黑盒，静态测试，动态的区别，你是怎么运用的？<br><br>A：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">白盒测试：白盒测试又称结构测试、逻辑驱动测试或基于程序代码内部结构的测试。此时，需要深入考察程序代码的内部结构、逻辑设计等等。白盒测试需要测试工程师具备很深的软件开发工地，精通相应的开发语言，一般的软件测试工程师难以胜任该工作。</span><br><span class="line"></span><br><span class="line">黑盒测试：黑盒测试又叫功能测试、数据驱动测试或给予需求规格说明书的功能测试。这种测试注重于测试软件的功能性需求。采用这种测试方法，测试工程师把测试对象看作一个黑盒子，不需要考虑程序内部的逻辑结构和特性，只需要依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明。黑盒测试能更好更真实的从用户角度来考察被测系统的功能性需求实现情况。</span><br><span class="line"></span><br><span class="line">静态测试（代码走读或者sonar）：静态测试，顾名思义，就是静态的、不执行被测对象程序代码而寻找缺陷的过程。通俗地讲，静态测试就是用眼睛看，阅读程序代码，文档资料等，与需求规格说明书中的需求进行比较，找出程序代码中设计的不合理，以及文档资料中的错误。</span><br><span class="line"></span><br><span class="line">动态测试：动态测试即为实际的执行被测对象的程序代码，输入事先设计好的测试用例，检查程序代码运行的结果与测试用例中设计的预期结果之间是否差异，判定实际结果与预期结果是否一致，从而检验程序的正确性、可靠性和有效性，并分析系统运行效率和健壮性等性能状况。</span><br><span class="line"></span><br><span class="line">动态测试由四部分组成：设计测试用例、执行测试用例、分析比较输出结果、输出测试报告。</span><br><span class="line">动态测试结合使用白盒测试和黑盒测试。</span><br></pre></td></tr></table></figure></p>
<p>Q.测试方法有哪些？<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">白盒测试方法：语句覆盖，判断覆盖，条件覆盖，多重条件覆盖</span><br><span class="line">黑盒测试方法：等价类划分，边界值分析，因果图分析，错误猜测</span><br></pre></td></tr></table></figure></p>
<p>Q.利用等价类划分判断是否为三角形？<br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- 有效等价类：</span><br><span class="line"></span><br><span class="line">    输入3个正整数或正小数：</span><br><span class="line">    1、两数之和大于第三数，如A&lt;B+C；B&lt;C+A；C&lt;A+B</span><br><span class="line">    2、两数之和不大于第三数</span><br><span class="line">    3、两数相等，如A=B或B=C或C=A</span><br><span class="line">    4、三数相等，如A=B=C</span><br><span class="line">    5、三数不相等，如A！=B，B！=C，C！=A</span><br><span class="line"></span><br><span class="line">- 无效等价类：</span><br><span class="line">    1、空</span><br><span class="line">    2、负整数</span><br><span class="line">    3、非数字                           </span><br><span class="line">    4、少于三个数</span><br></pre></td></tr></table></figure></p>
<p>Q.你是如果做测试分析的？<br><br>A：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 多读需求文档确定需求，不清楚的找人确认</span><br><span class="line">2. 梳理功能细化流程图，考虑流程中可能出现的设计缺陷</span><br><span class="line">3. 考虑正常流程中的测试难点</span><br><span class="line">4. 考虑与其他功能的关联</span><br><span class="line">5. 考虑非正常流程的影响，系统健壮性，以及版本兼容，历史数据</span><br></pre></td></tr></table></figure></p>
<p>Q.如果设计测试用例？什么样的测试用例是好的测试用例？<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">测试用例要素:用例编号，标题，功能模块或者系统，前置条件，输入数据，操作步骤，预期结果，优先级，执行结果。</span><br><span class="line">最后用例做到，步骤清晰，结果唯一，可操作性强</span><br></pre></td></tr></table></figure></p>
<p>Q.功能测试在beta版本对外的上线标准是什么？<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">但一般认为专业测试人员完成后，有部分用户参与的一轮测试即beta测试。</span><br><span class="line">1. 没有致命bug，不影响正常流程进行</span><br><span class="line">2. 所有功能点都覆盖到了</span><br><span class="line">3. 所有用例执行过至少一遍了</span><br><span class="line">4. 所有发现的bug被修复并验证做过regression</span><br></pre></td></tr></table></figure></p>
<p>Q.请用代码实现字符串拼接函数<br><br>Char <em>strconcat (char </em>pCh1, char *pCh2)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">join1</span><span class="params">(<span class="keyword">char</span> *a, <span class="keyword">char</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *c = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(a) + <span class="built_in">strlen</span>(b) + <span class="number">1</span>); <span class="comment">//局部变量，用malloc申请内存</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">NULL</span>) <span class="built_in">exit</span> (<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">char</span> *tempc = c; <span class="comment">//把首地址存下来</span></span><br><span class="line">    <span class="keyword">while</span> (*a != <span class="string">'\0'</span>) &#123;</span><br><span class="line">        *c++ = *a++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((*c++ = *b++) != <span class="string">'\0'</span>) &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//注意，此时指针c已经指向拼接之后的字符串的结尾'\0' !</span></span><br><span class="line">    <span class="keyword">return</span> tempc;<span class="comment">//返回值是局部malloc申请的指针变量，需在函数调用结束后free之</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Q.请设计Strconcat的测试用例?<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">入参边界校验</span><br><span class="line">注意边界值</span><br><span class="line">空指针异常</span><br></pre></td></tr></table></figure></p>
<p>Q.Http与Https有什么区别？<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 根本区别就是 HTTPS 在 HTTP 协议的基础上加入了 SSL 层，在传输层对网络连接进行加密。</span><br><span class="line">2. SSL 依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。采用 HTTPS 的服务器必须从证书颁发机构 CA（Certificate Authority）申请一个用于证明服务器用途类型的证书，当然一般都有收费，而且不便宜，其实你也可以通过 OpenSSL 自己造一个证书</span><br><span class="line">3. HTTP 是明文传输的，在传输过程中，在一些路由节点中很容易被别人捕获，识别你的内容，再在传输的数据中添加一些广告代码，最后数据传到你的手机里就显示成这样了，很不爽。而 HTTPS 能很有效的解决这个现象，我们在数据传输之前，双方商量一个加密的密码，然后俩个人之间的通讯都用这个密码进行加密，即便在路由节点被第三方捕获，它没有密码，看到的也是一堆乱码，没有办法在合适的位置插入广告代码，于是一个干干净净的界面就出现了。这只是一个很直观的作用，但是升级成 HTTPS更多的是为安全考虑，因为用户输入的账户密码等都有可能在传输过程中被监听，窃取，所以使用 HTTPS 来保证用户的信息安全是很有必要的。</span><br></pre></td></tr></table></figure></p>
<p>Q.Tomcat中如何配置SSL证书？<br><br>A:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8443"</span> <span class="attr">protocol</span>=<span class="string">"org.apache.coyote.http11.Http11Protocol"</span></span></span><br><span class="line"><span class="tag"><span class="attr">maxThreads</span>=<span class="string">"150"</span> <span class="attr">SSLEnabled</span>=<span class="string">"true"</span> <span class="attr">scheme</span>=<span class="string">"https"</span> <span class="attr">secure</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag"><span class="attr">clientAuth</span>=<span class="string">"false"</span> <span class="attr">sslProtocol</span>=<span class="string">"TLS"</span> <span class="attr">keystorefile</span>=<span class="string">"D:keyschlkey"</span> <span class="attr">keystorepass</span>=<span class="string">"changeit"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>Q.升级http协议到https协议，我们需要测试哪些内容？<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 连通性</span><br><span class="line">2. 服务端代理</span><br></pre></td></tr></table></figure></p>
<h1 id="测试情景"><a href="#测试情景" class="headerlink" title="测试情景"></a>测试情景</h1><p>Q.如何测试一个IM系统?<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 界面功能</span><br><span class="line">2. 传输稳定性</span><br><span class="line">3. 弱网稳定性</span><br><span class="line">4. 失败重试机制</span><br><span class="line">5. 用户隐私 检查是否在本地保存用户密码，无论加密与否 检查敏感的隐私信息如聊天记录、关系链、银行账号等是否进行加密 检查是否将系统文件</span><br><span class="line">6. 并发性能</span><br><span class="line">7. 系统兼容性</span><br></pre></td></tr></table></figure></p>
<p>Q.聊天功能测试用例设计？<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">发送对象（普通用户、公众号、群、其他特殊主体）</span><br><span class="line">衍生功能（转发、语音转文字、删除等）</span><br><span class="line">消息发送---单聊、群聊、语音、文字、图片、表情、链接、字符及长度</span><br><span class="line">消息管理---发布通知、接受通知、发文件、消息提醒、通知提醒、声音、震动、好友请求、请求处理</span><br><span class="line">发送内容（空白、正常文字、超长文字、以前曾经引起过崩溃的特殊内容、特殊字符、表情、图片、多媒体、红包、语音等）</span><br><span class="line">消息推送---在线、离线、收发、时序</span><br><span class="line">权限管理---开放群（任何人入群），半开放群（验证入群），验证加好友，不需验证加好友</span><br><span class="line">隐私管理---黑名单，允许好友查看动态，允许陌生人查看动态，允许通过手机号查找，允许真实姓名查找</span><br><span class="line">成员管理---加人，被加，退出，被动退出，编辑，删除</span><br><span class="line">群组管理---创建群，消息设置，申请入群，扫二维码入群，退群，通知提醒，头像编辑，名称编辑，简介编辑，权限编辑，成员编辑</span><br><span class="line">好友管理---扫二维码加人，加好友，查好友，好友推荐，群组推荐，联系人导入，拉黑名单，解除好友，备注名</span><br><span class="line">动态管理---发动态，发投票，点赞，表情，评论，增加，删除，分享，隐藏，编辑</span><br><span class="line">登录退出---忘记密码，更换账号</span><br><span class="line">文件管理---接收，离线接收，预览，删除，分享，转存，文件格式，大小</span><br><span class="line">语音聊天---接通/挂断、通话质量、耳机插拔、音量调解、话筒/扬声器切换、打开/关闭麦克风、后台挂起</span><br><span class="line">视频聊天---接通/挂点/切换语音、视频质量、耳机插拔、音量调解、话筒/扬声器切换、前置后置摄像头切换、视频框切换、后台挂起</span><br></pre></td></tr></table></figure></p>
<p>Q.Web页面操作响应过慢，如何定位原因？<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. chrome打开调试模式，访问URL，查看慢在什么地方。网络慢，服务器处理慢，同域名下资源太多，等等</span><br><span class="line">2. 测试到服务器的延时，丢包率等。</span><br><span class="line">3. 页面优化，切图等，资源加载不要阻塞，具体找开发聊一下。</span><br><span class="line">4. web服务器上开日志，看看是哪个环节慢，如果是PHP慢，就需要调试php参数，优化线程数。PHP逻辑问题需要开发解决。其他类型应用服务类似。</span><br><span class="line">5. 搭建监控平台，查看服务器负载，观察用户数和慢有没有对应的关系，</span><br><span class="line">6. 智能dns，cdn，等都可以考虑使用。</span><br></pre></td></tr></table></figure></p>
<p>Q.从用户浏览器输入url到用户看到页面结果的过程，发生了什么事情？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 请求域名解析服务器将域名解析为IP</span><br><span class="line">2. TCP三次握手</span><br><span class="line">3. 浏览器向服务器发送http请求</span><br><span class="line">4. 浏览器发送请求头信息和数据</span><br><span class="line">5. 服务器处理请求</span><br><span class="line">6. 服务器做出应答</span><br><span class="line">7. 服务器发送应答头信息</span><br><span class="line">8. 服务器发送数据</span><br><span class="line">9. tcp连接关闭</span><br></pre></td></tr></table></figure></p>
<p>Q.http的8种请求方式？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- OPTIONS 返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送&apos;*&apos;的请求来测试服务器的功能性。</span><br><span class="line">- HEAD 向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。</span><br><span class="line">- GET 向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中，例如在web app.中。其中一个原因是GET可能会被网络蜘蛛等随意访问。</span><br><span class="line">- POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</span><br><span class="line">- PUT 向指定资源位置上传其最新内容。</span><br><span class="line">- DELETE 请求服务器删除Request-URI所标识的资源。</span><br><span class="line">- TRACE 返回显服务器收到的请求，主要用于测试或诊断。</span><br><span class="line">CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</span><br></pre></td></tr></table></figure></p>
<p>Q.DNS的查询方式？<br><br>A：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DNS查询有2种</span><br><span class="line">正查：由Domain Name查询IP Address</span><br><span class="line">反查：由IP Address 查询Domain Name (利用In-Addr Arpa网域)</span><br></pre></td></tr></table></figure></p>
<p>Q.free命令中buffer和cache的区别?<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">两者都是RAM中的数据。简单来说，buffer是即将要被写入磁盘的，cache是被从磁盘中读出来的。</span><br><span class="line">buffer是由各种进程分配的，被用在如输入队列等方面，一个简单的例子如某个进程要求有多个字段读入，在所有字段被读入完整之前，进程把先前读入的字段放在buffer中保存。</span><br><span class="line">cache经常被用在磁盘的I/O请求上，如果有多个进程都要访问某个文件，于是该文件便被做成cache以方便下次被访问，这样可提供系统性能。</span><br></pre></td></tr></table></figure></p>
<h1 id="2-测试管理"><a href="#2-测试管理" class="headerlink" title="2. 测试管理"></a>2. 测试管理</h1><p>Q.如果项目周期很短，测试人力匮乏，你是怎么协调的？<br><br>A：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;范围不变，赶工/增加人手，快速跟进/并行开始任务。 范围能变，砍低优先级用例，缩小测试范围。</span><br></pre></td></tr></table></figure></p>
<p>Q.描述下你团队的测试分工？<br><br>A:<br></p>
<blockquote>
<p>按照业务线分工，分为信贷业务，理财业务，贷后和催收业务</p>
</blockquote>
<p>Q.对于团队成员，你是如何打kpi的？<br><br>A：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 出活</span><br><span class="line">2. 持续出活</span><br><span class="line">3. 持续精彩的出活</span><br></pre></td></tr></table></figure></p>
<h1 id="3-移动测试"><a href="#3-移动测试" class="headerlink" title="3. 移动测试"></a>3. 移动测试</h1><p>Q.请描述web测试和移动应用测试的相同点和区别？<br><br>A：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. web通常不要安装，移动应用通常要安装。</span><br><span class="line">2. 移动设备存在特殊性，不同设备的屏幕/分辨率，系统，定制UI都不相同。</span><br><span class="line">3. 移动应用不应该影响移动设备现有功能，如电话/短信等。</span><br><span class="line">4. 移动端要重点关注，发热（电量消耗）， crash， 流量(4G/WIFI/2G)等</span><br></pre></td></tr></table></figure></p>
<p>Q.你是如何做应用的兼容性测试的？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 硬件的适配：不同手机厂商、硬件性能，不同屏幕大小的适配</span><br><span class="line">2. OS版本的兼容。 iOS，Android， 手机，pad， 版本号啊，MUI定制啊等</span><br><span class="line">3. 不同分辨率屏幕的适配</span><br></pre></td></tr></table></figure></p>
<p>Q.请讲出客户端下 3 个常用的性能指标的名称与具体含义？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- 共有</span><br><span class="line">1. CPU利用率</span><br><span class="line">2. 内存使用率</span><br><span class="line">3. 平均用户响应时间</span><br><span class="line">- 独有的：</span><br><span class="line">1. 电量</span><br><span class="line">2. 流量</span><br><span class="line">3. 首次打开速度</span><br><span class="line">4. 竞品相应项目质量比较</span><br></pre></td></tr></table></figure></p>
<p>Q.iOS应用和Android应用测试有什么侧重点？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- 主要是iOS系统和Android系统的本质造成的：</span><br><span class="line">1. Android运行基于虚拟机，iOS则是沙盒机制</span><br><span class="line">2. iOS是伪后台，任何第三方程序都不能在后台运行；而Android是真后台，安卓中任何程序都能在后台运行，直到内存不够才关闭</span><br><span class="line">3. IOS中用于UI指令权限最高，安卓中数据处理指令权限最高。</span><br><span class="line">- 实际测试：</span><br><span class="line">1. 安全性。 因为Android2的本质，任何程序都就可以轻松访问其他程序文件，要关注下有没有偷偷访问不需要功能/偷流量/常时间运行占用内存消耗电量等问题。</span><br><span class="line">2. Android开源，定制版本过多（比如小米系列MIUI）， 要关注定制引起的问题。</span><br></pre></td></tr></table></figure></p>
<p>Q.请讲诉移动应用的灰度是怎么做的？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">灰度发布作为A/B Test的一种，一般指发布新功能到部分用户，收集反馈/改进，进而发布到全步用户的一种</span><br><span class="line">具体实施：</span><br><span class="line">1. 新服务发布到全部服务器，但通过配置项把不同特征用户的请求打到不同的后端服务上去。比如ip是中国的用户访点击某个按钮，调用的是后端。。。/vi这个API， 而国外ip调用。。/V2</span><br><span class="line">2. 新功能的后端服务只发布到部分服务器，只有访问到这个服务器的用户才能用新功能。</span><br><span class="line">3. 同一个用户访问的平台不同，请求的服务就不同，比如app的访问V1， web的访问V2，可以通过发布app版本来实现。</span><br><span class="line">4. 如果涉及到写DB操作， 一般都双写。即访问新服务时，写到新服务的DB数据也要写到老服务的DB。甚至全部切换至新服务后再并行运行一段时间，才彻底切换到新服务，停写老服务。</span><br></pre></td></tr></table></figure></p>
<p>Q.应用的闪退通常是什么原因造成的？如果应用闪退，Android 和 iOS 上是分别怎么抓取日志的？<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">一般闪退原因如下：</span><br><span class="line">1. 内存超载</span><br><span class="line">2. 后端服务或动态链接库未找到</span><br><span class="line">3. 应用初始化时无法正确读取到用户数据。</span><br><span class="line">4. 系统兼容问题。</span><br><span class="line">日志抓取的话，iOS：</span><br><span class="line">1. 通过iTunes Connect（Manage Your Applications - View Details - Crash Reports）获取用户的crash日志</span><br><span class="line">2. 通过Xcode从你的设备上获得崩溃日志</span><br><span class="line">3. 自己在程序中添加崩溃捕捉代码，如果应用集成第三方SDK，如百度统计</span><br><span class="line">Android：</span><br><span class="line">1. 通过集成第三方SDK，如百度统计、友盟统计等</span><br><span class="line">2. 发版时使用加固工具，他们也会收集错误日志，如360加固</span><br><span class="line">3. 在程序中添加程序异常崩溃的捕捉代码，保存到本地文件中</span><br></pre></td></tr></table></figure></p>
<p>Q.请简述移动应用在升级安装时候应该考虑的场景？<br><br>A：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. APP有新版本时，打开APP是否有更新提示。</span><br><span class="line">2. 当版本为非强制升级版时，用户可以取消更新，老版本能正常使用。用户在下次启动app时，仍能出现更新提示。</span><br><span class="line">3. 当版本为强制升级版时，当给出强制更新后用户没有做更新时，退出APP。下次启动app时，仍出现强制升级提示。</span><br><span class="line">4. 不删除APP直接更新，检查是否能正常更新，更新后能否正常工作。</span><br><span class="line">5. 删除老的APP，重新下载APP，能不能正常工作。</span><br><span class="line">6. 不删除APP直接更新，检查更新后的APP和新安装的APP提供的功能一样。</span><br><span class="line">7. 检查在线跨版本升级能否成功，版本过老是否提示用户重装。</span><br><span class="line">8. 更新成功后，用户数据有没有丢失，各个配置项是否还原。</span><br></pre></td></tr></table></figure></p>
<p>Q.App中H5页面与服务器是如何交互的？<br><br>A:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#使用webview控件内联H5页面</span><br><span class="line">webview.addJavascriptInterface(new Object() &#123;</span><br><span class="line">    @JavascriptInterface</span><br><span class="line">    public void openActivity(String activity)&#123;</span><br><span class="line">        Intent i = new Intent(Intent.ACTION_VIEW, Uri.parse(activity));</span><br><span class="line">        mContext.startActivity(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, &quot;android&quot;);</span><br><span class="line"></span><br><span class="line">&lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;alert(android.openActivity(&apos;Recharge&apos;))&quot;&gt;充值&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;alert(android.openActivity(&apos;Goods&apos;))&quot;&gt;抢购&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>Q.Android的四大组件？<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. Activity</span><br><span class="line">2. Service</span><br><span class="line">3. Broadcast Receiver广播接收器</span><br><span class="line">4. Content Provider 内容提供者</span><br></pre></td></tr></table></figure></p>
<p>Q.Android Broadcast的两种实现方式?<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 静态注册(系统广播)：</span><br><span class="line">    实现广播接收类,继承BroadcastReceiver</span><br><span class="line">    注册广播,在mainfreast.xml里面添加&lt;receiver&gt;&lt;/receiver&gt;如下</span><br><span class="line">2. 动态注册(自定义广播):</span><br><span class="line">    实现广播接收类,继承BroadcastReceiver</span><br><span class="line">    动态注册自定义广播，一般在onStart()的时候注册</span><br></pre></td></tr></table></figure></p>
<p>Q.Activity的状态?<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">生命周期：onCreate() -&gt; onStart() - &gt; onResume() -&gt; onPause() -&gt; onStop() -&gt;  onDestroy()</span><br></pre></td></tr></table></figure></p>
<p>Q.Android手机不同分辨率的匹配?<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 根据物理尺寸的大小准备5套布局layout</span><br><span class="line">2. 根据需求配置不同的布局layout</span><br></pre></td></tr></table></figure></p>
<p>Q.手机app崩溃的原因？<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 设备碎片化：由于设备极具多样性，App在不同的设备上可能有表现不同。</span><br><span class="line">2. 带宽限制：带宽不佳的网络对App所需的快速响应时间可能不够。</span><br><span class="line">3. 网络的变化：不同网络间的切换可能会影响App的稳定性。</span><br><span class="line">4. 内存管理：可用内存过低，或非授权的内存位置的使用可能会导致App失败。</span><br><span class="line">5. 用户过多：连接数量过多可能会导致App崩溃。</span><br><span class="line">6. 代码错误：没有经过测试的新功能，可能会导致App在生产环境中失败。</span><br><span class="line">7. 第三方服务：广告或弹出屏幕可能会导致App崩溃。</span><br></pre></td></tr></table></figure></p>
<p>Q.从一个主线程跳转到另一个线程如果做到的？<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AsynTask类或者Handler消息</span><br><span class="line">使用 Handler可以说是最万能的方式，其原理是消息循环，在主线程中建立Handler变量时，就会启动Handler消息循环，一个个的处理消息队列中的任务。但是其也有棘手的时候；其棘手的地方就是麻烦。</span><br></pre></td></tr></table></figure></p>
<p>Q.给你一个应用，请简述你会从哪些方面去测试？<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一般答分类，分类如下： 安装/卸载测试， UI， 功能， 性能， 安全（权限获取），需要的权限是否合理， 兼容， 易用， 可移植性。</span><br></pre></td></tr></table></figure></p>
<p>Q.请描述下微信朋友圈发小视频的用例设计？<br><br>A：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 安全性：因为对于微信发朋友圈来说，其实在安全性方面不是重点，就是去获取相册和视频的权限时要确认下有没有问题（但是微信支付这个功能这块就是最重要的了）。</span><br><span class="line">2. 兼容性：这块应该是app一个通用的测试难点了，涉及到不同型号和厂商的手机，相信很多公司都有了对应的测试方法，比如：众测。</span><br><span class="line">3. 体验性：这个其实是app的一个测试重点，按照目前发朋友圈的方式体验还是比较好的，而且人人都习惯了，所以也没有什么问题（不过目前发朋友圈有2种方式，大家可以比较下哪种更符合用户习惯呢）？ 这里也同时发现了几个问题：只能够现场录制视频后发朋友圈，不能发已有视频；不能发多个视频；不能够直接发文字；对于后面的2个问题，微信有自己的体验原则还可以理解。但是不能够发相册里面的视频其实是值得吐槽的（如果是石头哥的版本肯定是提bug的节奏），毕竟视频具有实时性，本来别人看到一个好玩的东西想录制视频（比如：小朋友的表情），还需要先打开微信，找到发朋友圈的地方再去录制，这个时候可能黄花菜都凉了。</span><br><span class="line">4. 可扩展性：我们除了现在能够发照片和视频外，后面如果支持更多内容的话，是不是有很快的解决方案，还是需要改动很大（这个其实我们测试人员是可以帮助开发去考虑的）。</span><br><span class="line">5. 可靠性：这里主要分为对发的内容和发送的过程来进行分析，结果大家可以看上面。</span><br><span class="line">6. 性能：对于app来说，主要的性能就是对资源的占用，当然， 这里也需要考虑到对服务器的性能压力。</span><br><span class="line">7. 可维护性：这里主要说只出问题后如何去分析和排查。要知道，对于app来说用户才是最大的测试群体。所以，一般的app都会有自动上报的功能（好吧，这其实已经涉及到安全问题了）。</span><br></pre></td></tr></table></figure></p>
<p>Q.如果让你来测试扫码支付，你会考虑哪些场景？<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">功能验证，安全验证，异常验证，失效时间</span><br></pre></td></tr></table></figure></p>
<p>Q.ABCD乘以9等于DCBA，那么ABCD各等于几?<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">四位数*9仍然是四位数,所以A只能为1</span><br><span class="line">1BCD*9=DCB1, 所以D=9</span><br><span class="line">1BC9*9=9CB1,因为9B不能进位，所以B只能为1或者0</span><br><span class="line">假设B为1，9C+8的个位数是1，9*C的个位数是3，这样C是7，但是c*9也不能进位，所以B只能为0</span><br><span class="line">10C9*9=9C01，9C*9+8个位数是0，所以c为8</span><br><span class="line">最后答案ABCD=1089</span><br></pre></td></tr></table></figure></p>
<p>Q.如何测试一个应用的登录场景？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- 功能</span><br><span class="line">- 性能</span><br><span class="line">- 兼容性</span><br><span class="line">- 安全</span><br><span class="line">    - 密码存储</span><br><span class="line">    - 接口传输加密</span><br><span class="line">- 异常</span><br></pre></td></tr></table></figure></p>
<h1 id="4-服务端测试"><a href="#4-服务端测试" class="headerlink" title="4. 服务端测试"></a>4. 服务端测试</h1><p>Q.请问你们公司是如何做接口测试的？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 接口规范拿到。</span><br><span class="line">2. 设计接口测试功能用例（主要从用户角度出发看接口能否实现业务需求，用例设计就是黑盒用例那一套）。</span><br><span class="line">3. 各种入参验证（正常情况，异常情况包括输入参数个数不对，类型不对，可选/必选， 还有考虑参数有互斥或关联的情况）。</span><br><span class="line">4. 接口返回值各种验证（符合接口文档需求）</span><br><span class="line">5. 了解接口实现逻辑，实现逻辑覆盖（语句/条件/分支/判定/。。。。。）</span><br><span class="line">6. 接口能并发执行吗?采用工具或者自写代码来验证，HTTP接口一般Jmeter， Fiddler，WRK Postman等都能验证，自己写更好。web service接口一般要写代码来调用。根据测试用例自动化。</span><br><span class="line">7. 发现问题跟功能测试一样，该报bug报bug，该跟踪状态跟踪状态</span><br><span class="line">8. Dubbo接口使用泛化调用的方法进行验证</span><br></pre></td></tr></table></figure></p>
<p>Q.接口测试质量评估标准是什么？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 接口功能是否正确，接口功能是否实现了业务需求。</span><br><span class="line">2. 接口参数正确性包括实参形参的个数/属性，是否匹配。</span><br><span class="line">3. 接口并发/串行执行时接口返回值的正确性。</span><br><span class="line">4. 有没有性能问题（并发执行），有无安全问题（用户能否直接访问该接口，需不需要验证）</span><br></pre></td></tr></table></figure></p>
<p>Q.请问你们公司是如何做性能测试的？请讲诉性能测试的相关指标？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">性能测试：</span><br><span class="line">- 拿到测试需求，确定测试软硬件环境/测试指标， 使用测试工具(Loadrunner, jmeter)录制或者编写测试代码，逐步加压，直到测试目的达成。</span><br><span class="line">- 分析测试结果，编写测试报告，突出性能指标包括成功，失败情况，并加以分析。</span><br><span class="line">- 调优（一般都是开发的事）</span><br><span class="line">性能测试相关指标:</span><br><span class="line">- 服务器系统资源方面 CPU占用率，内存占用率 磁盘的读写指标</span><br><span class="line">- 网络的占用情况 基础吞吐率</span><br><span class="line">- 事务处理速度 如平均登录时间，操作平均响应时间等。</span><br></pre></td></tr></table></figure></p>
<p>Q.产品项目的测试保障是如何做的？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答由于项目是叠加式研发，属于短频快项目，基于此采取分层测试策略保障，来实现分阶段逐层保证，同时降低各阶段质量工作的重合度； 同时建设业务全链路回归测试、精准测试、录制回放、线上应用、业务监、线上质检等手段来保证整个产品从研发到生产整个过程的质量。</span><br></pre></td></tr></table></figure></p>
<p>Q.压力测试和负载测试的区别?<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个（压力测试）把最后一根稻草仍你身上，一个（负载测试）就剩最后一根稻草没仍，或者仍给你指定数目稻草。</span><br></pre></td></tr></table></figure></p>
<p>Q.服务器中一般要监控哪些数据，如何监控的，怎么从监控数据中发现问题？<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CPU， 内存， 网络， I/O， 数据库。等等。 一般用工具监控，另外Windows上有性能监视器。</span><br><span class="line">发现问题，一般要关注阈值，比如CPU利用率超过85%，说明server压力太大了，数据量一大DB某条SQL写入速度变慢了等等等等</span><br></pre></td></tr></table></figure></p>
<p>Q.假设系统A调用系统B，我把B的接口都mock了，进行性能测试，这样有什么好处和坏处？<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">好处是去掉的依赖，可以在B没有好之前测试A，并且B的任何改动/错误/失效不会影响我测试A</span><br><span class="line">坏处是真实性能要比测出来的性能差， 性能指标不准确。 因为Mock的服务再真也不能代替真实服务</span><br></pre></td></tr></table></figure></p>
<p>Q.有一天早上打车高峰，滴滴服务端挂了大概30分钟，工程师抢修之后，马上上线，之后又挂了，请问有哪些原因会造成这个情况？<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一次挂第二次挂分开说，先问有没有错误码，日志有吗，有就看日志，没有就猜 是应用服务器挂了啊，是不是高峰期顶不住这么大并发访问啊？是数据库服务器啊，是不是频繁读写受不了啊，读写有分开吗？同步还是异步啊。</span><br><span class="line">第二次挂，可能更多了，是不是代码弄错了，改坏了。</span><br></pre></td></tr></table></figure></p>
<p>Q.如何保证接口的安全性？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 签名</span><br><span class="line">2. 加密</span><br></pre></td></tr></table></figure></p>
<h1 id="5-自动化相关"><a href="#5-自动化相关" class="headerlink" title="5. 自动化相关"></a>5. 自动化相关</h1><p>Q.如何看待自动化和手动测试？怎样的一个比例才是健康的？<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">见仁见智，一切能提高软件质量的方法都应该尝试。</span><br><span class="line">兵无常形，符合自己项目实际情况是最好的。当然你要面试自动化测试，肯定是一切稳定了的功能最好全部自动化掉。</span><br></pre></td></tr></table></figure></p>
<p>Q.你们公司的自动化投入产出比怎样？效益怎样？<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实话实说，UI自动化测试发现新bug的效益很低，主要用在回归测试上，减少测试工作量。接口测试可就不一样了，可以小步快跑，也可以集团作战。</span><br></pre></td></tr></table></figure></p>
<p>Q.自动化测试用例的覆盖率多少？<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有个50%了不得了吧， 一般核心业务里的最高优先级用例100%覆盖，这些用例也是用来跑冒烟的。 另外的看项目资源了。</span><br></pre></td></tr></table></figure></p>
<p>Q.如何在非单点登录的系统中实现自动化？<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需要做到业务测试账号与自动化测试账号分开</span><br></pre></td></tr></table></figure></p>
<p>Q.完整运行一次自动化用例需要多久时间？<br><br>A:</p>
<blockquote>
<p>小时级</p>
</blockquote>
<p>Q.什么是分层自动化？<br><br>A:</p>
<blockquote>
<p>金字塔结构， 最底层UnitTest，往上接口API/集成起来的service， 最上面UI自动化</p>
</blockquote>
<p>Q.你的测试数据是怎么准备的？<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据量小的情况下写在脚本里/外部文件（csv)</span><br><span class="line">数据量大的情况下放入数据库便于做数据分析和报告</span><br></pre></td></tr></table></figure></p>
<p>Q.测试脚本的维护成本是怎么样的？<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 不坏就不要修</span><br><span class="line">2. 终身追责，谁污染谁治理</span><br></pre></td></tr></table></figure></p>
<h2 id="5-1-工具使用"><a href="#5-1-工具使用" class="headerlink" title="5.1 工具使用"></a>5.1 工具使用</h2><h3 id="5-1-1-WebDriver"><a href="#5-1-1-WebDriver" class="headerlink" title="5.1.1 WebDriver"></a>5.1.1 WebDriver</h3><p>Q.WebDriver的工作原理？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. WebDriver Api</span><br><span class="line">2. 浏览器的驱动（火狐驱动，chrome驱动）</span><br><span class="line">3. 服务端本地浏览器</span><br></pre></td></tr></table></figure></p>
<p>Q.Selenium脚本执行时后端都发生了什么？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.对于每一条Selenium脚本，一个http请求会被创建并且发送给浏览器的驱动</span><br><span class="line">2.浏览器驱动中包含了一个HTTP Server，用来接收这些http请求</span><br><span class="line">3.HTTP Server接收到请求后根据请求来具体操控对应的浏览器</span><br><span class="line">4.浏览器执行具体的测试步骤</span><br><span class="line">5.浏览器将步骤执行结果返回给HTTP Server</span><br><span class="line">6.HTTP Server又将结果返回给Selenium的脚本，如果是错误的http代码我们就会在控制台看到对应的报错信息。</span><br></pre></td></tr></table></figure></p>
<p>Q.请问你的定位策略是什么？<br><br>A:</p>
<blockquote>
<p>ID， Clas， CSS， XPath， jquery脚本</p>
</blockquote>
<p>Q.请问如何实现用例失败或者异常时候需要截图？<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">框架自带， python+webdriver里是get_screenshot_as_file，通过报错捕获异常的方式来</span><br><span class="line">一般写一个装饰器，放在要执行的类上，try， catch下,Java类似</span><br></pre></td></tr></table></figure></p>
<p>Q.请问如何分布式执行webdriver用例？<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.利用Jenkins等，部署部分代码到多个机器上执行</span><br><span class="line">2.RemoteWebDriver</span><br><span class="line">3.Selenium Grid</span><br><span class="line"></span><br><span class="line">self.driver = webdriver.Remote(&apos;http://locahost:4444/wd/hub&apos;,</span><br><span class="line">                        desired_capabilities=webdriver.DesiredCapabilities.FIREFOX)</span><br><span class="line">self.driver.get(&quot;http://www.baidu.com&quot;)s</span><br></pre></td></tr></table></figure></p>
<p>Q.如何在脚本中执行 JavaScript 代码？<br><br>A:  </p>
<blockquote>
<p>driver.execute_js(‘脚本’)</p>
</blockquote>
<p>Q.selenium中用什么函数判断元素是否存在？<br><br>A:</p>
<blockquote>
<p>WebDriverWait(driver, timeout, 1).until(EC.presence_of_element_located((by, what)))</p>
</blockquote>
<p>Q.selenium中hidden或者是display ＝ none的元素是否可以定位到？<br><br>A: </p>
<blockquote>
<p>不能,可以写JavaScript将标签中的hidden先改为0，再定位元素</p>
</blockquote>
<p>Q.Selenium中如何保证操作元素的成功率？也就是说如何保证我点击的元素一定是可以点击的？<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 添加元素智能等待时间 driver.implicitly_wait(30)</span><br><span class="line">2. 添加强制等待时间(比如python中写 sleep)</span><br><span class="line">3. try 方式进行 id,name,clas,x path, css selector 不同方式进行定位，如果第一种失败可以自动尝试第二种</span><br></pre></td></tr></table></figure></p>
<p>Q.如何提高selenium脚本的执行速度？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 减少操作步骤，如经过三四步才能打开我们要测试的页面的话，我们就可以直接通过网址来打开，减少不必要的操作。</span><br><span class="line">2. 中断页面加载，如果页面加载的内容过多，我们可以查看一下加载慢的原因，如果加载的内容不影响我们测试，就设置超时时间，中断页面加载。</span><br><span class="line">3. 在设置等待时间的时候，可以sleep固定的时间，也可以检测某个元素出现后中断等待也可以提高速度。</span><br><span class="line">4. 配置testNG实现多线程。在编写测试用例的时候，一定要实现松耦合，然后在服务器允许的情况下，尽量设置多线程运行，提高执行速度。</span><br></pre></td></tr></table></figure></p>
<p>Q.用例在运行过程中经常会出现不稳定的情况，也就是说这次可以通过，下次就没办法通过了，如何去提升用例的稳定性？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- time.sleep( )</span><br><span class="line">- driver.implicitly_wait(30)</span><br><span class="line">- 多用 try 捕捉，处理异常</span><br><span class="line">- webDriverWait和until方法</span><br></pre></td></tr></table></figure></p>
<p>Q.你的自动化用例的执行策略是什么？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 自动化测试用例是用来监控的，在此目的下，我们就把自动化测试用例设置成定时执行的，如果每五分钟或是一个小时执行一次，在jenkins上创建一个定时任务即可。</span><br><span class="line">2. 必须回归的用例。有些儿测试用例，如BVT测试用例，我们在公司产品任何变动上线之前都需要回归执行。那我们就把测试用例设置成触发式执行，在jenkins上将我们的自动化测试任务绑定到开发的build任务上。当开发人员在仿真环境上部代码的时候，我们的自动化测试用例就会被触发执行。</span><br><span class="line">3. 不需要经常执行的测试用例。像全量测试用例，我们没有必要一直回归执行，必竟还是有时间消耗的，有些非主要业务线也不需要时时回归。这类测试用例我们就采用人工执行，在jenkins创建一个任务，需要执行的时候人工去构建即可。</span><br></pre></td></tr></table></figure></p>
<p>Q.什么是持续集成？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 持续集成源于极限编程(XP)，是一种软件实践，软件开发过程中集成步骤是一个漫长并且无法预测的过程。集成过程中可能会爆发大量的问题，因此集成过程需要尽可能小而多，实际上持续集成讲的是不断的去做软件的集成工作。持续集成，最简单的形式是包括一个监控版本控制（SVN等等）变化的工具。当变化被发觉时，这个工具可以自动的编译并测试你的应用。</span><br></pre></td></tr></table></figure></p>
<p>Q.自动化测试的时候是不是需要连接数据库做数据校验？<br><br>A: </p>
<blockquote>
<p>需要</p>
</blockquote>
<p>Q.id,name,class,xpath, css selector这些属性，你最偏爱哪一种，为什么？<br><br>A:<br></p>
<blockquote>
<p>xpath, css selector</p>
</blockquote>
<p>Q.如何去定位页面上动态加载的元素？<br><br>A:<br></p>
<blockquote>
<p>触发动态加载元素的事件，直至动态元素出现，进行定位</p>
</blockquote>
<p>Q.如何去定位属性动态变化的元素？<br><br>A:<br></p>
<blockquote>
<p>xpath或者css通过同级、父级、子级进行定位</p>
</blockquote>
<p>Q.webdriver client的原理是什么？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">webdriver是按照server – client的经典设计模式设计的。</span><br><span class="line">server端就是remote server，可以是任意的浏览器。当我们的脚本启动浏览器后，该浏览器就是remote server，它的职责就是等待client发送请求并做出相应；</span><br><span class="line">client端简单说来就是我们的测试代码，我们测试代码中的一些行为，比如打开浏览器，转跳到特定的url等操作是以http请求的方式发送给被 测试浏览器，也就是remote server；remote server接受请求，并执行相应操作，并在response中返回执行状态、返回值等信息；</span><br></pre></td></tr></table></figure></p>
<p>Q.webdriver的协议是什么？<br><br>A:<br></p>
<blockquote>
<p>The WebDriver Wire Protocol/JSON Wire protocol</p>
</blockquote>
<p>Q.启动浏览器的时候用到的是哪个webdriver协议？<br><br>A:<br></p>
<blockquote>
<p>http</p>
</blockquote>
<p>Q.什么是page object设计模式？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">相似功能地方，代码基本都是一样的，界面元素换个查找方式，把原来的使用 xpath方式，改为使用 id 查找，需要对每个用例脚本都要改，虽然几个用例看不出什么工作量，但是重复findElement的代码，已经让我们感到了代码的笨重。如果某些定位发生了改变，我们就得贯穿整个测试代码进行调整元素定位，这样就会导致我们的脚本在后期，难以维护。因此通过Page Object Model 我们可以创建更加健壮代码，并减少或者消除重复的测试代码，从而也能够提高代码的可读性，减少编写脚本的工作量。Page Object Model的实现，就是通过分离测试对象和测试脚本的抽象来实现的。</span><br></pre></td></tr></table></figure></p>
<p>Q.Python Selenium实现文件上传功能？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. input标签空间，直接定位并输入文件路径</span><br><span class="line">2. 非input类型上传文件，使用pywin32或者Autoit</span><br></pre></td></tr></table></figure></p>
<h3 id="5-1-2-Appium"><a href="#5-1-2-Appium" class="headerlink" title="5.1.2 Appium"></a>5.1.2 Appium</h3><p>Q.Appium 的定位策略有哪些？<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">driver.find_element_by_id() –元素的 resrouce-id 属性</span><br><span class="line">driver.find_element_by_AccessibilityId() – content-desc属性，替代以前的name。</span><br><span class="line">driver.find_element_by_xpath() –比css定位慢</span><br><span class="line">driver.find_element_by_class_name() –元素的 class 属性</span><br><span class="line">driver.find_element_by_css_selector()</span><br><span class="line">driver.find_element_by_link_text() –链接元素的全部显示文字</span><br><span class="line">driver.find_element_by_tag_name() –元素的标签名</span><br><span class="line">driver.find_element_by_partial_link_text() –链接元素的部分显示文字</span><br></pre></td></tr></table></figure></p>
<p>Q.请简述Appium的原理?<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iOS：</span><br><span class="line">    IosUIAutomation –iOS9.3或以下的定位方法</span><br><span class="line">    driver.find_element_by_ios_uiautomation(‘.elements()[0]’)</span><br><span class="line">Android：</span><br><span class="line">    AndroidUIAutomator， 仅支持 Android 4.2或以上，可支持元素的单个属性和多个属性定位。</span><br><span class="line">    driver.find_element_by_android_uiautomator(‘new UiSelector().text(“Animation”)’)</span><br></pre></td></tr></table></figure></p>
<p>Q.iOS 和 Android 的 UI 自动化的原理是什么？<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. Appium是C/S架构的，更像是一个proxy，连接其被测移动平台和测试脚本。</span><br><span class="line">2. appium是基于 webdriver 协议添加对移动设备自化api扩展而成的。</span><br></pre></td></tr></table></figure></p>
<p>Q.当定位策略都失败的时候，你该怎么做？<br><br>A:</p>
<blockquote>
<p>一般来说XPATH都能定位到，无非是可阅读性不强。真的全部失效，请求开发帮你改个元素属性好了。</p>
</blockquote>
<h3 id="5-1-3-Jmeter"><a href="#5-1-3-Jmeter" class="headerlink" title="5.1.3 Jmeter"></a>5.1.3 Jmeter</h3><p>Q.你用jmeter做什么测试？<br><br>A:</p>
<blockquote>
<p>接口，性能</p>
</blockquote>
<p>Q.如果有一个登录接口需要服务端返回参数，再带着这个参数去请求才能完成登录，用jmeter 怎么做？<br><br>A:</p>
<blockquote>
<p>Regular Expression Extractor，正则表达式提取器传参</p>
</blockquote>
<p>Q.Jmeter登录成功后自动跳转导致cookie重置返回登录失败？<br><br>A：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">校验页面的HTTP请求中，有看到一个：自动重定向、跟随重定向的设置；</span><br><span class="line">修改默认的“自动重定向”为“跟随重定向”</span><br></pre></td></tr></table></figure></p>
<p>Q. JMeter，怎么设置线程组下面指定的请求指定执行多次？<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给想要执行指定循环次数的请求 插入上级-》逻辑控制器 -》循环控制器，然后在循环控制器自定义循环次数。</span><br></pre></td></tr></table></figure></p>
<p>Q. Jmeter如何实现参数化？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用CSV Data Set Config，编码问题在使用CSV Data Set Config参数化时要求的比较严格，记事本另存为修改编码UTF-8.  注意用户名和密码是一一对应的，中间用户逗号（，）隔开。</span><br></pre></td></tr></table></figure></p>
<p>Q. Jmeter定量压测？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constant Throughput Timer 目标吞吐量。注意这里是每分钟发送的请求数，因此，对应测试需求中所要求的20 QPS ，这里的值应该是1200</span><br></pre></td></tr></table></figure></p>
<h3 id="5-1-4-TestNG"><a href="#5-1-4-TestNG" class="headerlink" title="5.1.4 TestNG"></a>5.1.4 TestNG</h3><p>Q. TestNG的特点优势？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 注解</span><br><span class="line">2. 依赖性测试</span><br><span class="line">3. 支持并发测试</span><br><span class="line">4. 支持错误重新运行</span><br><span class="line">5. 参数化测试</span><br><span class="line">6. 支持测试分组</span><br><span class="line">7. 通过testng.xml</span><br><span class="line">8. 详细的测试测试报告</span><br><span class="line">9. 可以运行Junit</span><br></pre></td></tr></table></figure></p>
<p>Q.TestNG的配置文件的作用？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">它定义了所有测试用例的执行顺序。</span><br><span class="line">它允许你对测试用例进行分组, 并可以根据要求执行。</span><br><span class="line">它执行所选的测试用例。</span><br><span class="line">在TestNG中, 可以在套件级别实现侦听器。</span><br><span class="line">它允许你将TestNG框架与Jenkins等工具集成。</span><br></pre></td></tr></table></figure>
<p>Q.在TestNG中@Listener注释的用途是什么？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TestNG提供了不同种类的侦听器, 每当事件触发时, 它们便可以执行不同的操作。 TestNG中使用最广泛的侦听器是ITestListener接口。 ITestListener接口包含诸如onTestSuccess, onTestfailure, onTestSkipped等方法。</span><br><span class="line"></span><br><span class="line">以下是可以实现的方案：</span><br><span class="line"></span><br><span class="line">如果测试用例失败, 那么侦听器应执行什么操作。</span><br><span class="line">如果通过了测试用例, 那么侦听器应执行什么操作。</span><br><span class="line">如果跳过测试用例, 那么侦听器应执行什么操作。</span><br></pre></td></tr></table></figure></p>
<p>Q. @Factory和@DataProvider批注有什么区别？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@DataProvider：TestNG使用它的注解, 根据DataProvider提供的数据多次执行测试方法。</span><br><span class="line"></span><br><span class="line">@Factory：TestNG使用它的注释, 以使用相应类的不同实例来执行同一测试类中存在的测试方法。</span><br></pre></td></tr></table></figure></p>
<p>Q. TestNG的常用注解？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">• @BeforeSuite, @BeforeTest, @BeforeClass, @BeforeMethod, @BeforeGroups</span><br><span class="line">• @AfterSuite, @AfterTest, @AfterClass, @AfterMethod, @AfterGroups</span><br><span class="line">• @DataProvider</span><br><span class="line">• @ExpectedExceptions</span><br><span class="line">• @Factory</span><br><span class="line">• @Test</span><br><span class="line">• @Parameters</span><br></pre></td></tr></table></figure></p>
<p>Q. TestNG并发注解？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@threadPoolSize</span><br><span class="line">@invocationCount</span><br></pre></td></tr></table></figure></p>
<h1 id="6-性能测试"><a href="#6-性能测试" class="headerlink" title="6. 性能测试"></a>6. 性能测试</h1><p>Q.做压力测试时，需要在负载机模拟大量用户，如何判断负载机本身不会成为瓶颈？<br><br>A: <br></p>
<blockquote>
<p>判断被机器的指标，如果是CPU，内存负载较大则说明是机器瓶颈，否则找其他原因</p>
</blockquote>
<p>Q.什么是负载测试？什么是性能测试？ <br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 负载测试是通过逐步增加系统负载，测试系统性能的变化，并最终确定在满足性能指标的情况下，系统所能承受的最大负载量的测试，例如，访问一个页面的响应时间规定不超过1秒，负载测试就是测试在响应时间为1秒时，系统所能承受的最大并发访问用户的数量。</span><br><span class="line">- 压力测试通常是在高负载情况下来对系统的稳定性进行测试，更有效地发现系统稳定性的隐患和系统在负载峰值的条件下功能隐患等。</span><br><span class="line">- 性能测试：指在一定的约束条件下（指定的软件、硬件、网络环境等），确定系统所能承受的最大负载压力。</span><br></pre></td></tr></table></figure></p>
<p>Q.性能测试包含了哪些测试（至少举出3种）?<br><br>A:<br></p>
<blockquote>
<p>性能测试包含负载测试、压力测试、大数据量测试、疲劳强度测试等。</p>
</blockquote>
<p>Q.简述性能测试的步骤?<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 分析产品结构，明确性能测试的需求，包括并发、极限、配置和指标等方面的性能要求，必要时基于LOAD测试的相同测略需同时考虑稳定性测试的需求。</span><br><span class="line">2. 分析应用场景和用户数据，细分用户行为和相关的数据流，确定测试点或测试接口，列示系统接口的可能瓶颈，一般是先主干接口再支线接口，并完成初步的测试用例设计。</span><br><span class="line">3. 依据性能测试需求和确定的测试点进行测试组网设计，并明确不同组网方案的重要程度或优先级作为取舍评估的依据，必要时在前期产品设计中提出支持性能测试的可测试性设计方案和对测试工具的需求。</span><br><span class="line">4. 完成性能测试用例设计、分类选择和依据用户行为分析设计测试规程，并准备好测试用例将用到的测试数据。</span><br><span class="line">5. 确定采用的测试工具。</span><br><span class="line">6. 进行初验测试，以主干接口的可用性为主，根据测试结果分析性能瓶颈，通过迭代保证基本的指标等测试的环境。</span><br><span class="line">7. 迭代进行全面的性能测试，完成计划中的性能测试用例的执行。</span><br><span class="line">8. 完成性能测试评估报告。</span><br></pre></td></tr></table></figure></p>
<p>Q.在进行性能测试的时候，有效的性能指标有哪些？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">一是：通用指标（指Web应用服务器、数据库服务器必需测试项）:</span><br><span class="line">- ProcessorTime:指服务器CPU占用率，一般平均达到70%时，服务就接近饱和</span><br><span class="line">- Memory Available Mbyte:可用内存数，如果测试时发现内存有变化情况也要注意，如果是内存泄露则比较严重</span><br><span class="line">- Physicsdisk Time:物理磁盘读写时间情况</span><br><span class="line">二是：Web服务器指标:</span><br><span class="line">- Avg Rps：平均每秒钟响应次数＝总请求时间/秒数</span><br><span class="line">- Avg time to last byte per terstion（mstes）：平均每秒业务角本的迭代次数</span><br><span class="line">- Successful Rounds：成功的请求</span><br><span class="line">- Failed Rounds：失败的请求</span><br><span class="line">- Successful Hits：成功的点击次数</span><br><span class="line">- Failed Hits：失败的点击次数</span><br><span class="line">- Hits Per Second：每秒点击次数</span><br><span class="line">- Successful Hits Per Second：每秒成功的点击次数</span><br><span class="line">- Failed Hits Per Second：每秒失败的点击次数</span><br><span class="line">- Attempted Connections：尝试链接数</span><br><span class="line">三是：数据库服务器指标</span><br><span class="line">- User 0 Connections ：用户连接数，也就是数据库的连接数量</span><br><span class="line">- Number of deadlocks：数据库死锁</span><br><span class="line">- Butter Cache hit：数据库Cache的命中情况</span><br></pre></td></tr></table></figure></p>
<p>Q.简述使用Loadrunner的步骤?<br><br>A:</p>
<blockquote>
<p>制定性能测试计划—&gt;开发测试脚本—&gt;设计测试场景—&gt;执行测试场景—&gt;监控测试场景—&gt;分析测试结果</p>
</blockquote>
<p>Q.什么时候可以开始执行性能测试?<br><br>A:</p>
<blockquote>
<p>功能测试通过；一般需要进行性能测试的系统，都是用户量比较大、业务使用比较频繁、比较重要的功能模块。</p>
</blockquote>
<p>Q. LoadRunner由哪些部件组成?<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. Vuser Generator（虚拟用户，脚本开发的）</span><br><span class="line">2. Controller（指挥官的作用）</span><br><span class="line">3. Analysis（收集测试数据，进行结果分析的）</span><br><span class="line">4. load Generator（产生压力的机器）</span><br></pre></td></tr></table></figure></p>
<p>Q.为什么要创建参数?如何创建参数?<br><br>A:<br></p>
<blockquote>
<p>参数：在环境变化时必须时脚本具有环境变化的能力，就需要参数化（客户端发送到服务器端）</p>
</blockquote>
<p>Q.什么是集合点？设置集合点有什么意义？Loadrunner中设置集合点的函数是哪个？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在性能测试过程中，需要模拟大量用户在同一时刻，访问系统并同时操作某一任务，可以通过配置集合点来实现，多个用户同时进行某操作；</span><br><span class="line">集合点可以在服务器上创建密集的用户负载，使LoadRunner能够测试服务器在负载状态下的性能。</span><br><span class="line">设置集合点函数：lr_rendezvous(&quot;Meeting&quot;)； // Meeting是集合点名称</span><br></pre></td></tr></table></figure></p>
<p>Q.全链路压测中，某台服务器CPU 100%了，有可能是什么问题？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. jps -m 非常方便直接定位所有的Java进程pid</span><br><span class="line">2. jstack -l pid &gt; jstack1031.log命令打印栈信息，如果因某些原因无法成功打印</span><br><span class="line">3. 查找占用CPU资源最高的进程id，使用top -H -p pid 查看进程pid的所有的线程，默认是按照%CPU高~低排序。</span><br><span class="line">4.</span><br></pre></td></tr></table></figure></p>
<h1 id="7-Mysql数据库相关"><a href="#7-Mysql数据库相关" class="headerlink" title="7. Mysql数据库相关"></a>7. Mysql数据库相关</h1><p>Q.说下左连接和右连接 <br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * from A left join B where A.id = B.id.</span><br><span class="line">左连接是A表的所有记录都显示，B表里没有的显示为null</span><br><span class="line">右连接是符合条件的B表中的内容全部显示，A表中没用的显示为null</span><br><span class="line">inner join 内关联只会显示主表和从表相关联的字段，不会出现null</span><br></pre></td></tr></table></figure></p>
<p>Q.介绍下什么是索引<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">索引是与表或视图关联的磁盘上结构，可以加快从表或视图中检索行的速度。索引包含由表或视图中一列或多列生成的键。</span><br></pre></td></tr></table></figure></p>
<p>Q.使用sql生产10万条数据 <br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 使用事务提交，批量插入数据库(每隔1W条提交下)</span><br><span class="line">2. 使用优化SQL语句：将SQL语句进行拼接，使用 insert into table () values (),(),(),()然后再一次性插入，如果字符串太长，则需要配置下MYSQL，在mysql 命令行中运行 ：set global max_allowed_packet = 2*1024*1024*10;</span><br></pre></td></tr></table></figure></p>
<p>Q.Mysql复制原理以及流程？<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 主：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；</span><br><span class="line">2. 从：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进 自己的relay log中；</span><br><span class="line">3. 从：sql执行线程——执行relay log中的语句；</span><br></pre></td></tr></table></figure></p>
<p>Q.MySQL中myisam与innodb的区别，至少5点? <br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1&gt;.InnoDB支持事物，而MyISAM不支持事物</span><br><span class="line">2&gt;.InnoDB支持行级锁，而MyISAM支持表级锁</span><br><span class="line">3&gt;.InnoDB支持MVCC, 而MyISAM不支持</span><br><span class="line">4&gt;.InnoDB支持外键，而MyISAM不支持</span><br><span class="line">5&gt;.InnoDB不支持全文索引，而MyISAM支持。</span><br></pre></td></tr></table></figure></p>
<p>Q.MySQL中varchar与char的区别以及varchar(50)中的50代表的涵义? <br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1)、varchar与char的区别char是一种固定长度的类型，varchar则是一种可变长度的类型</span><br><span class="line">(2)、varchar(50)中50的涵义最多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)</span><br><span class="line">(3)、int（20）中20的涵义是指显示字符的长度但要加参数的，最大为255，比如它是记录行数的id,插入10笔资料，它就显示00000000001 ~~~00000000010，当字符的位数超过11,它也只显示11位，如果你没有加那个让它未满11位就前面加0的参数，它不会在前面加020表示最大显示宽度为20，但仍占4字节存储，存储范围不变；</span><br></pre></td></tr></table></figure></p>
<p>Q.列举创建索引但是无法命中索引的8种情况?<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、查询条件中有or、not in、not exist等</span><br><span class="line">2、小表查询</span><br><span class="line">3、like查询是以%开头</span><br><span class="line">4、如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引</span><br><span class="line">5、没有使用索引字段查询</span><br><span class="line">6、对索引列进行运算，需要建立函数索引</span><br><span class="line">7、单独引用联合索引中的非第一位置的索引</span><br><span class="line">8、没有查询条件</span><br></pre></td></tr></table></figure></p>
<p>Q.如何开启慢日志查询？<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">slow_query_log： 慢查询开启状态</span><br><span class="line">slow_query_log_file：慢查询日志存放的位置（这个目录需要MySQL的运行帐号的可写权限，一般设置为MySQL的数据存放目录）</span><br><span class="line">long_query_time：查询超过多少秒才记录</span><br><span class="line">- 全局变量设置</span><br><span class="line">1、将 slow_query_log 全局变量设置为“ON”状态。指令示例：mysql&gt; set global slow_query_log=&apos;ON&apos;;</span><br><span class="line">2、设置慢查询日志存放的位置：mysql&gt; set global slow_query_log_file=&apos;/usr/local/mysql/data/slow.log&apos;;</span><br><span class="line">3、查询超过1秒就记录：mysql&gt; set global long_query_time=1;</span><br></pre></td></tr></table></figure></p>
<p>Q.数据库导入导出命令（结构+数据）？<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">导出数据库结构和数据：mysqldump -u用户名 -p密码 数据库名&gt; 路径+导出的文件名.sql</span><br><span class="line">导出数据库所有表结构：mysqldump -u用户名 -p密码 -d 数据库名&gt;路径+文件名.sql</span><br><span class="line">导出数据表结构和数据：mysqldump -u用户名 -p密码 数据库名 表名&gt;路径+文件名.sql</span><br><span class="line">导出数据表结构：mysqldump -u用户名 -p密码 -d 数据库名 表名&gt;路径+文件名.sql</span><br></pre></td></tr></table></figure></p>
<p>Q.数据库优化的思路? <br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- 1.SQL语句优化</span><br><span class="line">1）应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</span><br><span class="line">2）应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：select id from t where num is null</span><br><span class="line">可以在num上设置默认值0，确保表中num列没有null值**，然后这样查询：</span><br><span class="line">select id from t where num=0</span><br><span class="line">3）很多时候用 exists 代替 in 是一个好的选择</span><br><span class="line">4）用Where子句替换HAVING 子句 因为HAVING 只会在检索出所有记录之后才对结果集进行过滤</span><br><span class="line"></span><br><span class="line">- 2.索引优化</span><br><span class="line">合理使用：普通索引、唯一索引(主键索引、唯一索引)、联合索引、全文索引、空间索引</span><br><span class="line"></span><br><span class="line">- 3.数据库结构优化</span><br><span class="line">1）范式优化：</span><br><span class="line">比如消除冗余（节省空间。。）</span><br><span class="line">2）反范式优化：</span><br><span class="line">比如适当加冗余等（减少join）</span><br><span class="line">3）拆分表：</span><br><span class="line">分区将数据在物理上分隔开，不同分区的数据可以制定保存在处于不同磁盘上的数据文件里。这样，当对这个表进行查询时，只需要在表分区中进行扫描，而不必进行全表扫描，明显缩短了查询时间，另外处于不同磁盘的分区也将对这个表的数据传输分散在不同的磁盘I/O，一个精心设置的分区可以将数据传输对磁盘I/O竞争均匀地分散开。对数据量大的时时表可采取此方法。可按月自动建表分区。</span><br><span class="line">4）拆分其实又分垂直拆分和水平拆分：</span><br><span class="line">案例： 简单购物系统暂设涉及如下表：</span><br><span class="line">1.产品表（数据量10w，稳定）</span><br><span class="line">2.订单表（数据量200w，且有增长趋势）</span><br><span class="line">3.用户表 （数据量100w，且有增长趋势） 以mysql为例讲述下水平拆分和垂直拆分，mysql能容忍的数量级在百万静态数据可以到千万。</span><br><span class="line">垂直拆分：解决问题：表与表之间的io竞争 。不解决问题：单表中数据量增长出现的压力。</span><br><span class="line">方案： 把产品表和用户表放到一个server上 订单表单独放到一个server上</span><br><span class="line">水平拆分： 解决问题：单表中数据量增长出现的压力 不解决问题：表与表之间的io争夺。</span><br><span class="line">方案： 用户表通过性别拆分为男用户表和女用户表，订单表通过已完成和完成中拆分为已完成订单和未完成订单， 产品表、未完成订单放一个server上；已完成订单表和男用户表放一个server上；女用户表放一个server上(女的爱购物 哈哈)</span><br><span class="line">- 4.服务器硬件优化</span><br></pre></td></tr></table></figure></p>
<p>Q. 简述MySQL的执行计划？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在工作过程中，有时候会对慢查询进行调优。对于MySQL的SQL语句调优，MySQL本身提供了强大的explain关键字用于查询分析执行计划。</span><br><span class="line">语法：从语法角度explain和describe/desc是相同的，只是一般更常用desc看表结构，explain来看查询计划。</span><br></pre></td></tr></table></figure></p>
<p>Q. 在对name做了唯一索引前提下，简述以下区别?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from tb where name = ‘Oldboy-Wupeiqi’ # 全局遍历找所有</span><br><span class="line">select * from tb where name = ‘Oldboy-Wupeiqi’ limit 1 # 锁定一条就结束</span><br></pre></td></tr></table></figure></p>
<p>Q.什么是sql注入？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQL注入攻击指的是通过构建特殊的输入作为参数传入Web应用程序，而这些输入大都是SQL语法里的一些组合，通过执行SQL语句进而执行攻击者所要的操作，其主要原因是程序没有细致地过滤用户输入的数据，致使非法数据侵入系统。</span><br></pre></td></tr></table></figure></p>
<p>Q.关于sql语句应该考虑哪些安全性？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.防止sql注入，对特殊字符进行转义，过滤或者使用预编译的sql语句绑定变量。</span><br><span class="line">2.最小权限原则，特别是不要用root账户，为不同的类型的动作或者组建使用不同的账户。</span><br><span class="line">3.当sql运行出错时，不要把数据库返回的错误信息全部显示给用户，以防止泄漏服务器和数据库相关信息。</span><br></pre></td></tr></table></figure></p>
<p>Q.一张表,里面有ID自增主键,当insert了17条记录之后,删除了第15,16,17条记录,再把Mysql重启,再insert一条记录,这条记录的ID是18还是15 ？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果表的类型是MyISAM，那么是18。</span><br><span class="line">因为MyISAM表会把自增主键的最大ID记录到数据文件里，重启MySQL自增主键的最大ID也不会丢失。</span><br><span class="line">如果表的类型是InnoDB，那么是15。</span><br><span class="line">InnoDB表只是把自增主键的最大ID记录到内存中，所以重启数据库或者是对表进行OPTIMIZE操作，都会导致最大ID丢失。</span><br></pre></td></tr></table></figure></p>
<p>Q.简述数据库分库分表？（水平、垂直）?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">垂直分库：就是按照功能的不同，把没有关联的数据放到不同的数据库和服务器中</span><br><span class="line">水平分表：根据一定的规则将一个表的数据划分到不同的数据库中，两个数据库的表结构一样。</span><br></pre></td></tr></table></figure></p>
<p>Q.MySQL中InnoDB引擎的行锁是通过加在什么上完成(或称实现)的？为什么是这样子的？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InnoDB是基于索引来完成行锁例: select * from tab_with_index where id = 1 for update;for update 可以根据条件来完成行锁锁定,并且 id 是有索引键的列,如果 id 不是索引键那么InnoDB将完成表锁,,并发将无从谈起</span><br></pre></td></tr></table></figure></p>
<p>Q.SQL数据库命令，求救查询平均成绩?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、查询至少选修了2门课程的每个学生的平均成绩的语句是什么啊？</span><br><span class="line">2、使用UNION运算符将student_info表中姓“张”的学生的学号、姓名与curriculum表的课程编号、课程名称返回在一个表中，且列名为u_编号、u_名称。</span><br><span class="line">三个表格式如下</span><br><span class="line">表curriculum（课程编号、课程名称、学分）</span><br><span class="line">表grade（学号、课程编号、分数）</span><br><span class="line">表student_info(学号，姓名，性别，出生日期，家庭地址)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>select 学号, avg(分数) from grade group by 学号 having count(distinct 课程编号) &gt; 1</p>
</blockquote>
<blockquote>
<p>select 学号 as u_编号, 姓名 as u_名称<br>from student_info where 姓名 like ‘张%’<br>union<br>select 课程编号 as u_编号, 课程名称 as u_名称<br>from curriculum</p>
</blockquote>
<h1 id="8-Linux"><a href="#8-Linux" class="headerlink" title="8. Linux"></a>8. Linux</h1><p>Q.常用的命令？<br>A:</p>
<blockquote>
<p>ls,cd, mkdir, cat, vi, ps, touch,tail, less, head, ifconfig</p>
</blockquote>
<p>Q.用什么查看log？<br>A:</p>
<blockquote>
<p>watch, tail、cat、tac、head、echo</p>
</blockquote>
<p>Q.如何查找一个文件大小超过5M的文件?<br><br>A:</p>
<blockquote>
<p>find . -type f -size +5m</p>
</blockquote>
<p>Q.如何查看进程？<br><br>A:</p>
<blockquote>
<p>ps aux | less</p>
</blockquote>
<p>Q.一行命令关闭指定端口的对应进程？<br><br>A:<br></p>
<blockquote>
<p>kill <code>netstat -nlp | grep :3306 | awk &#39;{print $7}&#39; | awk -F&quot;/&quot; &#39;{ print $1 }&#39;</code> </p>
</blockquote>
<p>Q: Scp命令？并写出测试用例<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(1) 复制文件： </span><br><span class="line">scp local_file remote_username@remote_ip:remote_folder </span><br><span class="line">(2) 复制目录： </span><br><span class="line">scp -r local_folder remote_username@remote_ip:remote_folder </span><br><span class="line"></span><br><span class="line">测试用例设计：</span><br><span class="line">1. 命令格式</span><br><span class="line">2. 命令功能</span><br><span class="line">3. 命令参数</span><br><span class="line">4. 特殊异常情况</span><br></pre></td></tr></table></figure></p>
<p>Q. 截取日志文件中某个时间段的信息？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &apos;/2015-05-04 09:25:55/,/2015-05-04 09:28:55/p&apos; logfile</span><br></pre></td></tr></table></figure></p>
<p>Q.scp 复制后如何查看是否完全复制?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md5sum验证文件传输过程中是否不一致</span><br></pre></td></tr></table></figure></p>
<p>Q.写出软链接和硬链接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">软链接（符号链接） ln -s   source  target </span><br><span class="line">硬链接 （实体链接）ln       source  target</span><br></pre></td></tr></table></figure></p>
<p>Q.配置文件的区别~/.bash_profile、~/.bashrc、和~/.bash_logout?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.上面这三个文件是bash shell的用户环境配置文件，位于用户的主目录下。其中.bash_profile是最重要的一个配置文件，它在用户每次登录系统时被读取，里面的所有命令都会被bash执行。.profile(由Bourne Shell和Korn Shell使用)和.login(由C Shell使用)两个文件是.bash_profile的同义词，目的是为了兼容其它Shell。在Debian中使用.profile文件代 替.bash_profile文件。</span><br><span class="line">2.bashrc文件会在bash shell调用另一个bash shell时读取，也就是在shell中再键入bash命令启动一个新shell时就会去读该文件。这样可有效分离登录和子shell所需的环境。但一般 来说都会在.bash_profile里调用.bashrc脚本以便统一配置用户环境。</span><br><span class="line">3.bash_logout在退出shell时被读取。所以我们可把一些清理工作的命令放到这文件中</span><br></pre></td></tr></table></figure></p>
<p>Q.Vi命令的常用操作？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;$&quot;命令将光标移动到当前行行尾。如果你的键盘上有一个键，它的作用也一样。</span><br><span class="line">&quot;^&quot;命令将光标移动到当前行的第一个非空白字符上。</span><br><span class="line">:s/vivian/sky/ 替换当前行第一个 vivian 为 sky </span><br><span class="line">:s/vivian/sky/g 替换当前行所有 vivian 为 sky</span><br></pre></td></tr></table></figure></p>
<p>Q.查询文本不区分大小写？<br>A:</p>
<blockquote>
<p>cat main.go | grep -i “println”<br>fmt.Println(“hello”)</p>
</blockquote>
<p>Q.如何获取文件的最后一行?<br>A:</p>
<blockquote>
<p>tail -l</p>
</blockquote>
<p>Q.假如文件中每行第一个元素是 FIND，如何获取第二个元素<br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk&apos;&#123; if ($1 == &quot;FIND&quot;) print $2&#125;&apos;</span><br><span class="line">awk -F &apos;:&apos; &apos;&#123;print $1 &quot;\t&quot; $4&#125;&apos; student.txt</span><br></pre></td></tr></table></figure></p>
<p>Q.如何调试 bash 脚本<br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将 -xv 参数加到 #!/bin/bash 后</span><br><span class="line">例子：</span><br><span class="line">&gt; #!/bin/bash –xv</span><br></pre></td></tr></table></figure></p>
<p>Q.如何检查文件系统中是否存在某个文件?<br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">if [ -f /var/log/messages ]</span><br><span class="line">then</span><br><span class="line">echo &quot;File exists&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">文件表达式</span><br><span class="line">-e filename 如果 filename存在，则为真</span><br><span class="line">-d filename 如果 filename为目录，则为真 </span><br><span class="line">-f filename 如果 filename为常规文件，则为真</span><br><span class="line">-L filename 如果 filename为符号链接，则为真</span><br><span class="line">-r filename 如果 filename可读，则为真 </span><br><span class="line">-w filename 如果 filename可写，则为真 </span><br><span class="line">-x filename 如果 filename可执行，则为真</span><br><span class="line">-s filename 如果文件长度不为0，则为真</span><br><span class="line">-h filename 如果文件是软链接，则为真</span><br><span class="line">filename1 -nt filename2 如果 filename1比 filename2新，则为真。</span><br><span class="line">filename1 -ot filename2 如果 filename1比 filename2旧，则为真。</span><br></pre></td></tr></table></figure></p>
<p>Q.如何查找占用某个端口的进程id？如何杀掉该进程？<br><br>A:</p>
<blockquote>
<p>netstat -apn | grep 4040 | kill -9 26105</p>
</blockquote>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>Q.什么是守护进程？<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">守护进程(daemon)是一类在后台运行的特殊进程，用于执行特定的系统任务。很多守护进程在系统引导的时候启动，并且一直运行直到系统关闭。另一些只在需要的时候才启动，完成任务后就自动结束。</span><br></pre></td></tr></table></figure></p>
<p>Q.什么是僵尸进程？<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个进程在调用exit命令结束自己的生命的时候，其实它并没有真正的被销毁， 而是留下一个称为僵尸进程（Zombie）的数据结构（系统调用exit，它的作用是 使进程退出，但也仅仅限于将一个正常的进程变成一个僵尸进程，并不能将其完全销毁）</span><br></pre></td></tr></table></figure></p>
<p>Q.I/O复用模型之epoll?<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">epoll是Linux多路服用IO接口select/poll的加强版，e对应的英文单词就是enhancement，中文翻译为增强，加强，提高，充实的意思。所以epoll模型会显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。</span><br><span class="line">epoll把用户关心的文件描述符上的时间放在内核的一个事件表中，无需像select和poll那样每次调用都重复传入文件描述符集。</span><br><span class="line">epoll在获取事件的时候，无需遍历整个被监听的文件描述符集合，而是遍历那些被内核IO事件异步唤醒而加入ready队列的描述符集合。</span><br><span class="line">所以，epoll是Linux大规模高并发网络程序的首选模型。</span><br></pre></td></tr></table></figure></p>
<h1 id="9-网络相关"><a href="#9-网络相关" class="headerlink" title="9. 网络相关"></a>9. 网络相关</h1><p>Q.七层网络协议模型和四层网络模型<br><br>A:</p>
<p>OSI七层网络协议:<br></p>
<table>
<thead>
<tr>
<th>层</th>
<th>数据单元</th>
<th>协议</th>
</tr>
</thead>
<tbody>
<tr>
<td>物理层</td>
<td>比特</td>
<td></td>
</tr>
<tr>
<td>数据链路层</td>
<td>帧</td>
<td></td>
</tr>
<tr>
<td>网络层</td>
<td>报文</td>
<td>IP</td>
</tr>
<tr>
<td>传输层</td>
<td>TPDU</td>
<td>TCP/UDP</td>
</tr>
<tr>
<td>会话层</td>
<td>SPDU</td>
<td></td>
</tr>
<tr>
<td>表示层</td>
<td>PPDU</td>
<td></td>
</tr>
<tr>
<td>应用层</td>
<td>APDU</td>
<td>HTTP</td>
</tr>
</tbody>
</table>
<p>四层模型：<br><br>层 | 协议<br>— | —<br>应用层 | Telnet<br>运输层 | TCP/UDP<br>网络层 | IP<br>链路层 | 设备驱动</p>
<p>Q.请解释下TCP协议的三次交手,四次挥手，以及每步的原因？<br><br>A:<br></p>
<ul>
<li>三次握手：</li>
</ul>
<ol>
<li>第一步：源主机A的TCP向主机B发出连接请求报文段，其首部中的SYN(同步)标志位应置为1，表示想与目标主机B进行通信，并发送一个同步序列号X(例：SEQ=100)进行同步，表明在后面传送数据时的第一个数据字节的序号是X＋1（即101）。SYN同步报文会指明客户端使用的端口以及TCP连接的初始序号。</li>
<li>第二步：目标主机B的TCP收到连接请求报文段后，如同意，则发回确认。在确认报中应将ACK位和SYN位置1，表示客户端的请求被接受。确认号应为X＋1(图中为101)，同时也为自己选择一个序号Y。</li>
<li>第三步：源主机A的TCP收到目标主机B的确认后要向目标主机B给出确认，其ACK置1，确认号为Y＋1，而自己的序号为X＋1。TCP的标准规定，SYN置1的报文段要消耗掉一个序号。<br>　　运行客户进程的源主机A的TCP通知上层应用进程，连接已经建立。当源主机A向目标主机B发送第一个数据报文段时，其序号仍为X＋1，因为前一个确认报文段并不消耗序号。<br>　　当运行服务进程的目标主机B的TCP收到源主机A的确认后，也通知其上层应用进程，连接已经建立。至此建立了一个全双工的连接。</li>
</ol>
<ul>
<li>四次挥手：</li>
</ul>
<ol>
<li>第一步：源主机A的应用进程先向其TCP发出连接释放请求，并且不再发送数据。TCP通知对方要释放从A到B这个方向的连接，将发往主机B的TCP报文段首部的终止比特FIN置1，其序号X等于前面已传送过的数据的最后一个字节的序号加1。</li>
<li>第二步：目标主机B的TCP收到释放连接通知后即发出确认，其序号为Y，确认号为X＋1，同时通知高层应用进程，这样，从A到B的连接就释放了，连接处于半关闭状态，相当于主机A向主机B说：“我已经没有数据要发送了。但如果还发送数据，我仍接收。”此后，主机B不再接收主机A发来的数据。但若主机B还有一些数据要发送主机A，则可以继续发送。主机A只要正确收到数据，仍应向主机B发送确认。</li>
<li>第三步：若主机B不再向主机A发送数据，其应用进程就通知TCP释放连接。主机B发出的连接释放报文段必须将终止比特FIN和确认比特ACK置1，并使其序号仍为Y，但还必须重复上次已发送过的ACK＝X＋1。</li>
<li><p>第四步：主机A必须对此发出确认，将ACK置1，ACK＝Y＋1，而自己的序号是X＋1。这样才把从B到A的反方向的连接释放掉。主机A的TCP再向其应用进程报告，整个连接已经全部释放</p>
<p> <img src="https://img-blog.csdn.net/20160809153521584" alt="avatar"></p>
</li>
</ol>
<p>Q.为什么连接的时候是三次握手，关闭的时候却是四次握手？<br><br>A:<br>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p>
<p>Q.为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？<br><br>A:<br><br>虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p>
<p>Q.服务端为了解决这个TIME_WAIT问题?<br><br>A:<br><br>可选择的方式有三种：</p>
<pre><code>Ø  保证由客户端主动发起关闭（即做为B端）
Ø  关闭的时候使用RST的方式
Ø  对处于TIME_WAIT状态的TCP允许重用,SO_REUSEADDR
</code></pre><p>Q.客户端主动关闭连接？<br><br>A:<br><br>一般Apache的配置是：</p>
<pre><code>Timeout 30  
KeepAlive On   #表示服务器端不会主动关闭链接  
MaxKeepAliveRequests 100  
KeepAliveTimeout 180  
表示：Apache不会主动关闭链接，
</code></pre><p>两种情况下Apache会主动关闭连接：</p>
<ol>
<li>Apache收到了http协议头中有客户端要求Apache关闭连接信息，如setRequestHeader(“Connection”, “close”);  </li>
<li>连接保持时间达到了180秒的超时时间，将关闭。<br>如果配置如下：<br>KeepAlive Off   #表示服务器端会响应完数据后主动关闭链接  </li>
</ol>
<p>Q.如果tcp建立连接时第三次握手失败，tcp会做何操作？<br><br>A:<br><br>当失败时服务器并不会重传ack报文，而是直接发送RTS报文段，进入CLOSED状态。这样做的目的是为了防止SYN洪泛攻击。</p>
<p><img src="https://img-blog.csdn.net/20130922231845953" alt="image"></p>
<p>Q.Http与TCP的区别？<br><br>A:</p>
<ol>
<li>Http是短连接，客户端发送请求都需要服务器端回送响应.请求结束后，主动释放链接，因此为短连接。HTTP连接使用的是”请求-响应”方式，不仅在请求时建立连接，而且客户端向服务器端请求后，服务器才返回数据。</li>
<li>Socket是对TCP/IP协议的封装，Socket知识接口不是协议，通过 Socket 我们才能使用 TCP/IP 协议，除了 TCP，也可以使用 UDP 协议来传递数据。创建 Socket 连接的时候，可以指定传输层协议，可以是 TCP 或者 UDP，当用 TCP 连接，该Socket就是个TCP连接，反之。</li>
<li>Socket为长连接：通常情况下Socket 连接就是 TCP 连接，因此 Socket 连接一旦建立,通讯双方开始互发数据内容，直到双方断开连接。在实际应用中，由于网络节点过多，在传输过程中，会被节点断开连接，因此要通过轮询高速网络，该节点处于活跃状态。</li>
<li>很多情况下，都是需要服务器端向客户端主动推送数据，保持客户端与服务端的实时同步。<br> 若双方是 Socket 连接，可以由服务器直接向客户端发送数据。<br> 若双方是 HTTP 连接，则服务器需要等客户端发送请求后，才能将数据回传给客户端。<br> 因此，客户端定时向服务器端发送请求，不仅可以保持在线，同时也询问服务器是否有新数据，如果有就将数据传给客户端。</li>
</ol>
<p>Q.http的keep-alive和tcp的keepalive区别？<br><br>A:<br></p>
<ol>
<li>在http早期，每个http请求都要求打开一个tcp socket连接，并且使用一次之后就断开这个tcp连接。<br>使用keep-alive可以改善这种状态，即在一次TCP连接中可以持续发送多份数据而不会断开连接。通过使用keep-alive机制，可以减少tcp连接建立次数，也意味着可以减少TIME_WAIT状态连接，以此提高性能和提高httpd服务器的吞吐率(更少的tcp连接意味着更少的系统内核调用,socket的accept()和close()调用)。但是，keep-alive并不是免费的午餐,长时间的tcp连接容易导致系统资源无效占用。配置不当的keep-alive，有时比重复利用连接带来的损失还更大。所以，正确地设置keep-alive timeout时间非常重要。</li>
<li>TCP的keepalive,链接建立之后，如果应用程序或者上层协议一直不发送数据，或者隔很长时间才发送一次数据，当链接很久没有数据报文传输时如何去确定对方还在线，到底是掉线了还是确实没有数据传输，链接还需不需要保持，这种情况在TCP协议设计中是需要考虑到的。<br>TCP协议通过一种巧妙的方式去解决这个问题，当超过一段时间之后，TCP自动发送一个数据为空的报文给对方，如果对方回应了这个报文，说明对方还在线，链接可以继续保持，如果对方没有报文返回，并且重试了多次之后则认为链接丢失，没有必要保持链接。</li>
</ol>
<p>http的keep-alive:<br>    <img src="https://img-blog.csdn.net/20160405143505594?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="avatar"></p>
<p>Q.TCP与UDP的区别？<br><br>A:<br></p>
<ol>
<li>TCP提供面向连接的传输，通信前要先建立连接（三次握手机制）；UDP提供无连接的传输，通信前不需要建立连接。</li>
<li>TCP提供可靠的传输（有序，无差错，不丢失，不重复）；UDP提供不可靠的传输。</li>
<li>TCP面向字节流的传输，因此它能将信息分割成组，并在接收端将其重组；UDP是面向数据报的传输，没有分组开销。</li>
<li>TCP提供拥塞控制和流量控制机制；UDP不提供拥塞控制和流量控制机制。</li>
</ol>
<p>Q.TCP的流量控制和拥塞控制的实现机制? <br><br>A:<br></p>
<ol>
<li><p>TCP采用大小可变的滑动窗口机制实现流量控制功能。窗口的大小是字节。在TCP报文段首部的窗口字段写入的数值就是当前给对方设置发送窗口的数据的上限。在数据传输过程中，TCP提供了一种基于滑动窗口协议的流量控制机制，用接收端接收能力（缓冲区的容量）的大小来控制发送端发送的数据量。</p>
</li>
<li><p>采用滑动窗口机制还可对网络进行拥塞控制，将网络中的分组（TCP报文段作为其数据部分）数量维持在一定的数量之下，当超过该数值时，网络的性能会急剧恶化。传输层的拥塞控制有慢开始（Slow-Start）、拥塞避免（Congestion Avoidance）、快重传（Fast Retransmit）和快恢复（Fast Recovery）四种算法。<br>拥塞：　大量数据报涌入同一交换节点（如路由器），导致该节点资源耗尽而必须丢弃后面到达的数据报时，就是拥塞。</p>
</li>
</ol>
<p>Q.Socket重传机制？<br><br>A:<br><br>TCP每发送一个报文段，就设置一次定时器。只要定时器设置的重发时间到而还没有收到确认，就要重发这一报文段。<br>TCP环境<br>报文往返时间不定、有很大差别<br>A、B在一个局域网络，往返时延很小<br>A、C在一个互联网内，往返时延很大<br>因此，A很难确定一个固定的、与B、C通信都适用的定时器时间<br>TCP采用了一种自适应算法。这种算法记录每一个报文段发出的时间，以及收到相应的确认报文段的时间。这两个时间之差就是报文段的往返时延。将各个报文段的往返时延样本加权平均，就得出报文段的平均往返时延T。</p>
<p>Q.Socket滑动窗口机制?<br><br>A:<br><br>TCP 采用大小可变的滑动窗口进行流量控制。窗口大小的单位是字节。<br>在 TCP 报文段首部的窗口字段写入的数值就是当前给对方设置的发送窗口数值的上限。发送窗口在连接建立时由双方商定。但在通信的过程中，接收端可根据自己的资源情况，随时动态地调整对方的发送窗口上限值(可增大或减小)</p>
<p>Q.多线程如何同步？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">临界区、互斥区、事件、信号量四种方式</span><br><span class="line">临界区（Critical Section）、互斥量（Mutex）、信号量（Semaphore）、事件（Event）的区别</span><br><span class="line"></span><br><span class="line">1）、临界区：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。</span><br><span class="line"></span><br><span class="line">2）、互斥量：采用互斥对象机制。 只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享 .互斥量比临界区复杂。因为使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。</span><br><span class="line"></span><br><span class="line">3）、信号量：它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目 .信号量对象对线程的同步方式与前面几种方法不同，信号允许多个线程同时使用共享资源，这与操作系统中的PV操作相同。它指出了同时访问共享资源的线程最大数目。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。</span><br><span class="line"></span><br><span class="line">PV操作及信号量的概念都是由荷兰科学家E.W.Dijkstra提出的。信号量S是一个整数，S大于等于零时代表可供并发进程使用的资源实体数，但S小于零时则表示正在等待使用共享资源的进程数。</span><br><span class="line">　　 P操作申请资源：</span><br><span class="line">　　 1. S减1；</span><br><span class="line">　　（2）若S减1后仍大于等于零，则进程继续执行；</span><br><span class="line">　　（3）若S减1后小于零，则该进程被阻塞后进入与该信号相对应的队列中，然后转入进程调度。</span><br><span class="line">　　V操作 释放资源：</span><br><span class="line">　　（1）S加1；</span><br><span class="line">　　（2）若相加结果大于零，则进程继续执行；</span><br><span class="line">　　（3）若相加结果小于等于零，则从该信号的等待队列中唤醒一个等待进程，然后再返回原进程继续执行或转入进程调度。</span><br><span class="line"></span><br><span class="line">4）事 件： 通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作 .</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line">　　1） 互斥量与临界区的作用非常相似，但互斥量是可以命名的，也就是说它可以跨越进程使用。所以创建互斥量需要的资源更多，所以如果只为了在进程内部是用的话使用临界区会带来速度上的优势并能够减少资源占用量。因为互斥量是跨进程的互斥量一旦被创建，就可以通过名字打开它。</span><br><span class="line">　　2） 互斥量（Mutex），信号灯（Semaphore），事件（Event）都可以被跨越进程使用来进行同步数据操作，而其他的对象与数据同步操作无关，但对于进程和线程来讲，如果进程和线程在运行状态则为无信号状态，在退出后为有信号状态。所以可以使用WaitForSingleObject来等待进程和线程退出。</span><br><span class="line">　　3） 通过互斥量可以指定资源被独占的方式使用，但如果有下面一种情况通过互斥量就无法处理，比如现在一位用户购买了一份三个并发访问许可的数据库系统，可以根据用户购买的访问许可数量来决定有多少个线程/进程能同时进行数据库操作，这时候如果利用互斥量就没有办法完成这个要求，信号灯对象可以说是一种资源计数器。</span><br></pre></td></tr></table></figure></p>
<p>Q.信号与信号量的区别？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 信号：（signal）是一种处理异步事件的方式。信号时比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程外，还可以发送信号给进程本身。linux除了支持unix早期的信号语义函数，还支持语义符合posix.1标准的信号函数sigaction。</span><br><span class="line">2. 信号量：（Semaphore）线程间通信处理同步互斥的机制。是在多线程环境下使用的一种设施, 它负责协调各个线程, 以保证它们能够正确、合理的使用公共资源。</span><br></pre></td></tr></table></figure></p>
<p>Q.进程与线程的区别？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1、首先是定义</span><br><span class="line"></span><br><span class="line">进程：是执行中一段程序，即一旦程序被载入到内存中并准备执行，它就是一个进程。进程是表示资源分配的的基本概念，又是调度运行的基本单位，是系统中的并发执行的单位。</span><br><span class="line"></span><br><span class="line">线程：单个进程中执行中每个任务就是一个线程。线程是进程中执行运算的最小单位。</span><br><span class="line"></span><br><span class="line">2、一个线程只能属于一个进程，但是一个进程可以拥有多个线程。多线程处理就是允许一个进程中在同一时刻执行多个任务。</span><br><span class="line"></span><br><span class="line">3、线程是一种轻量级的进程，与进程相比，线程给操作系统带来侧创建、维护、和管理的负担要轻，意味着线程的代价或开销比较小。</span><br><span class="line"></span><br><span class="line">4、线程没有地址空间，线程包含在进程的地址空间中。线程上下文只包含一个堆栈、一个寄存器、一个优先权，线程文本包含在他的进程 的文本片段中，进程拥有的所有资源都属于线程。所有的线程共享进程的内存和资源。同一进程中的多个线程共享代码段(代码和常量)，数据段(全局变量和静态变量)，扩展段(堆存储)。但是每个线程拥有自己的栈段， 寄存器的内容，栈段又叫运行时段，用来存放所有局部变量和临时变量。</span><br><span class="line"></span><br><span class="line">5、父和子进程使用进程间通信机制，同一进程的线程通过读取和写入数据到进程变量来通信。</span><br><span class="line"></span><br><span class="line">6、进程内的任何线程都被看做是同位体，且处于相同的级别。不管是哪个线程创建了哪一个线程，进程内的任何线程都可以销毁、挂起、恢复和更改其它线程的优先权。线程也要对进程施加控制，进程中任何线程都可以通过销毁主线程来销毁进程，销毁主线程将导致该进程的销毁，对主线程的修改可能影响所有的线程。</span><br><span class="line"></span><br><span class="line">7、子进程不对任何其他子进程施加控制，进程的线程可以对同一进程的其它线程施加控制。子进程不能对父进程施加控制，进程中所有线程都可以对主线程施加控制。</span><br><span class="line"></span><br><span class="line">相同点：</span><br><span class="line"></span><br><span class="line">进程和线程都有ID/寄存器组、状态和优先权、信息块，创建后都可更改自己的属性，都可与父进程共享资源、都不能直接访问其他无关进程或线程的资源</span><br></pre></td></tr></table></figure></p>
<p>Q.进程间通讯的方式有哪些？各有什么优缺点？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 管道：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程之间使用。进程的亲缘关系通常是指父子进程关系。</span><br><span class="line">2. 有名管道（FIFO）：有名管道也是半双工的通信方式，但是允许在没有亲缘关系的进程之间使用，管道是先进先出的通信方式。</span><br><span class="line">3. 信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</span><br><span class="line">4. 消息队列：消息队列是有消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</span><br><span class="line">5. 信号 ( sinal ) ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</span><br><span class="line">6. 共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</span><br><span class="line">7. 套接字( socket ) ：套接字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。</span><br></pre></td></tr></table></figure></p>
<p>Q.tcp建立连接和断开连接的各种过程中的状态转换细节?<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">客户端：主动打开SYN_SENT---&gt;ESTABLISHED---&gt;主动关闭FIN_WAIT_1---&gt;FIN_WAIT_2---&gt;TIME_WAIT</span><br><span class="line">服务器端：LISTEN（被动打开）---&gt;SYN_RCVD---&gt;ESTABLISHED---&gt;CLOSE_WAIT(被动关闭)---&gt;LAST_ACK---&gt;CLOSED</span><br></pre></td></tr></table></figure></p>
<p>Q.epoll与Select的区别？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">I/O多路复用，先构造一张有关描述符的列表（epoll中为队列），然后调用一个函数，直到这些描述符中的一个准备好时才返回，返回时告诉进程哪些I/O就绪。select和epoll这两个机制都是多路I/O机制的解决方案，select为POSIX标准中的，而epoll为Linux所特有的。</span><br><span class="line">区别（epoll相对select的有点）三点：</span><br><span class="line">1. select的句柄数目受限，在linux/posix_types.h头文件有这样的声明：#define __FD_SETSIZE    1024  表示select最多同时监听1024个fd。而epoll没有，它的限制是最大的打开文件句柄数目。</span><br><span class="line">2. epoll的最大好处是不会随着FD的数目增长而降低效率，在selec中采用轮询处理，其中的数据结构类似一个数组的数据结构，而epoll是维护一个队列，直接看队列是不是空就可以了。epoll只会对&quot;活跃&quot;的socket进行操作---这是因为在内核实现中epoll是根据每个fd上面的callback函数实现的。那么，只有&quot;活跃&quot;的socket才会主动的去调用 callback函数（把这个句柄加入队列），其他idle状态句柄则不会，在这点上，epoll实现了一个&quot;伪&quot;AIO。但是如果绝大部分的I/O都是“活跃的”，每个I/O端口使用率很高的话，epoll效率不一定比select高（可能是要维护队列复杂）。</span><br><span class="line">3. 使用mmap加速内核与用户空间的消息传递。无论是select,poll还是epoll都需要内核把FD消息通知给用户空间，如何避免不必要的内存拷贝就很重要，在这点上，epoll是通过内核于用户空间mmap同一块内存实现的。</span><br></pre></td></tr></table></figure></p>
<p>Q.CPU密集型和IO密集型？<br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">我们可以把任务分为计算密集型和IO密集型。</span><br><span class="line"></span><br><span class="line">计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。</span><br><span class="line"></span><br><span class="line">计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。</span><br><span class="line"></span><br><span class="line">第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。</span><br><span class="line"></span><br><span class="line">IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。</span><br><span class="line"></span><br><span class="line">总之，计算密集型程序适合C语言多线程，I/O密集型适合脚本语言开发的多线程。</span><br></pre></td></tr></table></figure></p>
<p>Q.一个页面从输入URL到页面加载显示完成，这个过程都发生了什么？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、首先，在浏览器地址栏中输入url</span><br><span class="line">2、浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。</span><br><span class="line">3、在发送http请求前，需要域名解析(DNS解析)，解析获取相应的IP地址。</span><br><span class="line">4、浏览器向服务器发起tcp连接，与浏览器建立tcp三次握手。</span><br><span class="line">5、握手成功后，浏览器向服务器发送http请求，请求数据包。</span><br><span class="line">6、服务器处理收到的请求，将数据返回至浏览器</span><br><span class="line">7、浏览器收到HTTP响应</span><br><span class="line">8、读取页面内容，浏览器渲染，解析html源码</span><br><span class="line">9、生成Dom树、解析css样式、js交互</span><br><span class="line">10、客户端和服务器交互</span><br><span class="line">11、ajax查询</span><br></pre></td></tr></table></figure></p>
<h1 id="10-编程语言相关"><a href="#10-编程语言相关" class="headerlink" title="10. 编程语言相关"></a>10. 编程语言相关</h1><h2 id="10-1-Java"><a href="#10-1-Java" class="headerlink" title="10.1 Java"></a>10.1 Java</h2><h3 id="基本知识点"><a href="#基本知识点" class="headerlink" title="基本知识点"></a>基本知识点</h3><p>Q. java基本数据类型?<br><br>A:<br><br>java中一共分为8种基本数据类型：byte、short、int、long、float、double、char、boolean,其中byte、short、int、long是整型。float、double是浮点型,char是字符型,boolean是布尔型。</p>
<p>Q.引用类型<br><br>A:<br><br>java为每种基本类型都提供了对应的封装类型，分别为：Byte、Short、Integer、Long、Float、Double、Character、Boolean。引用类型是一种对象类型,它的值是指向内存空间的引用，就是地址。</p>
<p>Q.String,StringBuilder和StringBuffer的区别？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java平台提供了两种类型的字符串：String和StringBuffer/StringBuilder，它们可以储存和操作字符串。其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。而StringBuffer/StringBuilder类表示的字符串对象可以直接进行修改。StringBuilder是Java 5中引入的，它和StringBuffer的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer要高。</span><br></pre></td></tr></table></figure></p>
<p>Q.JAVA中静态块，静态变量加载顺序？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一般顺序：静态块（静态变量）——&gt;成员变量——&gt;构造方法——&gt;静态方法</span><br></pre></td></tr></table></figure></p>
<p>Q.什么是面向对象编程？ <br><br>A:</p>
<blockquote>
<p>把一切看成对象，三大特性 继承，封装，多态</p>
</blockquote>
<p>Q.面向对象的特征？ <br><br>A:</p>
<blockquote>
<p>抽象，继承，封装，多态</p>
</blockquote>
<p>Q.final,finally,finalize的区别？<br><br>A：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final:是一个关键字，被final修饰的变量为不可变的变量，被final修饰的类，就意味着不能再派生出新的子类，不能作为父类而被子类继承。因此一个类不能既被abstract声明，又被final声明。</span><br><span class="line">finally:是在异常处理时提供finally块来执行任何清除操作。不管有没有异常被抛出、捕获，finally块都会被执行</span><br><span class="line">finalize:是一个方法名，java技术允许使用finalize（）方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用,在object类中定义。</span><br></pre></td></tr></table></figure></p>
<p>Q.int 和 Integer 有什么区别<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. Integer是int的包装类；int是基本数据类型；</span><br><span class="line">2. Integer变量必须实例化后才能使用；int变量不需要</span><br><span class="line">3. Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值</span><br><span class="line">4. Integer的默认值是null；int的默认值是0。</span><br></pre></td></tr></table></figure></p>
<p>Q.深拷贝与浅拷贝？<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。</span><br><span class="line">- 深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。</span><br></pre></td></tr></table></figure></p>
<p>Q.重载和重写的区别<br><br>A：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">重载：</span><br><span class="line">1) 方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。重载是一个类中多态性的一种表现。</span><br><span class="line">2) Java的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。调用方法时通过传递给它们的不同参数个数和参数类型给它们的不同参数个数和参数类型给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是多态性。</span><br><span class="line">3) 重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准。</span><br><span class="line"></span><br><span class="line">重写：</span><br><span class="line">1) 父类与子类之间的多态性，对父类的函数进行重新定义。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写(Overriding)。在Java中，子类可继承父类中的方法，而不需要重新编写相同的方法。但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。方法重写又称方法覆盖。</span><br><span class="line">2) 若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法将覆盖原有的方法。如需父类中原有的方法，可使用super关键字，该关键字引用了当前类的父类。</span><br><span class="line">3) 子类函数的访问修饰权限不能少于父类的；</span><br></pre></td></tr></table></figure></p>
<p>Q.抽象类和接口有什么区别<br><br>A：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Java中接口和抽象类的定义语法分别为interface与abstract关键字。</span><br><span class="line"></span><br><span class="line">抽象类：在Java中被abstract关键字修饰的类称为抽象类，被abstract关键字修饰的方法称为抽象方法，抽象方法只有方法的声明，没有方法体。抽象类的特点：</span><br><span class="line"></span><br><span class="line">a、抽象类不能被实例化只能被继承；</span><br><span class="line"></span><br><span class="line">b、包含抽象方法的一定是抽象类，但是抽象类不一定含有抽象方法；</span><br><span class="line"></span><br><span class="line">c、抽象类中的抽象方法的修饰符只能为public或者protected，默认为public；</span><br><span class="line"></span><br><span class="line">d、一个子类继承一个抽象类，则子类必须实现父类抽象方法，否则子类也必须定义为抽象类；</span><br><span class="line"></span><br><span class="line">e、抽象类可以包含属性、方法、构造方法，但是构造方法不能用于实例化，主要用途是被子类调用。</span><br><span class="line"></span><br><span class="line">接口：Java中接口使用interface关键字修饰，特点为:</span><br><span class="line"></span><br><span class="line">a、接口可以包含变量、方法；变量被隐士指定为public static final，方法被隐士指定为public abstract（JDK1.8之前）；</span><br><span class="line"></span><br><span class="line">b、接口支持多继承，即一个接口可以extends多个接口，间接的解决了Java中类的单继承问题；</span><br><span class="line"></span><br><span class="line">c、一个类可以实现多个接口；</span><br><span class="line"></span><br><span class="line">d、JDK1.8中对接口增加了新的特性：（1）、默认方法（default method）：JDK 1.8允许给接口添加非抽象的方法实现，但必须使用default关键字修饰；定义了default的方法可以不被实现子类所实现，但只能被实现子类的对象调用；如果子类实现了多个接口，并且这些接口包含一样的默认方法，则子类必须重写默认方法；（2）、静态方法（static method）：JDK 1.8中允许使用static关键字修饰一个方法，并提供实现，称为接口静态方法。接口静态方法只能通过接口调用（接口名.静态方法名）。</span><br></pre></td></tr></table></figure></p>
<p>Q.说说反射的用途及实现<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">通过反射，我们可以在运行时获得程序或程序集中每一个类型成员和成员变量的信息。</span><br><span class="line">程序中一般的对象类型都是在编译期就确定下来的，而Java 反射机制可以动态的创建对象并调用其属性，这样对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象即使这个对象在编译期是未知的，</span><br><span class="line">反射的核心：是 JVM 在运行时 才动态加载的类或调用方法或属性，他不需要事先（写代码的时候或编译期）知道运行对象是谁。</span><br><span class="line">用途：Spring动态加载需要的对象</span><br></pre></td></tr></table></figure></p>
<p>Q.说说自定义注解的场景及实现<br><br>A：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">登陆、权限拦截、日志处理，以及各种Java框架，如Spring，Hibernate，JUnit 提到注解就不能不说反射，Java自定义注解是通过运行时靠反射获取注解。实际开发中，例如我们要获取某个方法的调用日志，可以通过AOP（动态代理机制）给方法添加切面，通过反射来获取方法包含的注解，如果包含日志注解，就进行日志记录。</span><br></pre></td></tr></table></figure></p>
<p>Q.HTTP 请求的 GET 与 POST 方式的区别<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET方法会把名值对追加在请求的URL后面。因为URL对字符数目有限制，进而限制了用在客户端请求的参数值的数目。并且请求中的参数值是可见的，因此，敏感信息不能用这种方式传递。</span><br><span class="line">POST方法通过把请求参数值放在请求体中来克服GET方法的限制，因此，可以发送的参数的数目是没有限制的。最后，通过POST请求传递的敏感信息对外部客户端是不可见的。</span><br></pre></td></tr></table></figure></p>
<p>Q.session 与 cookie 区别<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cookie 是 Web 服务器发送给浏览器的一块信息。浏览器会在本地文件中给每一个 Web 服务器存储 cookie。以后浏览器在给特定的 Web 服务器发请求的时候，同时会发送所有为该服务器存储的 cookie。</span><br><span class="line">下面列出了 session 和 cookie 的区别:</span><br><span class="line">无论客户端浏览器做怎么样的设置，session都应该能正常工作。客户端可以选择禁用 cookie，但是,session 仍然是能够工作的，因为客户端无法禁用服务端的 session。</span><br></pre></td></tr></table></figure></p>
<p>Q.session 分布式处理<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. sessio粘性。就是说，用户在访问了某台服务器后，之后的操作就让其只走该服务器就好。那么久可以让用户只访问该台机器了。</span><br><span class="line">eg:nginx配置</span><br><span class="line">    upstream test&#123;</span><br><span class="line">        #这里添加的是上面启动好的两台服务器ip_hash;#粘性Session</span><br><span class="line">            server 192.168.22.229:8080 weight=1;</span><br><span class="line">            server 192.168.22.230:8080 weight=1;</span><br><span class="line">    &#125;</span><br><span class="line">2. 使用广播的方式，当一台服务器中的session中（增删改）了之后，将这个session中的所有数据，通过广播一样的方式，同步到其他的服务器中去。</span><br><span class="line">3. 使用中间件共享session，使用redis集群的形式</span><br></pre></td></tr></table></figure></p>
<p>Q.JDBC 流程<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 加载驱动Class.forname(“oracle”)</span><br><span class="line">- 调用DriverManager.getConnection方法， 通过JDBC URL，用户名，密码取得数据库连接的Connection对象。</span><br><span class="line">- 获取Connection后， 便可以通过createStatement创建Statement用以执行SQL语句。</span><br><span class="line">- 有时候会得到查询结果，比如select，得到查询结果，查询（SELECT）的结果存放于结果集（ResultSet）中。</span><br><span class="line">- 关闭数据库语句，关闭数据库连接。</span><br></pre></td></tr></table></figure></p>
<p>Q.MVC 设计思想<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MVC是三个单词的首字母缩写，它们是Model（模型）、View（视图）和Controller（控制）。这个模式认为，程序不论简单或复杂，从结构上看，都可以分成三层。</span><br><span class="line"></span><br><span class="line">- 最上面的一层，是直接面向最终用户的”视图层”（View）。它是提供给用户的操作界面，是程序的外壳。</span><br><span class="line">- 最底下的一层，是核心的”数据层”（Model），也就是程序需要操作的数据或信息。</span><br><span class="line">- 中间的一层，就是”控制层”（Controller），它负责根据用户从”视图层”输入的指令，选取”数据层”中的数据，然后对其进行相应的操作，产生最终结果。</span><br></pre></td></tr></table></figure></p>
<p>Q.equals 与 == 的区别<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">==与equals的主要区别是：</span><br><span class="line">== 常用于比较原生类型，而equals()方法用于检查对象的相等性。另一个不同的点是：如果==和equals()用于比较对象，当两个引用地址相同，==返回true。而equals()可以返回true或者false主要取决于重写实现。最常见的一个例子，字符串的比较，不同情况==和equals()返回不同的结果。</span><br></pre></td></tr></table></figure></p>
<p>Q.解释程序开发中同步和异步的概念？<br><br>A:<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">同步：发送发发出数据后，等待接收方发回响应才发下一个数据包的通讯方式</span><br><span class="line">异步：发送方发出数据后，不等待接收方发回响应，接着发送下一个数据包</span><br></pre></td></tr></table></figure>
<p>Q.内存泄露的原因？<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，首先，这些对象是可达的，即在有向图中，存在通路可以与其相连；其次，这些对象是无用的，即程序以后不会再使用这些对象。如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。</span><br><span class="line">长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。</span><br><span class="line">1. 静态集合类引起内存泄露</span><br><span class="line">2. 当集合里面的对象属性被修改后，再调用remove（）方法时不起作用</span><br><span class="line">3. 监听器</span><br><span class="line">4. 各种连接，显示的关闭资源池</span><br></pre></td></tr></table></figure></p>
<p>Q.类的序列化与反序列化<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对象序列化机制（object serialization）是Java语言内建的一种对象持久化方式，通过对象序列化，可以把对象的状态保存为字节数组，并且可以在有需要的时候将这个字节数组通过反序列化的方式再转换成对象。对象序列化可以很容易的在JVM中的活动对象和字节数组（流）之间进行转换。</span><br><span class="line">在Java中，对象的序列化与反序列化被广泛应用到RMI(远程方法调用)及网络传输中。</span><br><span class="line">类通过实现 java.io.Serializable 接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。</span><br></pre></td></tr></table></figure></p>
<p>Q.数据库是如何和model用ORM连接的？<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ORM的全称是Object Relational Mapping，即对象关系映射。它的实现思想就是将关系数据库中表的数据映射成为对象，以对象的形式展现，这样开发人员就可以把对数据库的操作转化为对这些对象的操作。因此它的目的是为了方便开发人员以面向对象的思想来实现对数据库的操作。</span><br><span class="line">实现ORM主要有以下三个文件：</span><br><span class="line"></span><br><span class="line">1. 映射类：映射数据库表的结构，表中的字段在类中被描述成属性，将来就可以实现把表中的记录映射成为该类的对象</span><br><span class="line">2. 映射文件：它的作用是指定数据库表和映射类之间的关系，包括映射类和数据库表的对应关系、表字段和类属性类型的对应关系以及表字段和类属性名称的对应关系等</span><br><span class="line">3. 数据库配置文件：它的作用是指定与数据库连接时需要的连接信息，比如连接哪中数据库、登录用户名、登录密码以及连接字符串等。</span><br><span class="line"></span><br><span class="line">在这三种主要的文件中，映射类为普通Java源文件、映射文件为XML格式、数据库配置文件为Properties格式或者是XML格式。想理解“映射”首先我们需要知道如何解析这三种文件，即解析XML格式文件、解析Properties格式文件和解析Java类文件。</span><br></pre></td></tr></table></figure></p>
<p>Q.Mybatis中#{}和${}有什么区别？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. #&#123;&#125; 和 $&#123;&#125; 在预编译中的处理是不一样的。#&#123;&#125; 在预处理时，会把参数部分用一个占位符 ? 代替</span><br><span class="line">2. 而 $&#123;&#125; 则只是简单的字符串替换</span><br><span class="line">3. 优先使用 #&#123;&#125;。因为 $&#123;&#125; 会导致 sql 注入的问题</span><br></pre></td></tr></table></figure></p>
<p>Q.什么是SQL注入？如何避免？写出你了解的其他安全问题？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SQL注入攻击指的是通过构建特殊的输入作为参数传入Web应用程序，而这些输入大都是SQL语法里的一些组合，通过执行SQL语句进而执行攻击者所要的操作，其主要原因是程序没有细致地过滤用户输入的数据，致使非法数据侵入系统。</span><br><span class="line">根据相关技术原理，SQL注入可以分为平台层注入和代码层注入。前者由不安全的数据库配置或数据库平台的漏洞所致；后者主要是由于程序员对输入未进行细致地过滤，从而执行了非法的数据查询。</span><br><span class="line">基于此，SQL注入的产生原因通常表现在以下几方面：</span><br><span class="line">    ①不当的类型处理；</span><br><span class="line">    ②不安全的数据库配置；</span><br><span class="line">    ③不合理的查询集处理；</span><br><span class="line">    ④不当的错误处理；</span><br><span class="line">    ⑤转义字符处理不合适；</span><br><span class="line">    ⑥多个提交处理不当。</span><br><span class="line">防护：</span><br><span class="line">1.永远不要信任用户的输入。对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和</span><br><span class="line">双&quot;-&quot;进行转换等。</span><br><span class="line">2.永远不要使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取。</span><br><span class="line">3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。</span><br><span class="line">4.不要把机密信息直接存放，加密或者hash掉密码和敏感的信息。</span><br><span class="line">5.应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装</span><br></pre></td></tr></table></figure></p>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>Q. 常见的设计模式？<br><br>A:</p>
<p>Q. 适配器模式？<br><br>A:<br><br>适配器模式：将一个类的接口转换成客户希望的另一个接口。适配器模式让那些接口不兼容的类可以一起工作<br>适配器模式的别名为包装器(Wrapper)模式，它既可以作为类结构型模式，也可以作为对象结构型模式。在适配器模式定义中所提及的接口是指广义的接口，它可以表示一个方法或者方法的集合。</p>
<p>Q.</p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>Q.List 和 Set 区别?<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. List,Set都是继承自Collection接口 </span><br><span class="line">2. List特点：元素有放入顺序，元素可重复 ，Set特点：元素无放入顺序，元素不可重复（注意：元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的）</span><br><span class="line">3. List接口有三个实现类：LinkedList，ArrayList，Vector ，Set接口有两个实现类：HashSet(底层由HashMap实现)，LinkedHashSet</span><br></pre></td></tr></table></figure></p>
<p>Q.List 和 Map 区别<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. List特点：元素有放入顺序，元素可重复;</span><br><span class="line">2. Map特点：元素按键值对存储，无放入顺序;</span><br><span class="line">3. List接口有三个实现类：LinkedList，ArrayList，Vector;</span><br><span class="line">4. LinkedList：底层基于链表实现，链表内存是散乱的，每一个元素存储本身内存地址的同时还存储下一个元素的地址。链表增删快，查找慢; </span><br><span class="line">5. Map接口有三个实现类：HashMap，HashTable，LinkeHashMap</span><br><span class="line">6. Map相当于和Collection一个级别的；Map该集合存储键值对，且要求保持键的唯一性；</span><br></pre></td></tr></table></figure></p>
<p>Q.Arraylist 与 LinkedList 区别<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1) 因为Array是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的。Array获取数据的时间复杂度是O(1),但是要删除数据却是开销很大的，因为这需要重排数组中的所有数据。</span><br><span class="line">2) 相对于ArrayList，LinkedList插入是更快的。因为LinkedList不像ArrayList一样，不需要改变数组的大小，也不需要在数组装满的时候要将所有的数据重新装入一个新的数组，这是ArrayList最坏的一种情况，时间复杂度是O(n)，而LinkedList中插入或删除的时间复杂度仅为O(1)。ArrayList在插入数据时还需要更新索引（除了插入数组的尾部）。 </span><br><span class="line">3) 类似于插入数据，删除数据时，LinkedList也优于ArrayList。 </span><br><span class="line">4) LinkedList需要更多的内存，因为ArrayList的每个索引的位置是实际的数据，而LinkedList中的每个节点中存储的是实际的数据和前后节点的位置。</span><br><span class="line">5) 你的应用不会随机访问数据。因为如果你需要LinkedList中的第n个元素的时候，你需要从第一个元素顺序数到第n个数据，然后读取数据。 </span><br><span class="line">6) 你的应用更多的插入和删除元素，更少的读取数据。因为插入和删除元素不涉及重排数据，所以它要比ArrayList要快。</span><br></pre></td></tr></table></figure></p>
<p>Q.ArrayList 与 Vector 区别<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1）同步性:Vector是线程安全的，也就是说是同步的 ，而ArrayList 是线程序不安全的，不是同步的 数2。</span><br><span class="line">2）数据增长:当需要增长时,Vector默认增长为原来一倍 ，而ArrayList却是原来的50% ，这样,ArrayList就有利于节约内存空间。</span><br></pre></td></tr></table></figure></p>
<p>Q.HashMap 和 Hashtable 的区别<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)。</span><br><span class="line">2. HashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。</span><br></pre></td></tr></table></figure></p>
<p>Q.HashSet 和 HashMap 区别<br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.HashMap实现了Map接口，HashSet实现了Set接口</span><br><span class="line">2.HashMap储存键值对，HashSet仅仅存储对象</span><br><span class="line">3.使用put()方法将元素放入map中，使用add()方法将元素放入set中</span><br><span class="line">4.HashMap中使用键对象来计算hashcode值 | HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false |</span><br><span class="line">5.HashMap比较快，因为是使用唯一的键来获取对象 | HashSet较HashMap来说比较慢 |</span><br></pre></td></tr></table></figure></p>
<p>Q.HashMap 和 ConcurrentHashMap 的区别<br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(1)放入HashMap的元素是key-value对</span><br><span class="line">(2)底层说白了就是以前数据结构课程讲过的散列结构</span><br><span class="line">(3)要将元素放入到hashmap中，那么key的类型必须要实现hashcode方法，默认这个方法是根据对象的地址来计算的，具体我也记不太清楚了，接着还必须覆盖对象的equal方法</span><br><span class="line">（4）ConcurrentHashMap对整个桶数组进行了分段，而HashMap则没有 </span><br><span class="line">（5）ConcurrentHashMap在每一个分段上都用锁进行保护，从而让锁的粒度更精细一些，并发性能更好，而HashMap没有锁机制，不是线程安全的</span><br></pre></td></tr></table></figure></p>
<p>Q.HashMap 的工作原理及代码实现<br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HashMap的初始值还要考虑加载因子:</span><br><span class="line">1. 哈希冲突：若干Key的哈希值按数组大小取模后，如果落在同一个数组下标上，将组成一条Entry链，对Key的查找需要遍历Entry链上的每个元素执行equals()比较。</span><br><span class="line">2. 加载因子：为了降低哈希冲突的概率，默认当HashMap中的键值对达到数组大小的75%时，即会触发扩容。因此，如果预估容量是100，即需要设定100/0.75＝134的数组大小。</span><br><span class="line">3. 空间换时间：如果希望加快Key查找的时间，还可以进一步降低加载因子，加大初始大小，以降低哈希冲突的概率。</span><br><span class="line"></span><br><span class="line">HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。</span><br></pre></td></tr></table></figure></p>
<p>Q.HashMap扩容的条件？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 当前数据存储的数量（即size()）大小必须大于等于阈值；</span><br><span class="line">2. 当前加入的数据是否发生了hash冲突。</span><br></pre></td></tr></table></figure></p>
<p>Q.ConcurrentHashMap 的工作原理及代码实现<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap采用了非常精妙的&quot;分段锁&quot;策略，ConcurrentHashMap的主干是个Segment数组。Segment继承了ReentrantLock，所以它就是一种可重入锁（ReentrantLock)。在ConcurrentHashMap，一个Segment就是一个子哈希表，Segment里维护了一个HashEntry数组，并发环境下，对于不同Segment的数据进行操作是不用考虑锁竞争的。</span><br></pre></td></tr></table></figure></p>
<p>Q.并发操作HashMap会导致什么问题？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">并发环境下的rehash过程可能会带来循环链表，导致死循环致使线程挂掉</span><br></pre></td></tr></table></figure></p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>Q.讲下Java多线程的使用<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">多线程一般用来更好的利用CPU资源，解决诸如程序“在一部分上会阻塞”，“在另一部分上需要持续运行”的场合。多线程一般用来更好的利用CPU资源，解决诸如程序“在一部分上会阻塞”，“在另一部分上需要持续运行”的场合。</span><br></pre></td></tr></table></figure></p>
<p>Q.创建线程的方式及实现? <br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1. 继承Thread类创建线程类</span><br><span class="line">- 定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。</span><br><span class="line">- 创建Thread子类的实例，即创建了线程对象。</span><br><span class="line">- 调用线程对象的start()方法来启动该线程.</span><br><span class="line">2. 通过Runnable接口创建线程类</span><br><span class="line">- 定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</span><br><span class="line">- 创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。</span><br><span class="line">- 调用线程对象的start()方法来启动该线程。</span><br><span class="line">3. 通过Callable和Future创建线程</span><br><span class="line">- 创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。</span><br><span class="line">- 创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。 </span><br><span class="line">- 使用FutureTask对象作为Thread对象的target创建并启动新线程。</span><br><span class="line">- 调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</span><br><span class="line">在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</span><br></pre></td></tr></table></figure></p>
<p>Q.sleep()，wait()，join（），yield（）有什么区别<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. sleep()方法需要指定等待的时间，它可以让当前正在执行的线程在指定的时间内暂停执行，进入阻塞状态，该方法既可以让其他同优先级或者高优先级的线程得到执行的机会，也可以让低优先级的线程得到执行机会。但是sleep()方法不会释放“锁标志”，也就是说如果有synchronized同步块，其他线程仍然不能访问共享数据。</span><br><span class="line">2. wait()方法与sleep()方法的不同之处在于，wait()方法会释放对象的“锁标志”。当调用某一对象的wait()方法后，会使当前线程暂停执行，并将当前线程放入对象等待池中，直到调用了notify()方法后，将从对象等待池中移出任意一个线程并放入锁标志等待池中，只有锁标志等待池中的线程可以获取锁标志，它们随时准备争夺锁的拥有权。当调用了某个对象的notifyAll()方法，会将对象等待池中的所有线程都移动到该对象的锁标志等待池。除了使用notify()和notifyAll()方法，还可以使用带毫秒参数的wait(long timeout)方法，效果是在延迟timeout毫秒后，被暂停的线程将被恢复到锁标志等待池。 此外，wait()，notify()及notifyAll()只能在synchronized语句中使用，但是如果使用的是ReenTrantLock实现同步，该如何达到这三个方法的效果呢？解决方法是使用ReenTrantLock.newCondition()获取一个Condition类对象，然后Condition的await()，signal()以及signalAll()分别对应上面的三个方法。</span><br><span class="line">3. yield()方法和sleep()方法类似，也不会释放“锁标志”，区别在于，它没有参数，即yield()方法只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行，另外yield()方法只能使同优先级或者高优先级的线程得到执行机会，这也和sleep()方法不同。</span><br><span class="line">4. join()方法会使当前线程等待调用join()方法的线程结束后才能继续执行</span><br></pre></td></tr></table></figure></p>
<p>Q.说说 CountDownLatch 原理<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CountDownLatch 内部维护了一个整数n，n（要大于等于0）在==当前线程== 初始化CountDownLatch方法指定。当前线程调用 CountDownLatch的await()方法阻塞当前线程，等待其他调用CountDownLatch对象的CountDown()方法的线程执行完毕。 其他线程调用该CountDownLatch的CountDown()方法，该方法会把n-1，直到所有线程执行完成，n等于0，==当前线程==就恢复执行。</span><br></pre></td></tr></table></figure></p>
<p>Q.说说 CyclicBarrier 原理<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CyclicBarrier简介CyclicBarrier是一个同步辅助类,允许一组线程互相等待,直到到达某个公共屏障点(commonbarrierpoint)。因为该barrier在释放等待线程后可以重用,所以称它为循环的barrier。</span><br></pre></td></tr></table></figure></p>
<p>Q.说说 Semaphore 原理<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Semaphore直译为信号。实际上Semaphore可以看做是一个信号的集合。不同的线程能够从Semaphore中获取若干个信号量。当Semaphore对象持有的信号量不足时，尝试从Semaphore中获取信号的线程将会阻塞。直到其他线程将信号量释放以后，阻塞的线程会被唤醒，重新尝试获取信号量。</span><br></pre></td></tr></table></figure></p>
<p>Q.说说 Exchanger 原理<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当一个线程到达exchange调用点时，如果它的伙伴线程此前已经调用了此方法，那么它的伙伴会被调度唤醒并与之进行对象交换，然后各自返回。如果它的伙伴还没到达交换点，那么当前线程将会被挂起，直至伙伴线程到达——完成交换正常返回；或者当前线程被中断——抛出中断异常；又或者是等候超时——抛出超时异常。</span><br></pre></td></tr></table></figure></p>
<p>Q.说说 CountDownLatch 与 CyclicBarrier 区别<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(01) CountDownLatch的作用是允许1或N个线程等待其他线程完成执行;而CyclicBarrier则是允许N个线程相互等待。</span><br><span class="line">(02) CountDownLatch的计数器无法被重置;CyclicBarrier的计数器可以被重置后使用,因此它被称为是循环的barrier。</span><br></pre></td></tr></table></figure></p>
<p>Q.ThreadLocal 原理分析<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal提供了线程本地变量，它可以保证访问到的变量属于当前线程，每个线程都保存有一个变量副本，每个线程的变量都不同。ThreadLocal相当于提供了一种线程隔离，将变量与线程相绑定。</span><br></pre></td></tr></table></figure></p>
<p>Q.讲讲线程池的实现原理<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当提交一个新任务到线程池时，线程池的处理流程如下。</span><br><span class="line">1. 线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作 线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。</span><br><span class="line">2. 线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。</span><br><span class="line">3. 线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。</span><br></pre></td></tr></table></figure></p>
<p>Q.线程池的几种方式与使用场景<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在Executors类里面提供了一些静态工厂，生成一些常用的线程池</span><br><span class="line">1. newFixedThreadPool：创建固定大小的线程池。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。 </span><br><span class="line">2. newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</span><br><span class="line">3. newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</span><br><span class="line">4. newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</span><br><span class="line">5. newSingleThreadScheduledExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。</span><br></pre></td></tr></table></figure></p>
<p>Q.线程的生命周期<br><br>A:<br><br><img src="https://images2017.cnblogs.com/blog/1252584/201712/1252584-20171216161451499-1101244651.png" alt="image"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)5种状态</span><br><span class="line">- 新建（new Thread）</span><br><span class="line">当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动)</span><br><span class="line">例如：Thread t1=new Thread();</span><br><span class="line"></span><br><span class="line">- 就绪（runnable）</span><br><span class="line">线程已经被启动，正在等待被分配给CPU时间片，也就是说此时线程正在就绪队列中排队等候得到CPU资源。例如：t1.start();</span><br><span class="line"></span><br><span class="line">- 运行（running）</span><br><span class="line">线程获得CPU资源正在执行任务（run()方法），此时除非此线程自动放弃CPU资源或者有优先级更高的线程进入，线程将一直运行到结束。</span><br><span class="line"></span><br><span class="line">- 死亡（dead）</span><br><span class="line">当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。</span><br><span class="line"></span><br><span class="line">自然终止：正常运行run()方法后终止</span><br><span class="line">异常终止：调用stop()方法让一个线程终止运行</span><br><span class="line"></span><br><span class="line">- 堵塞（blocked）</span><br><span class="line">由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，即进入堵塞状态。</span><br><span class="line">正在睡眠：用sleep(long t) 方法可使线程进入睡眠方式。一个睡眠着的线程在指定的时间过去可进入就绪状态。</span><br><span class="line">正在等待：调用wait()方法。（调用motify()方法回到就绪状态）</span><br><span class="line">被另一个线程所阻塞：调用suspend()方法。（调用resume()方法恢复）</span><br></pre></td></tr></table></figure></p>
<p>Q.有三个线程T1，T2，T3，怎么确保它们按顺序执行？<br><br>A:<br><br>在主线程中，每一个线程start（）后立即join（）</p>
<p>Q.Thread 类中的start() 和 run() 方法有什么区别？<br><br>A:<br><br>1.start（）方法来启动线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码；通过调用Thread类的start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行操作的， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程</p>
<p>2.run（）方法当作普通方法的方式调用。程序还是要顺序执行，要等待run方法体执行完毕后，才可继续执行下面的代码； 程序中只有主线程——这一个线程， 其程序执行路径还是只有一条， 这样就没有达到写线程的目的。</p>
<p>Q.请写一个线程安全的单例模型，还有其他写法吗？<br><br>A:</p>
<ul>
<li>内部类实现:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonInner &#123;</span><br><span class="line">    private SingletonInner()&#123;&#125;</span><br><span class="line">    /* 此处使用一个内部类来维护单例 */</span><br><span class="line">    private static class SingletonFactory&#123;</span><br><span class="line">        private static SingletonInner singletonInner = new SingletonInner();</span><br><span class="line">    &#125;</span><br><span class="line">    /* 获取实例 */</span><br><span class="line">    public static SingletonInner getinstance()&#123;</span><br><span class="line">        return SingletonFactory.singletonInner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Q.如果CPU占用率较高，如何分析出是哪个线程？top命令进行查看，如何分析出是java的那个线程呢？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. top 命令查到PID</span><br><span class="line">2. ps p 9534 -L -o pcpu,pmem,pid,tid,time,tname,cmd 查到tid</span><br><span class="line">3. 查看内存使用的堆栈：在这里我们挑选了TID=25830的线程进行分析，首先需要将25830这个id转换为16进制。需输入如下命令，执行命令 printf &quot;%x\n&quot; 25830</span><br><span class="line">4. 将PID为9534的堆栈信息打印到jstack.log中，命令：jstack -l 9534 &gt; /home/zheren/jstack.log</span><br></pre></td></tr></table></figure></p>
<h3 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h3><p>Q.谈谈锁机制 <br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">最简单的方式，使用Synchronization关键字:Java Synchronization介绍</span><br><span class="line">使用java.util.concurrent.atomic 包中的原子类，例如 AtomicInteger</span><br><span class="line">使用java.util.concurrent.locks 包中的锁</span><br><span class="line">使用线程安全的集合ConcurrentHashMap</span><br><span class="line">使用volatile关键字，保证变量可见性（直接从内存读，而不是从线程cache读）</span><br></pre></td></tr></table></figure></p>
<p>Q.volatile 实现原理 <br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁更加方便。如果一个字段被声明成volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。</span><br></pre></td></tr></table></figure></p>
<p>Q.synchronize 实现原理 <br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同步代码块是使用monitorenter和monitorexit指令实现的，同步方法（在这看不出来需要看JVM底层实现）依靠的是方法修饰符上的ACC_SYNCHRONIZED实现。</span><br></pre></td></tr></table></figure></p>
<p>Q.synchronized 与 lock 的区别 <br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">一、synchronized和lock的用法区别</span><br><span class="line">（1）synchronized(隐式锁)：在需要同步的对象中加入此控制，synchronized可以加在方法上，也可以加在特定代码块中，括号中表示需要锁的对象。</span><br><span class="line">（2）lock（显示锁）：需要显示指定起始位置和终止位置。一般使用ReentrantLock类做为锁，多个线程中必须要使用一个ReentrantLock类做为对 象才能保证锁的生效。且在加锁和解锁处需要通过lock()和unlock()显示指出。所以一般会在finally块中写unlock()以防死锁。</span><br><span class="line"></span><br><span class="line">二、synchronized和lock性能区别</span><br><span class="line">synchronized是托管给JVM执行的，而lock是java写的控制锁的代码。在Java1.5中，synchronize是性能低效的。因为 这是一个重量级操作，需要调用操作接口，导致有可能加锁消耗的系统时间比加锁以外的操作还多。相比之下使用Java提供的Lock对象，性能更高一些。但 是到了Java1.6，发生了变化。synchronize在语义上很清晰，可以进行很多优化，有适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。导致 在Java1.6上synchronize的性能并不比Lock差。</span><br><span class="line"></span><br><span class="line">三、synchronized和lock机制区别</span><br><span class="line">（1）synchronized原始采用的是CPU悲观锁机制，即线程获得的是独占锁。独占锁意味着其 他线程只能依靠阻塞来等待线程释放锁。</span><br><span class="line">（2）Lock用的是乐观锁方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁实现的机制就 是CAS操作（Compare and Swap）。</span><br></pre></td></tr></table></figure></p>
<p>Q.Lock同步总结？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Lock类也可以实现线程同步，而Lock获得锁需要执行lock方法，释放锁需要执行unLock方法</span><br><span class="line">Lock类可以创建Condition对象，Condition对象用来是线程等待和唤醒线程，需要注意的是Condition对象的唤醒的是用同一个Condition执行await方法的线程，所以也就可以实现唤醒指定类的线程</span><br><span class="line">Lock类分公平锁和不公平锁，公平锁是按照加锁顺序来的，非公平锁是不按顺序的，也就是说先执行lock方法的锁不一定先获得锁</span><br><span class="line">Lock类有读锁和写锁，读读共享，写写互斥，读写互斥</span><br></pre></td></tr></table></figure></p>
<p>Q.CAS 乐观锁 <br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</span><br><span class="line"></span><br><span class="line">CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前值。）CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”这其实和乐观锁的冲突检查+数据更新的原理是一样的。</span><br></pre></td></tr></table></figure></p>
<p>Q.ABA 问题 <br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CAS会导致“ABA问题”。</span><br><span class="line">CAS算法实现一个重要前提需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化。</span><br><span class="line">比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。</span><br><span class="line">部分乐观锁的实现是通过版本号（version）的方式来解决ABA问题，乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现ABA问题，因为版本号只会增加不会减少。</span><br></pre></td></tr></table></figure></p>
<p>Q.乐观锁的业务场景及实现方式 <br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">乐观锁（Optimistic Lock）：</span><br><span class="line">每次获取数据的时候，都不会担心数据被修改，所以每次获取数据的时候都不会进行加锁，但是在更新数据的时候需要判断该数据是否被别人修改过。如果数据被其他线程修改，则不进行数据更新，如果数据没有被其他线程修改，则进行数据更新。由于数据没有进行加锁，期间该数据可以被其他线程进行读写操作。</span><br><span class="line">比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。</span><br></pre></td></tr></table></figure></p>
<p>Q.AQS实现原理？<br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AQS 的全称是 AbstactQueuedSynchronizer 即抽象队列同步器</span><br><span class="line">java并发包下很多API都是基于AQS来实现的加锁和释放锁等功能的，AQS是java并发包的基础类。比如：ReetrantLock ，ReentrantReadWriteLock 都是基于AQS来实现的。</span><br><span class="line">AQS 中维护了一个很重要的变量 state, 它是int型的，表示加锁的状态，初始状态值为0；另外 AQS 还维护了一个很重要的变量exclusiveOwnerThread，它表示的是获得锁的线程，也叫独占线程。AQS中还有一个用来存储获取锁失败线程的队列，以及head 和 tail 结点</span><br><span class="line">然后检查 当前线程是不是和获取锁的线程是同一个，结果发现是同一个，所以 state+1 = 2，这就是可重入的核心原理</span><br></pre></td></tr></table></figure></p>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>Q.JVM运行内存的分类?<br><br>A:<br>JVM内存结构：<br><img src="https://img-blog.csdn.net/20180812235058303?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JydWNlMTI4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"></p>
<p>堆：<br><img src="https://img-blog.csdn.net/2018031000051841?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYnJ1Y2UxMjg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- 程序计数器：当前线程所执行的字节码的行号指示器，用于记录下一条要运行的指令，线程私有</span><br><span class="line">注：如果正在执行的是Native方法，计数器值则为空</span><br><span class="line">- Java虚拟栈：存放基本数据类型、对象的引用、方法出口等，线程私有</span><br><span class="line">- Native方法栈：和虚拟栈相似，只不过它服务于Native方法，线程私有</span><br><span class="line">- Java堆：java内存最大的一块，所有对象实例、数组都存放在java堆，GC回收的地方，线程共享</span><br><span class="line">- 方法区：存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码数据等。（即永久带），回收目标主要是常量池的回收和类型的卸载，各线程共享</span><br></pre></td></tr></table></figure>
<p>Q.Java内存堆和栈区别?<br><br>A:</p>
<ul>
<li>栈内存用来存储基本类型的变量和对象的引用变量，堆内存用来存储Java中的对象，无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中</li>
<li>栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存，堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问</li>
<li>如果栈内存没有可用的空间存储方法调用和局部变量，JVM会抛出java.lang.StackOverFlowError，如果是堆内存没有可用的空间存储生成的对象，JVM会抛出java.lang.OutOfMemoryError</li>
<li>栈的内存要远远小于堆内存，如果你使用递归的话，那么你的栈很快就会充满，-Xss选项设置栈内存的大小。-Xms选项可以设置堆的开始时的大小</li>
</ul>
<p>Q.Java四引用?以及对应的使用场景？<br><br>A:<br>这4种级别由高到低依次为：强引用、软引用、弱引用和虚引用</p>
<ul>
<li>强引用（StrongReference）强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。 ps：强引用其实也就是我们平时A a = new A()这个意思。</li>
<li>软引用（SoftReference）<br>如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。<br>我们可以利用软引用实现一些缓存功能当第一次从数据库加载数据的时候将对象设置一个软引用，当对象使用完毕，GC还没有清理的时候再次加载对象时，可以先从软引用队列查找是否存在跟对象相关的软应用，如果存在则调用get方法获取该对象的强引用，否则再去数据库加载</li>
<li>弱引用（WeakReference）<br>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。<br>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中</li>
<li>虚引用（PhantomReference）<br>虚引用在任何时候都可能被垃圾回收器回收，主要用来跟踪对象被垃圾回收器回收的活动，被回收时会收到一个系统通知。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</li>
</ul>
<p>Q.GC回收机制?<br><br>A:<br></p>
<ul>
<li>Java中对象是采用new或者反射的方法创建的，这些对象的创建都是在堆（Heap）中分配的，所有对象的回收都是由Java虚拟机通过垃圾回收机制完成的。GC为了能够正确释放对象，会监控每个对象的运行状况，对他们的申请、引用、被引用、赋值等状况进行监控</li>
<li>Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理</li>
<li>可以调用下面的方法之一：System.gc() 或Runtime.getRuntime().gc() ，但JVM可以屏蔽掉显示的垃圾回收调用</li>
</ul>
<p>Q.GC 标记对象的死活?<br><br>A:<br></p>
<ul>
<li>引用计数法：给对象添加一个引用计数器,没当被引用的时候,计数器的值就加一。引用失效的时候减一,当计数器的值为 0 的时候就表示改对象可以被 GC 回收了，弊端:A-&gt;B,B-&gt;A,那么 AB 将永远不会被回收了。也就是引用有环的情况</li>
<li>根搜索算法(可达性算法) GC Roots Tracing：通过一个叫 GC Roots 的对象作为起点,从这些结点开始向下搜索,搜索所走过的路径称为引用链,当一个对象没有与任何的引用链相连的时候则改对象就可以被。 GC 回收回收了Roots 包括：java 虚拟机栈中引用的对象,本地方法栈中引用的对象,方法区中常量引用的对象,方法区中静态属性引用的对象</li>
</ul>
<p>Q.GC回收算法<br><br>A:</p>
<ul>
<li><p>标记-清除法：标记出没有用的对象，然后一个一个回收掉<br>缺点：标记和清除两个过程效率不高，产生内存碎片导致需要分配较大对象时无法找到足够的连续内存而需要触发一次GC操作</p>
</li>
<li><p>复制算法: 按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉<br>缺点：将内存缩小为了原来的一半</p>
</li>
<li><p>标记-整理法：标记出没有用的对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内<br>优点：解决了标记- 清除算法导致的内存碎片问题和在存活率较高时复制算法效率低的问题。</p>
</li>
<li><p>分代回收：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法</p>
</li>
</ul>
<p>Q.MinorGC&amp;FullGC <br><br>A:</p>
<ul>
<li>Minor GC通常发生在新生代的Eden区，在这个区的对象生存期短，往往发生GC的频率较高，回收速度比较快，一般采用复制-回收算法</li>
<li>Major GC 是清理老年代,Full GC 是清理整个堆空间—包括年轻代和老年代。</li>
<li>Full GC/Major GC 发生在老年代，一般情况下，触发老年代GC的时候不会触发Minor GC，所采用的是标记-清除算法</li>
</ul>
<p>Q.内存分配与回收策略<br><br>A:<br></p>
<ul>
<li>结构（堆大小 = 新生代 + 老年代 ）：<br>新生代(1/3)(初始对象，生命周期短)：Eden 区、survivior 0、survivior 1（ 8 : 1 : 1）<br>老年代(2/3)(长时间存在的对象)</li>
<li>一般小型的对象都会在 Eden 区上分配，如果Eden区无法分配，那么尝试把活着的对象放到survivor0中去（Minor GC）<br>如果survivor0可以放入，那么放入之后清除Eden区<br>如果survivor0不可以放入，那么尝试把Eden和survivor0的存活对象放到survivor1中<br>如果survivor1可以放入，那么放入survivor1之后清除Eden和survivor0，之后再把survivor1中的对象复制到survivor0中，保持survivor1一直为空。<br>如果survivor1不可以放入，那么直接把它们放入到老年代中，并清除Eden和survivor0，这个过程也称为分配担保（Full GC）</li>
<li>大对象、长期存活的对象则直接进入老年代</li>
<li>动态对象年龄判定</li>
<li>空间分配担保，Full GC…</li>
</ul>
<p>Q.GC垃圾收集器?<br><br>A:<br></p>
<ul>
<li>Serial New收集器是针对新生代的收集器，采用的是复制算法</li>
<li>Parallel New（并行）收集器，新生代采用复制算法，老年代采用标记整理</li>
<li>Parallel Scavenge（并行）收集器，针对新生代，采用复制收集算法</li>
<li>Serial Old（串行）收集器，新生代采用复制，老年代采用标记清理</li>
<li>Parallel Old（并行）收集器，针对老年代，标记整理</li>
<li><p>CMS收集器，基于标记-清除,收集器是一种以获取最短回收停顿时间为目标的收集器。<br>  CMS收集器是基于“标记—清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤：</p>
<p>  初始标记（CMS initial mark）<br>  初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要“Stop The World”。</p>
<p>  并发标记（CMS concurrent mark）<br>  并发标记阶段就是进行GC Roots Tracing的过程。</p>
<p>  重新标记（CMS remark）<br>  重新标记阶段是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短，仍然需要“Stop The World”。</p>
<p>  并发清除（CMS concurrent sweep）<br>  并发清除阶段会清除对象。</p>
<p>  由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p>
</li>
<li><p>G1收集器(JDK)：整体上是基于标记清理，局部采用复制</p>
<ul>
<li><p>并行与并发<br>G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。</p>
<p>分代收集<br>与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。</p>
<p>空间整合<br>与CMS的“标记—清理”算法不同，G1从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。<br>综上：新生代基本采用复制算法，老年代采用标记整理算法。cms采用标记清除</p>
</li>
</ul>
</li>
</ul>
<p>Q.CMS解决了什么问题？<br><br>A:<br><br> CMS，全称Concurrent Mark and Sweep，用于对年老代进行回收，目标是尽量减少应用的暂停时间，减少full gc发生的机率，利用和应用程序线程并发的垃圾回收线程来标记清除年老代。CMS并非没有暂停，而是用两次短暂停来替代串行标记整理算法的长暂停。<br>不能忍受长时间停顿要求快速响应的应用,减少应用停顿时间，主要用于web应用</p>
<p>Q为什么CMS两次标记时要 stop the world？<nr><br>A:<br><br>我们知道垃圾回收首先是要经过标记的。对象被标记后就会根据不同的区域采用不同的收集方法。看上去很完美的一件事情，其实并不然。<br>大家有没有想过一件事情，当虚拟机完成两次标记后，便确认了可以回收的对象。但是，垃圾回收并不会阻塞我们程序的线程，他是与当前程序并发执行的。所以问题就出在这里，当GC线程标记好了一个对象的时候，此时我们程序的线程又将该对象重新加入了“关系网”中，当执行二次标记的时候，该对象也没有重写finalize()方法，因此回收的时候就会回收这个不该回收的对象。<br>虚拟机的解决方法就是在一些特定指令位置设置一些“安全点”，当程序运行到这些“安全点”的时候就会暂停所有当前运行的线程（Stop The World 所以叫STW），暂停后再找到“GC Roots”进行关系的组建，进而执行标记和清除。<br>这些特定的指令位置主要在：</nr></p>
<pre><code>1、循环的末尾
2、方法临返回前 / 调用方法的call指令后
3、可能抛异常的位置
</code></pre><p>Q.Java类加载机制?<br><br>A:<br></p>
<ul>
<li>概念<br>虚拟机把描述类的数据文件（字节码）加载到内存，并对数据进行验证、准备、解析以及类初始化，最终形成可以被虚拟机直接使用的java类型（java.lang.Class对象）</li>
<li>类的生命周期</li>
</ul>
<ol>
<li>加载过程：通过一个类的全限定名来获取定义此类的二进制字节流，将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。在内存中(方法区)生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口；</li>
<li>验证过程：为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，文件格式验证、元数据验证、字节码验证、符号引用验证</li>
<li>准备过程：正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配</li>
<li>解析阶段：虚拟机将常量池内的符号引用替换为直接引用的过程</li>
<li>初始化阶段：类初始化阶段是类加载过程的最后一步。初始化阶段就是执行类构造器<clint>()方法的过程</clint></li>
<li>使用阶段：</li>
<li>卸载阶段：</li>
</ol>
<ul>
<li><p>Java类加载器<br>类加载器负责加载所有的类，同一个类(一个类用其全限定类名(包名加类名)标志)只会被加载一次<br>Bootstrap ClassLoader:根类加载器，负责加载java的核心类，它不是java.lang.ClassLoader的子类，而是由JVM自身实现<br>Extension ClassLoader:扩展类加载器，扩展类加载器的加载路径是JDK目录下jre/lib/ext,扩展类的getParent()方法返回null,实际上扩展类加载器的父类加载器是根加载器，只是根加载器并不是Java实现的<br>System ClassLoader:系统(应用)类加载器，它负责在JVM启动时加载来自java命令的-classpath选项、java.class.path系统属性或CLASSPATH环境变量所指定的jar包和类路径。程序可以通过getSystemClassLoader()来获取系统类加载器。系统加载器的加载路径是程序运行的当前路径</p>
</li>
<li><p>双亲委派模型的工作过程<br>首先会先查找当前ClassLoader是否加载过此类，有就返回；<br>如果没有，查询父ClassLoader是否已经加载过此类，如果已经加载过,就直接返回Parent加载的类；<br>如果整个类加载器体系上的ClassLoader都没有加载过，才由当前ClassLoader加载(调用findClass)，整个过程类似循环链表一样。</p>
</li>
<li><p>双亲委托机制的作用<br>共享功能，一些Framework层级的类一旦被顶层的ClassLoader加载过就缓存在内存里面，以后任何地方用到都不需要重新加载。<br>隔离功能，保证java/Android核心类库的纯净和安全，防止恶意加载。</p>
</li>
<li><p>如何打破双亲委派模型？<br>双亲委派模型的逻辑都在loadClass()中，重写loaderClass()，一般是重写findClass()的<br>系统自带的三个类加载器都加载特定目录下的类，如果我们自己的类加载器放在一个特殊的目录，那么系统的加载器就无法加载，也就是最终还是由我们自己的加载器加载</p>
</li>
<li><p>自定义ClassLoader？<br>loadClass(String name,boolean resolve)：根据指定的二进制名称加载类<br>findClass(String name)： 根据二进制名称来查找类<br>直接使用或继承已有的ClassLoader实现：java.net.URLClassLoader、java.security.SecureClassLoader、 java.rmi.server.RMIClassLoader<br>在调用loadClass()，会先根据委派模型在父加载器中加载，如果加载失败，则会调用自己的findClass方法来完成加载</p>
</li>
</ul>
<p>Q.引起类加载操作的五个行为?<br><br>A:<br></p>
<ul>
<li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令</li>
<li>反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化</li>
<li>子类初始化的时候，如果其父类还没初始化，则需先触发其父类的初始化</li>
<li>虚拟机执行主类的时候(有 main(string[] args))</li>
<li>JDK1.7 动态语言支持</li>
</ul>
<p>Q.Java对象创建时机?<br><br>A:<br></p>
<ul>
<li>使用new关键字创建对象</li>
<li>使用Class类的newInstance方法(反射机制)</li>
<li>使用Constructor类的newInstance方法(反射机制)</li>
<li>使用Clone方法创建对象</li>
<li>使用(反)序列化机制创建对象</li>
</ul>
<h3 id="数据库存储"><a href="#数据库存储" class="headerlink" title="数据库存储"></a>数据库存储</h3><p>Q.Mysql索引使用的注意事项<br><br>A:<br>索引的目的在于提高查询效率，可以类比字典,通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是我们总是通过同一种查找方式来锁定数据。</p>
<ul>
<li>UNIQUE(唯一索引)：不可以出现相同的值，可以有NULL值</li>
<li>INDEX(普通索引)：允许出现相同的索引内容</li>
<li>PROMARY KEY(主键索引)：不允许出现相同的值</li>
<li>fulltext index(全文索引)：可以针对值中的某个单词，但效率确实不敢恭维</li>
<li>组合索引：实质上是将多个字段建到一个索引里，列值的组合必须唯一</li>
</ul>
<p>Q.Sql优化方法 <br><br>A:</p>
<ul>
<li>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</li>
<li>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描</li>
<li>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描</li>
<li><p>应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num=10 or num=20</span><br><span class="line">可以这样查询：</span><br><span class="line">select id from t where num=10</span><br><span class="line">union all</span><br><span class="line">select id from t where num=20</span><br></pre></td></tr></table></figure>
</li>
<li><p>in 和 not in 也要慎用，否则会导致全表扫描</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num in(1,2,3)</span><br><span class="line">对于连续的数值，能用 between 就不要用 in 了：</span><br><span class="line">select id from t where num between 1 and 3</span><br></pre></td></tr></table></figure>
</li>
<li><p>任何地方都不要使用 select <em> from t ，用具体的字段列表代替“</em>”，不要返回用不到的任何字段</p>
</li>
<li>尽可能的使用 varchar 代替 char ，因为首先变长字段存储空间小，可以节省存储空间</li>
</ul>
<p>Q.mysql explain的用法和结果的含义？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">explain select surname,first_name form a,b where a.id=b.id </span><br><span class="line"></span><br><span class="line">table：显示这一行的数据是关于哪张表的</span><br><span class="line"></span><br><span class="line">type：这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、index和ALL</span><br><span class="line">    type显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</span><br><span class="line">    一般来说，得保证查询至少达到range级别，最好能达到ref。</span><br></pre></td></tr></table></figure></p>
<p>Q.Mysql遇到死锁问题？<br><br>A.<br>MySQL有三种锁的级别：页级、表级、行级</p>
<ul>
<li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</li>
<li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</li>
<li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度</li>
<li>所谓死锁<deadlock>:<br>是指两个或两个以上的进程在执行过程中,<br>因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去.<br>此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等竺的进程称为死锁进程.<br>表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB.</deadlock></li>
</ul>
<p>死锁的关键在于：两个(或以上)的Session加锁的顺序不一致。那么对应的解决死锁问题的关键就是：让不同的session加锁有次序</p>
<p>死锁案例：<br><br>需求：将投资的钱拆成几份随机分配给借款人。<br>投资人投资后，将金额随机分为几份，然后随机从借款人表里面选几个，然后通过一条条select for update 去更新借款人表里面的余额等。<br>抽象出来就是一个session通过for循环会有几条如下的语句：</p>
<p><code>Select * from xxx where id=&#39;随机id&#39; for update</code></p>
<p>基本来说，程序开启后不一会就死锁。这可以是说最经典的死锁情形了。例如两个用户同时投资，A用户金额随机分为2份，分给借款人1，2;B用户金额随机分为2份，分给借款人2，1;由于加锁的顺序不一样，死锁当然很快就出现了。<br>对于这个问题的改进很简单，直接把所有分配到的借款人直接一次锁住就行了。</p>
<p><code>Select * from xxx where id in (xx,xx,xx) for update</code></p>
<p>在in里面的列表值mysql是会自动从小到大排序，加锁也是一条条从小到大加的锁</p>
<p>Q.数据库索引的原理<br><br>A:<br><br>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。</p>
<p>Q.MySQL数据库的索引类型？<br><br>A:<br><br>Mysql目前主要有以下几种索引类型：FULLTEXT，HASH，BTREE，RTREE。</p>
<ol>
<li>FULLTEXT<br>即为全文索引，目前只有MyISAM引擎支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。<br>全文索引并不是和MyISAM一起诞生的，它的出现是为了解决WHERE name LIKE “%word%”这类针对文本的模糊查询效率较低的问题。</li>
<li>HASH<br>由于HASH的唯一（几乎100%的唯一）及类似键值对的形式，很适合作为索引。<br>HASH索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率。但是，这种高效是有条件的，即只在“=”和“in”条件下高效，对于范围查询、排序及组合索引仍然效率不高。</li>
<li>BTREE<br>BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。这是MySQL里默认和最常用的索引类型。</li>
<li>RTREE<br>RTREE在MySQL很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种</li>
</ol>
<p>Q.索引种类有哪些？<br><br>A:<br><br>普通索引：仅加速查询<br>唯一索引：加速查询 + 列值唯一（可以有null）<br>主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个<br>组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并<br>全文索引：对文本的内容进行分词，进行搜索</p>
<p>Q.存储引擎的InnoDB与MyISAM<br><br>A:<br></p>
<ul>
<li>InnoDB支持事务，MyISAM不支持，这一点是非常之重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了</li>
<li>MyISAM适合查询以及插入为主的应用，InnoDB适合频繁修改以及涉及到安全性较高的应用</li>
<li>InnoDB支持外键，MyISAM不支持</li>
<li>从MySQL5.5.5以后，InnoDB是默认引擎</li>
<li>InnoDB不支持FULLTEXT类型的索引</li>
<li>InnoDB中不保存表的行数，如select count() from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含where条件时MyISAM也需要扫描整个表</li>
<li>清空整个表时，InnoDB是一行一行的删除，效率非常慢。MyISAM则会重建表</li>
<li>InnoDB支持行锁（某些情况下还是锁整表，如 update table set a=1 where user like ‘%lee%’</li>
</ul>
<p>Q.为什么使用B-tree<br><br>A:<br><br>鉴于B-tree具有良好的定位特性，其常被用于对检索时间要求苛刻的场合，例如：<br>1、B-tree索引是数据库中存取和查找文件(称为记录或键值)的一种方法。<br>2、硬盘中的结点也是B-tree结构的。与内存相比，硬盘必须花成倍的时间来存取一个数据元素，这是因为硬盘的机械部件读写数据的速度远远赶不上纯电子媒体的内存。与一个结点两个分支的二元树相比，B-tree利用多个分支（称为子树）的结点，减少获取记录时所经历的结点数，从而达到节省存取时间的目的。</p>
<p>Q.聚集索引与非聚集索引的区别<br><br>A:<br><br>聚集索引：可以帮助把很大的范围，迅速减小范围。但是查找该记录，就要从这个小范围中Scan了。<br>非聚集索引：把一个很大的范围，转换成一个小的地图。你需要在这个小地图中找你要寻找的信息的位置。然后通过这个位置，再去找你所需要的记录。</p>
<p>Q.limit 20000 加载很慢怎么解决<br><br>A:<br><br>LIMIT n 等价于 LIMIT 0,n<br>此题总结一下就是让limit走索引去查询，例如：order by 索引字段，或者limit前面根where条件走索引字段等等。</p>
<p>Q.选择合适的分布式主键方案<br><br>A:<br></p>
<ul>
<li>数据库自增长序列或字段</li>
<li>UUID</li>
<li>UUID的变种</li>
<li>Redis生成ID</li>
<li>Twitter的snowflake算法</li>
</ul>
<p>Q.选择合适的数据存储方案<br><br>A:<br></p>
<ul>
<li><p>关系型数据库 MySQL<br><br>MySQL 是一个最流行的关系型数据库，在互联网产品中应用比较广泛。一般情况下，MySQL 数据库是选择的第一方案，基本上有 80% ~ 90% 的场景都是基于 MySQL 数据库的。因为，需要关系型数据库进行管理，此外，业务存在许多事务性的操作，需要保证事务的强一致性。同时，可能还存在一些复杂的 SQL 的查询。值得注意的是，前期尽量减少表的联合查询，便于后期数据量增大的情况下，做数据库的分库分表。</p>
</li>
<li><p>内存数据库 Redis<br>随着数据量的增长，MySQL 已经满足不了大型互联网类应用的需求。因此，Redis 基于内存存储数据，可以极大的提高查询性能，对产品在架构上很好的补充。例如，为了提高服务端接口的访问速度，尽可能将读频率高的热点数据存放在 Redis 中。这个是非常典型的以空间换时间的策略，使用更多的内存换取 CPU 资源，通过增加系统的内存消耗，来加快程序的运行速度。</p>
</li>
</ul>
<p>在某些场景下，可以充分的利用 Redis 的特性，大大提高效率。这些场景包括缓存，会话缓存，时效性，访问频率，计数器，社交列表，记录用户判定信息，交集、并集和差集，热门列表与排行榜，最新动态等。</p>
<p>使用 Redis 做缓存的时候，需要考虑数据不一致与脏读、缓存更新机制、缓存可用性、缓存服务降级、缓存穿透、缓存预热等缓存使用问题。</p>
<ul>
<li>文档数据库 MongoDB<br><br>MongoDB 是对传统关系型数据库的补充，它非常适合高伸缩性的场景，它是可扩展性的表结构。基于这点，可以将预期范围内，表结构可能会不断扩展的 MySQL 表结构，通过 MongoDB 来存储，这就可以保证表结构的扩展性。</li>
</ul>
<p>此外，日志系统数据量特别大，如果用 MongoDB 数据库存储这些数据，利用分片集群支持海量数据，同时使用聚集分析和 MapReduce 的能力，是个很好的选择。</p>
<p>MongoDB 还适合存储大尺寸的数据，GridFS 存储方案就是基于 MongoDB 的分布式文件存储系统。</p>
<ul>
<li><p>列族数据库 HBase<br><br>HBase 适合海量数据的存储与高性能实时查询，它是运行于 HDFS 文件系统之上，并且作为 MapReduce 分布式处理的目标数据库，以支撑离线分析型应用。在数据仓库、数据集市、商业智能等领域发挥了越来越多的作用，在数以千计的企业中支撑着大量的大数据分析场景的应用。</p>
</li>
<li><p>全文搜索引擎 ElasticSearch<br><br>在一般情况下，关系型数据库的模糊查询，都是通过 like 的方式进行查询。其中，like “value%” 可以使用索引，但是对于 like “%value%” 这样的方式，执行全表查询，这在数据量小的表，不存在性能问题，但是对于海量数据，全表扫描是非常可怕的事情。ElasticSearch 作为一个建立在全文搜索引擎 Apache Lucene 基础上的实时的分布式搜索和分析引擎，适用于处理实时搜索应用场景。此外，使用 ElasticSearch 全文搜索引擎，还可以支持多词条查询、匹配度与权重、自动联想、拼写纠错等高级功能。因此，可以使用 ElasticSearch 作为关系型数据库全文搜索的功能补充，将要进行全文搜索的数据缓存一份到 ElasticSearch 上，达到处理复杂的业务与提高查询速度的目的。</p>
</li>
</ul>
<p>ElasticSearch 不仅仅适用于搜索场景，还非常适合日志处理与分析的场景。著名的 ELK 日志处理方案，由 ElasticSearch、Logstash 和 Kibana 三个组件组成，包括了日志收集、聚合、多维度查询、可视化显示等。</p>
<p>Q.ObjectId 规则<br><br>A:<br><br> 它并没有采用自动增长主键，因为在分布式服务器之间做数据同步很麻烦，而是采用了一种ObjectId的方式，它生成方便，占用空间比long多了4个字节，（12个字节）在数据表现层面也说的过去，它是一种以时间，机器，进程和自增几个因素组合的方式来体现的，可以近似看成是按时间的先后进行排序的，对于ObjectId的生成我们可以通过MongoDB服务端去获得，或者在客户端也有对它的集成，使用方便，一般情况下，在客户端实体类中只要定义一个ObjectId类型的属性，这个属性就默认被赋上值了，应该说，还是比较方便的，由于它存储是一种字符串，所以，一般客户端，像NoRM都为我们实现了对string类型的隐藏转换，应该说，还是比较友好的！</p>
<p>Q.聊聊 MongoDB 使用场景<br><br>A:<br></p>
<ul>
<li>用在应用服务器的日志记录，查找起来比文本灵活，导出也很方便。也是给应用练手，从外围系统开始使用MongoDB</li>
<li>mongodb之前有用过，主要用来存储一些监控数据，No schema 对开发人员来说，真的很方便，增加字段不用改表结构，而且学习成本极低</li>
<li>使用MongoDB做了O2O快递应用，·将送快递骑手、快递商家的信息（包含位置信息）存储在 MongoDB，然后通过 MongoDB 的地理位置查询，这样很方便的实现了查找附近的商家、骑手等功能，使得快递骑手能就近接单</li>
</ul>
<p>Q.聊聊 ElasticSearch 使用场景<br><br>A:<br><br>在一般情况下，关系型数据库的模糊查询，都是通过 like 的方式进行查询。其中，like “value%” 可以使用索引，但是对于 like “%value%” 这样的方式，执行全表查询，这在数据量小的表，不存在性能问题，但是对于海量数据，全表扫描是非常可怕的事情。ElasticSearch 作为一个建立在全文搜索引擎 Apache Lucene 基础上的实时的分布式搜索和分析引擎，适用于处理实时搜索应用场景。此外，使用 ElasticSearch 全文搜索引擎，还可以支持多词条查询、匹配度与权重、自动联想、拼写纠错等高级功能。因此，可以使用 ElasticSearch 作为关系型数据库全文搜索的功能补充，将要进行全文搜索的数据缓存一份到 ElasticSearch 上，达到处理复杂的业务与提高查询速度的目的。</p>
<h2 id="10-4-Python"><a href="#10-4-Python" class="headerlink" title="10.4 Python"></a>10.4 Python</h2><p>Q. Python 的特点和优点是什么?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 解释性</span><br><span class="line">2. 动态特性</span><br><span class="line">3. 面向对象</span><br><span class="line">4. 语法简洁</span><br><span class="line">5. 开源</span><br><span class="line">6. 丰富的社区资源</span><br></pre></td></tr></table></figure></p>
<p>Q.深拷贝和浅拷贝的区别是什么？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">深拷贝是将对象本身复制给另一个对象。这意味着如果对对象的副本进行更改时不会影响原对象。在 Python 中，我们使用 deepcopy（）函数进行深拷贝，使用方法如下：</span><br><span class="line"></span><br><span class="line">浅拷贝是将对象的引用复制给另一个对象。因此，如果我们在副本中进行更改，则会影响原对象。使用 copy（）函数进行浅拷贝</span><br></pre></td></tr></table></figure></p>
<p>Q.如何在一个函数内部修改全局变量？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">global修饰该变量</span><br></pre></td></tr></table></figure></p>
<p>Q.列出5个python标准库?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">os：提供了不少与操作系统相关联的函数</span><br><span class="line">sys:   通常用于命令行参数</span><br><span class="line">re:   正则匹配</span><br><span class="line">math: 数学运算</span><br><span class="line">datetime:处理日期时间</span><br></pre></td></tr></table></figure></p>
<p>Q.字典如何删除键和合并两个字典?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del和update方法</span><br></pre></td></tr></table></figure></p>
<p>Q.谈下python的GIL?为什么说python的多线程不是真正的多线程？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GIL 是python的全局解释器锁，同一进程中假如有多个线程运行，一个线程在运行python程序的时候会霸占python解释器（加了一把锁即GIL），使该进程内的其他线程无法运行，等该线程运行完后其他线程才能运行。如果线程运行过程中遇到耗时操作，则解释器锁解开，使其他线程运行。所以在多线程中，线程的运行仍是有先后顺序的，并不是同时进行。</span><br><span class="line"></span><br><span class="line">多进程中因为每个进程都能被系统分配资源，相当于每个进程有了一个python解释器，所以多进程可以实现多个进程的同时运行，缺点是进程系统资源开销大</span><br></pre></td></tr></table></figure></p>
<p>Q.python实现列表去重的方法?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">先通过集合去重，在转列表</span><br><span class="line">list=[4,533,23,4,23]</span><br><span class="line">set(list)</span><br></pre></td></tr></table></figure></p>
<p>Q.fun(<em>args,**kwargs)中的</em>args,**kwargs什么意思？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*args表示任何多个无名参数，它是一个tuple</span><br><span class="line">**kwargs表示关键字参数，它是一个dict</span><br></pre></td></tr></table></figure></p>
<p>Q.简述面向对象中<strong>new</strong>和<strong>init</strong>区别?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、__new__至少要有一个参数cls，代表当前类，此参数在实例化时由Python解释器自动识别</span><br><span class="line"></span><br><span class="line">2、__new__必须要有返回值，返回实例化出来的实例，这点在自己实现__new__时要特别注意，可以return父类（通过super(当前类名, cls)）__new__出来的实例，或者直接是object的__new__出来的实例</span><br><span class="line"></span><br><span class="line">3、__init__有一个参数self，就是这个__new__返回的实例，__init__在__new__的基础上可以完成一些其它初始化的动作，__init__不需要返回值</span><br><span class="line"></span><br><span class="line">4、如果__new__创建的是当前类的实例，会自动调用__init__函数，通过return语句里面调用的__new__函数的第一个参数是cls来保证是当前类实例，如果是其他类的类名，；那么实际创建返回的就是其他类的实例，其实就不会调用当前类的__init__函数，也不会调用其他类的__init__函数。</span><br></pre></td></tr></table></figure></p>
<p>Q.简述with方法打开处理文件帮我我们做了什么？?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">打开文件在进行读写的时候可能会出现一些异常状况，如果按照常规的f.open</span><br><span class="line">写法，我们需要try,except,finally，做异常判断，并且文件最终不管遇到什么情况，都要执行finally f.close()关闭文件，with方法帮我们实现了finally中f.close</span><br></pre></td></tr></table></figure></p>
<p>Q.列表[1,2,3,4,5],请使用map()函数输出[1,4,9,16,25]，并使用列表推导式提取出大于10的数，最终输出[16,25]?<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list = [1,2,3,4,5]</span><br><span class="line">def fn(x):</span><br><span class="line">    return x**2</span><br><span class="line">res = map(fn,list)</span><br><span class="line">res = [i for i in res if i&gt;10]</span><br></pre></td></tr></table></figure></p>
<p>Q.Python装饰器模式？<br><br>A:<br></p>
<ul>
<li><p>带参数的装饰器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logging</span><span class="params">(level)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner_wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">"[&#123;level&#125;]: enter function &#123;func&#125;()"</span>.format(</span><br><span class="line">                level=level,</span><br><span class="line">                func=func.__name__)</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> inner_wrapper</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@logging(level='INFO')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(something)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"say &#123;&#125;!"</span>.format(something)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有使用@语法，等同于</span></span><br><span class="line"><span class="comment"># say = logging(level='INFO')(say)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@logging(level='DEBUG')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do</span><span class="params">(something)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"do &#123;&#125;..."</span>.format(something)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    say(<span class="string">'hello'</span>)</span><br><span class="line">    do(<span class="string">"my work"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>带参数的类装饰器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">logging</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, level=<span class="string">'INFO'</span>)</span>:</span></span><br><span class="line">        self.level = level</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, func)</span>:</span> <span class="comment"># 接受函数</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">"[&#123;level&#125;]: enter function &#123;func&#125;()"</span>.format(</span><br><span class="line">                level=self.level,</span><br><span class="line">                func=func.__name__)</span><br><span class="line">            func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper  <span class="comment">#返回函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@logging(level='INFO')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(something)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"say &#123;&#125;!"</span>.format(something)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="11-中间件"><a href="#11-中间件" class="headerlink" title="11. 中间件"></a>11. 中间件</h1><h2 id="11-1-tomcat"><a href="#11-1-tomcat" class="headerlink" title="11.1 tomcat"></a>11.1 tomcat</h2><p>Q.Tomcat的类加载机制？<br><br>A:<br><br>Tomcat的类加载机制是违反了双亲委托原则的，对于一些未加载的非基础类(Object,String等)，各个web应用自己的类加载器(WebAppClassLoader)会优先加载，加载不到时再交给commonClassLoader走双亲委托。<br>对于JVM来说：<br>因此，按照这个过程可以想到，如果同样在CLASSPATH指定的目录中和自己工作目录中存放相同的class，会优先加载CLASSPATH目录中的文件。<br><img src="https://images0.cnblogs.com/blog2015/449064/201506/141327112691951.jpg" alt="image"></p>
<h2 id="11-2-redis"><a href="#11-2-redis" class="headerlink" title="11.2 redis"></a>11.2 redis</h2><p>Q.Redis有哪些类型<br><br>A:<br><br>Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。</p>
<p>Q.Redis的内部结构<br><br>A:<br><br>当我们在本文中提到Redis的“数据结构”，可能是在两个不同的层面来讨论它。</p>
<ul>
<li>第一个层面，是从使用者的角度，string，list，hash，set，sorted set</li>
<li>第二个层面，是从内部实现的角度，属于更底层的实现，ht(dict),raw,embstr,intset,sds,ziplist,quicklist,skiplist</li>
<li>存储效率（memory efficiency）。Redis是专用于存储数据的，它对于计算机资源的主要消耗就在于内存，因此节省内存是它非常非常重要的一个方面。这意味着Redis一定是非常精细地考虑了压缩数据、减少内存碎片等问题。</li>
<li>快速响应时间（fast response time）。与快速响应时间相对的，是高吞吐量（high throughput）。Redis是用于提供在线访问的，对于单个请求的响应时间要求很高，因此，快速响应时间是比高吞吐量更重要的目标。有时候，这两个目标是矛盾的。</li>
<li>单线程（single-threaded）。Redis的性能瓶颈不在于CPU资源，而在于内存访问和网络IO。而采用单线程的设计带来的好处是，极大简化了数据结构和算法的实现。相反，Redis通过异步IO和pipelining等机制来实现高速的并发访问。显然，单线程的设计，对于单个请求的快速响应时间也提出了更高的要求。</li>
</ul>
<p>Q.Redis的内部淘汰机制<br><br>A:<br></p>
<ul>
<li>noeviction：当内存使用达到阈值的时候，所有引起申请内存的命令会报错。</li>
<li>allkeys-lru：在主键空间中，优先移除最近未使用的key。</li>
<li>volatile-lru：在设置了过期时间的键空间中，优先移除最近未使用的key。</li>
<li>allkeys-random：在主键空间中，随机移除某个key。</li>
<li>volatile-random：在设置了过期时间的键空间中，随机移除某个key。</li>
<li>volatile-ttl：在设置了过期时间的键空间中，具有更早过期时间的key优先移除。</li>
</ul>
<p>Q.Redis的使用场景<br><br>A:<br><br>随着数据量的增长，MySQL 已经满足不了大型互联网类应用的需求。因此，Redis 基于内存存储数据，可以极大的提高查询性能，对产品在架构上很好的补充。例如，为了提高服务端接口的访问速度，尽可能将读频率高的热点数据存放在 Redis 中。这个是非常典型的以空间换时间的策略，使用更多的内存换取 CPU 资源，通过增加系统的内存消耗，来加快程序的运行速度。<br>在某些场景下，可以充分的利用 Redis 的特性，大大提高效率。这些场景包括缓存，会话缓存，时效性，访问频率，计数器，社交列表，记录用户判定信息，交集、并集和差集，热门列表与排行榜，最新动态等。<br>使用 Redis 做缓存的时候，需要考虑数据不一致与脏读、缓存更新机制、缓存可用性、缓存服务降级、缓存穿透、缓存预热等缓存使用问题。</p>
<p>Q.Redis持久化机制<br><br>A:<br><br>redis 支持两种持久化方式，一种是 Snapshotting（快照）也是默认方式，另一种是 Append-only file</p>
<ul>
<li>快照是默认的持久化方式。这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb。可以通过配置设置自动做快照持久化的方式。</li>
<li>由于快照方式是在一定间隔时间做一次的，所以如果 redis 意外 down 掉的话，就会丢失最后一次快照后的所有修改。如果应用要求不能丢失任何修改的话，可以采用 aof 持久化方式。下面介绍 Append-only file:aof 比快照方式有更好的持久化性，是由于在使用 aof 持久化方式时,redis 会将每一个收到的写命令都通过 write 函数追加到文件中(默认是 appendonly.aof)。当 redis 重启时会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。当然由于 os 会在内核中缓存 write 做的修改，所以可能不是立即写到磁盘上。这样 aof 方式的持久化也还是有可能会丢失部分修改。不过我们可以通过配置文件告诉 redis 我们想要通过 fsync 函数强制 os 写入到磁盘的时机。有三种方式如下（默认是：每秒 fsync 一次）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes //启用 aof 持久化方式</span><br><span class="line"># appendfsync always //收到写命令就立即写入磁盘，最慢，但是保证完全的持久化</span><br><span class="line">appendfsync everysec //每秒钟写入磁盘一次，在性能和持久化方面做了很好的折中</span><br><span class="line"># appendfsync no //完全依赖 os，性能最好,持久化没保证</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Q.Redis集群方案与实现<br><br>A:<br><br>Redis在互联网大数据平台有着广泛的应用，主要被用来缓存热点数据，避免海量请求压垮数据库，同时可以提升服务节点的响应速度和并发量。随着数据量的增多，由于redis是占用单台物理机或虚机的内存，内存资源是有限的，要动态地扩容缩容，就需要用到redis集群。redis集群的架构方案经历了一系列演变和改良的过程，本文介绍了四种主流的redis架构方案。</p>
<ul>
<li>客户端分片<br>  优点:<br>  不使用第三方中间件，实现方法和代码可以自己掌控并且可随时调整。这种分片性能比代理式更好(因为少了分发环节)，分发压力在客户端，无服务端压力增加<br>  缺点:<br>  不能平滑地水平扩容，扩容/缩容时，必须手动调整分片程序，出现故障不能自动转移，难以运维</li>
<li>Twemproxy(代理)<br>  优点：<br>  运维成本低。业务方不用关心后端 Redis 实例，跟操作 Redis 一样。Proxy 的逻辑和存储的逻辑是隔离的<br>  缺点<br>  a. 代理层多了一次转发，性能有所损耗<br>  b. 进行扩容/缩容时候，部分数据可能会失效，需要手动进行迁移，对运维要求较高，而且难以做到平滑的扩缩容<br>  c. 出现故障，不能自动转移，运维性很差</li>
<li>Redis Cluster<br>  优点：<br>  a. 无中心节点<br>  b. 数据按照 Slot 存储分布在多个 Redis 实例上<br>  c. 平滑的进行扩容/缩容节点<br>  d. 自动故障转移(节点之间通过 Gossip 协议交换状态信息,进行投票机制完成 Slave 到 Master 角<br>色的提升)<br>  e. 降低运维成本，提高了系统的可扩展性和高可用性<br>  缺点：<br>  a. 严重依赖外部 Redis-Trib<br>  b. 缺乏监控管理<br>  c. 需要依赖 Smart Client(连接维护, 缓存路由表, MultiOp 和 Pipeline 支持)<br>  d. Failover 节点的检测过慢，不如“中心节点 ZooKeeper”及时<br>  e. Gossip 消息的开销<br>  f. 无法根据统计区分冷热数据<br>  g. Slave“冷备”，不能缓解读压力<br>实际应用方案：</li>
<li>方案 1 使用nginx开发(OpenResty方式)</li>
<li>方案 2 codis （豌豆荚采用的基于代理的redis集群方案)</li>
<li>方案3 自己独立开发redis智能客户端</li>
</ul>
<p>Q.Redis为什么是单线程的<br><br>A:<br><br>单纯的网络IO来说，量大到一定程度之后，多线程的确有优势——但并不是单纯的多线程，而是每个线程自己有自己的epoll这样的模型，也就是多线程和multiplexing混合<br>还要考虑Redis操作的对象。它操作的对象是内存中的数据结构。如果在多线程中操作，那就需要为这些对象加锁。最终来说，多线程性能有提高，但是每个线程的效率严重下降了。而且程序的逻辑严重复杂化。<br>要知道Redis的数据结构并不全是简单的Key-Value，还有列表，hash，map等等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在hash当中添加或者删除一个对象，等等。这些操作还可以合成MULTI/EXEC的组。这样一个操作中可能就需要加非常多的锁，导致的结果是同步开销大大增加。这还带来一个恶果就是吞吐量虽然增大，但是响应延迟可能会增加。<br>Redis在权衡之后的选择是用单线程，突出自己功能的灵活性。在单线程基础上任何原子操作都可以几乎无代价地实现，多么复杂的数据结构都可以轻松运用，甚至可以使用Lua脚本这样的功能。对于多线程来说这需要高得多的代价。</p>
<p>Q.缓存崩溃<br><br>A:<br><br>缓存雪崩是由于原有缓存失效(过期)，新缓存未到期间。所有请求都去查询数据库，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。</p>
<p>Q.缓存降级<br><br>A:<br><br>服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。</p>
<p>Q.使用缓存的合理性问题<br><br>A:<br></p>
<ul>
<li>热点数据，缓存才有价值</li>
<li>频繁修改的数据，看情况考虑使用缓存</li>
<li>数据不一致性</li>
<li>缓存更新机制</li>
<li>缓存可用性</li>
<li>缓存服务降级</li>
<li>缓存预热</li>
<li>缓存穿透</li>
</ul>
<h2 id="11-3-消息队列-MQ"><a href="#11-3-消息队列-MQ" class="headerlink" title="11.3 消息队列(MQ)"></a>11.3 消息队列(MQ)</h2><p>Q.消息队列的使用场景?<br><br>A:<br><br>主要解决应用耦合，异步消息，流量削锋,增大吞吐量等问题</p>
<ul>
<li>异步处理</li>
<li>应用解耦</li>
<li>流量削锋</li>
<li>日志处理</li>
<li>消息通讯</li>
</ul>
<p>Q.JMS消息队列的消息模型？<br><br>A:<br><br>JMS消息队列的两种消息模型P2P（Point to Point）,Publish/Subscribe(Pub/Sub)<br>P2P特点：</p>
<ul>
<li>每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)</li>
<li>发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行，它不会影响到消息被发送到队列</li>
<li>接收者在成功接收消息之后需向队列应答成功<br>Pub/Sub的特点：</li>
<li>每个消息可以有多个消费者</li>
<li>发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息</li>
<li>为了消费消息，订阅者必须保持运行的状态</li>
</ul>
<p>Q.消息的重发补偿解决思路？<br><br>A:<br></p>
<ul>
<li><p>MQ消息发送过程：<br>  1:  消息生产者中send会阻塞操作(网络IO阻塞),如果网络异常,将导致消息发送失败,此时生产者需要在编码设计上做好异常检测或者重发机制;其中网络异常主要体现在”网络中断”或者JMS Provider失效.</p>
<p>  2:  JMS Provider接收到消息之后,将会保存在内存中(或者DB中),此后并立即向此Producer发送”ACK”信号,如果JMS Provider在存储上遇到无法解决的异常(比如磁盘故障,嵌入式DB异常),那么”ACK”响应将会携带异常信息(message);如果”ACK”发送中网络IO异常导致无法发送,将会导致”此消息”被移除,此时send方法也将从阻塞中返回并抛出异常.因为网络IO异常,通常TCP链接的双端都能及时的感知到.</p>
<pre><code>ACK发送正常,指的是TCP连接上&quot;ACK&quot;数据已经通过网络发送给了Client,这个过程中没有发生异常,此后也意味着当前JMS消息被持久存储,producer的send方法也正确返回.此后如果Client端在处理ACK信息过程中出现问题(几乎不可能),那么JMS Provider也将认为此消息已经被正确发送.需要提醒的是,在Client端:消息的send和ACK在IO流上不是一个连续的过程,在不同的确认时机中,ACK信息是可以是同步的(send方法阻塞,知道收到ACK,比如持久化类型的消息),有些时异步获取的(比如事务中的消息,或者非持久化消息),不过JMS中的ACK MODE都producer并没有任何意义..
</code></pre><p>  3: 消息消费者receive消息,这个操作在Queue中是consumer主动”拉取”(监听),在Topic中是Provider推送;当消费者接收到消息之后,可以立即确认(AUTO),然后再去执行与消息有关的业务;也可以”延迟”确认等.</p>
<p>  4: 当消息被消费者接收到之后,JMS Provider将消息添加到此消费者的”待确认消息”列表,如果JMS Provider在此消费者的IO通道中阻塞返回,但却没有收到ACK,那么将导致此消息重发.如果ACK正常接收到,那么JMS Provider将会把此消息从持久存储设备删除.</p>
</li>
<li><p>JMS中ACK MODE</p>
<ol>
<li><p>AUTO_ACKNOWLEDGE:自动确认,当Consumer客户端(通常是指Consumer所属的Session)在收到消息之后,即准备确认消息,通常在receive()方法返回之前,或者在messageListener.onMessage()正常执行之后,向Provider发送ACK指令..所谓AUTO_ACK,就是确认的时机有Session”择机”实施;开发者无法干扰.</p>
</li>
<li><p>DUPS_OK_ACKNOWLEDGE: 允许延迟批量确认,重点在”批量”,AUTO_ACK通常是确认一条消息(事实上在不同的JMS实现中,它仍然可以像DUPS一样确认多条消息)..当消费者接收到消息之后,并不是立即确认,而是”滞留”一段时间之后才会确认(批量确认);这种方式直观上是提升了client端消费数据的速度(优先接触消息),但这种模式下,需要消费者能够接受”消息重发”的情况,比如当Consumer客户端失效重启,那些尚未确认但已经被”touch”(消费)过的消息有可能会重复接受到;对于JMS Provider而言,如果它”等待”一定时间后,仍未收到”确认”,将会重发消息.,这种模式,对性能的提升是不明确的,因为较晚的确认消息,意味着JMS Provider需要更长时间的保留”待确认”消息列表..究竟多少条消息作为”批量”的边界,有具体的JMS实现者决定.</p>
</li>
<li><p>CLIENT_ACKNOWLEDGE: 客户端确认,需要要求消息消费者明确的调用message.acknowledge()方法来确认此消息的接收成功,无论何种原因(未捕获异常),如果此方法未被调用,那么此消息将会被重发.这种模式下,允许消费者自己选择时机确认消息,通常使用在消息编组(group)的情况下:将一系列消息作为一个group接收,当group中最后一个消息确认成功后,那么JMS Provider就认为此组消息全部接收成功(只需确认组的最后一条消息即可,那么JMS Provider会认为此前的其他消息也接收正常).</p>
</li>
</ol>
</li>
<li><p>消息保证</p>
</li>
<li><p>事务<br>  事务用来描述”一系列消息要么全部确认成功,要么全不确认”的特征,它和数据库事务最终需要达成的效果是一样的.JMS Provider会缓存每个生产者当前事务下的所有消息,直到commit或者rollback.commit操作将会导致事务中所有的消息被持久存储;rollback意味着JMS Provider将会清除此事务下所有的消息记录…在事务未提交之前,消息是不会被持久存储的,也不会被消费者消费.</p>
<p>  每次事务提交之后,在client端会生成一个事务ID(一个session中不会出现重复的ID,clientID:sessionID:txID);事务的提交或者回滚都会携带ID.对于producer而言,在事务类型的session中,发送消息(一个或者多个)之后,需要执行session.commit(),否则消息将不会被存储.对于consumer而言,消息接收到之后,需要手动的使用commit,否则JMS Provider会认为消息没有被接收,导致重发,因此你可以认为commit就是一个消息确认操作.</p>
</li>
<li><p>消息编组<br>  一序列消息,如果不编组的话,可能会被分发给不同的消费者;但是很多时候,我们期望这”一序列”的消息能够有序的交付给一个消费者,无论是消息的发送还是消费,都希望它们是不可分割的”组合”.那么此时我们需要”消息编组”,我们需要使用到”JMSXGroupID”/“JMSXGroupSeq”两个属性.注意JMSProvider并不会根据JMSXGroupSeq进行排序,顺序还是需要自己来维护.</p>
</li>
</ul>
<p>Q.消息的幂等性解决思路？<br><br>A:<br><br>生产者发送信息到MQ Server：</p>
<ul>
<li>MQ内部生成全局唯一的消息ID，具有业务无关性，对消息发送方和消息接收方屏蔽，保证只有一条消息发送到MQ Server落库<br>MQ Server发送消息给消费者</li>
<li>业务消息体重必须有一个biz_id，作为幂等和去重的依据<ol>
<li>业务全局唯一</li>
<li>由业务消息发送方生成，业务相关，对MQ透明</li>
<li>有业务消息消费方负责判重，保证幂等</li>
</ol>
</li>
</ul>
<p>Q.自己如何实现消息队列<br><br>A:<br></p>
<p>Q.如何保证消息的有序性<br><br>A:<br><br>使用exclusive consumer（可以理解为私有消费者）:如果一个queue设置为exclusive，broker会调选一个consumer，并且将所有的消息都发给这个consumer。如果这个consumer挂了，broker会自动挑选另外一个consumer。<br>脑裂问题我们是不能避免的，可以避免的时在发生脑裂时，2个master能同时去消费queue中的数据。所以我们应该用zookeeper来选主，让主去消费队列，并且队列要设置成exclusive。这样我们就保证队列中的消息是被顺序消费的。</p>
<p>Q.Kafka怎么保证不丢，不重复消费数据<br><br>A:<br></p>
<ul>
<li><p>丢包问题：消息推送服务，每天早上，手机上各终端都会给用户推送消息，这时候流量剧增，可能会出现kafka发送数据过快，导致服务器网卡爆满，或者磁盘处于繁忙状态，可能会出现丢包现象。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先对kafka进行限速， 其次启用重试机制，重试间隔时间设置长一些，最后Kafka设置acks=all，即需要相应的所有处于ISR的分区都确认收到该消息后，才算发送成功。</span><br></pre></td></tr></table></figure>
</li>
<li><p>重发问题：当消费者重新分配partition的时候，可能出现从头开始消费的情况，导致重发问题。当消费者消费的速度很慢的时候，可能在一个session周期内还未完成，导致心跳机制检测报告出问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">至少发一次+去重操作（幂等性）</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="11-4-nginx"><a href="#11-4-nginx" class="headerlink" title="11.4 nginx"></a>11.4 nginx</h2><p>Q.请解释一下什么是Nginx?</p>
<p>Q.请列举Nginx的一些特性?</p>
<p>Q.Nginx的配置文件详解？<br><br>A:<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br></pre></td><td class="code"><pre><span class="line">######Nginx配置文件nginx.conf中文详解#####</span><br><span class="line">#定义Nginx运行的用户和用户组</span><br><span class="line">user www www;</span><br><span class="line"></span><br><span class="line">#nginx进程数，建议设置为等于CPU总核心数。</span><br><span class="line">worker_processes 8;</span><br><span class="line"></span><br><span class="line">#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]</span><br><span class="line">error_log /usr/local/nginx/logs/error.log info;</span><br><span class="line"></span><br><span class="line">#进程pid文件</span><br><span class="line">pid /usr/local/nginx/logs/nginx.pid;</span><br><span class="line"></span><br><span class="line">#指定进程可以打开的最大描述符：数目</span><br><span class="line">#工作模式与连接数上限</span><br><span class="line">#这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。</span><br><span class="line">#现在在linux 2.6内核下开启文件打开数为65535，worker_rlimit_nofile就相应应该填写65535。</span><br><span class="line">#这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。</span><br><span class="line">worker_rlimit_nofile 65535;</span><br><span class="line"></span><br><span class="line">events</span><br><span class="line">&#123;</span><br><span class="line">    #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型</span><br><span class="line">    #是Linux 2.6以上版本内核中的高性能网络I/O模型，linux建议epoll，如果跑在FreeBSD上面，就用kqueue模型。</span><br><span class="line">    #补充说明：</span><br><span class="line">    #与apache相类，nginx针对不同的操作系统，有不同的事件模型</span><br><span class="line">    #A）标准事件模型</span><br><span class="line">    #Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll</span><br><span class="line">    #B）高效事件模型</span><br><span class="line">    #Kqueue：使用于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X.使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。</span><br><span class="line">    #Epoll：使用于Linux内核2.6版本及以后的系统。</span><br><span class="line">    #/dev/poll：使用于Solaris 7 11/99+，HP/UX 11.22+ (eventport)，IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。</span><br><span class="line">    #Eventport：使用于Solaris 10。 为了防止出现内核崩溃的问题， 有必要安装安全补丁。</span><br><span class="line">    use epoll;</span><br><span class="line"></span><br><span class="line">    #单个进程最大连接数（最大连接数=连接数*进程数）</span><br><span class="line">    #根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cpu跑到100%就行。每个进程允许的最多连接数，理论上每台nginx服务器的最大连接数为。</span><br><span class="line">    worker_connections 65535;</span><br><span class="line"></span><br><span class="line">    #keepalive超时时间。</span><br><span class="line">    keepalive_timeout 60;</span><br><span class="line"></span><br><span class="line">    #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。</span><br><span class="line">    #分页大小可以用命令getconf PAGESIZE 取得。</span><br><span class="line">    #[root@web001 ~]# getconf PAGESIZE</span><br><span class="line">    #4096</span><br><span class="line">    #但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。</span><br><span class="line">    client_header_buffer_size 4k;</span><br><span class="line"></span><br><span class="line">    #这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。</span><br><span class="line">    open_file_cache max=65535 inactive=60s;</span><br><span class="line"></span><br><span class="line">    #这个是指多长时间检查一次缓存的有效信息。</span><br><span class="line">    #语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使用字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息.</span><br><span class="line">    open_file_cache_valid 80s;</span><br><span class="line"></span><br><span class="line">    #open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。</span><br><span class="line">    #语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1 使用字段:http, server, location  这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如果使用更大的值,文件描述符在cache中总是打开状态.</span><br><span class="line">    open_file_cache_min_uses 1;</span><br><span class="line"></span><br><span class="line">    #语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件是记录cache错误.</span><br><span class="line">    open_file_cache_errors on;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#设定http服务器，利用它的反向代理功能提供负载均衡支持</span><br><span class="line">http</span><br><span class="line">&#123;</span><br><span class="line">    #文件扩展名与文件类型映射表</span><br><span class="line">    include mime.types;</span><br><span class="line"></span><br><span class="line">    #默认文件类型</span><br><span class="line">    default_type application/octet-stream;</span><br><span class="line"></span><br><span class="line">    #默认编码</span><br><span class="line">    #charset utf-8;</span><br><span class="line"></span><br><span class="line">    #服务器名字的hash表大小</span><br><span class="line">    #保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小.</span><br><span class="line">    server_names_hash_bucket_size 128;</span><br><span class="line"></span><br><span class="line">    #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。</span><br><span class="line">    client_header_buffer_size 32k;</span><br><span class="line"></span><br><span class="line">    #客户请求头缓冲大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。</span><br><span class="line">    large_client_header_buffers 4 64k;</span><br><span class="line"></span><br><span class="line">    #设定通过nginx上传文件的大小</span><br><span class="line">    client_max_body_size 8m;</span><br><span class="line"></span><br><span class="line">    #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。</span><br><span class="line">    #sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。</span><br><span class="line">    sendfile on;</span><br><span class="line"></span><br><span class="line">    #开启目录列表访问，合适下载服务器，默认关闭。</span><br><span class="line">    autoindex on;</span><br><span class="line"></span><br><span class="line">    #此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用</span><br><span class="line">    tcp_nopush on;</span><br><span class="line"></span><br><span class="line">    tcp_nodelay on;</span><br><span class="line"></span><br><span class="line">    #长连接超时时间，单位是秒</span><br><span class="line">    keepalive_timeout 120;</span><br><span class="line"></span><br><span class="line">    #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。</span><br><span class="line">    fastcgi_connect_timeout 300;</span><br><span class="line">    fastcgi_send_timeout 300;</span><br><span class="line">    fastcgi_read_timeout 300;</span><br><span class="line">    fastcgi_buffer_size 64k;</span><br><span class="line">    fastcgi_buffers 4 64k;</span><br><span class="line">    fastcgi_busy_buffers_size 128k;</span><br><span class="line">    fastcgi_temp_file_write_size 128k;</span><br><span class="line"></span><br><span class="line">    #gzip模块设置</span><br><span class="line">    gzip on; #开启gzip压缩输出</span><br><span class="line">    gzip_min_length 1k;    #最小压缩文件大小</span><br><span class="line">    gzip_buffers 4 16k;    #压缩缓冲区</span><br><span class="line">    gzip_http_version 1.0;    #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）</span><br><span class="line">    gzip_comp_level 2;    #压缩等级</span><br><span class="line">    gzip_types text/plain application/x-javascript text/css application/xml;    #压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。</span><br><span class="line">    gzip_vary on;</span><br><span class="line"></span><br><span class="line">    #开启限制IP连接数的时候需要使用</span><br><span class="line">    #limit_zone crawler $binary_remote_addr 10m;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    #负载均衡配置</span><br><span class="line">    upstream piao.jd.com &#123;</span><br><span class="line"></span><br><span class="line">        #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。</span><br><span class="line">        server 192.168.80.121:80 weight=3;</span><br><span class="line">        server 192.168.80.122:80 weight=2;</span><br><span class="line">        server 192.168.80.123:80 weight=3;</span><br><span class="line"></span><br><span class="line">        #nginx的upstream目前支持4种方式的分配</span><br><span class="line">        #1、轮询（默认）</span><br><span class="line">        #每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</span><br><span class="line">        #2、weight</span><br><span class="line">        #指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</span><br><span class="line">        #例如：</span><br><span class="line">        #upstream bakend &#123;</span><br><span class="line">        #    server 192.168.0.14 weight=10;</span><br><span class="line">        #    server 192.168.0.15 weight=10;</span><br><span class="line">        #&#125;</span><br><span class="line">        #2、ip_hash</span><br><span class="line">        #每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</span><br><span class="line">        #例如：</span><br><span class="line">        #upstream bakend &#123;</span><br><span class="line">        #    ip_hash;</span><br><span class="line">        #    server 192.168.0.14:88;</span><br><span class="line">        #    server 192.168.0.15:80;</span><br><span class="line">        #&#125;</span><br><span class="line">        #3、fair（第三方）</span><br><span class="line">        #按后端服务器的响应时间来分配请求，响应时间短的优先分配。</span><br><span class="line">        #upstream backend &#123;</span><br><span class="line">        #    server server1;</span><br><span class="line">        #    server server2;</span><br><span class="line">        #    fair;</span><br><span class="line">        #&#125;</span><br><span class="line">        #4、url_hash（第三方）</span><br><span class="line">        #按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。</span><br><span class="line">        #例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法</span><br><span class="line">        #upstream backend &#123;</span><br><span class="line">        #    server squid1:3128;</span><br><span class="line">        #    server squid2:3128;</span><br><span class="line">        #    hash $request_uri;</span><br><span class="line">        #    hash_method crc32;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        #tips:</span><br><span class="line">        #upstream bakend&#123;#定义负载均衡设备的Ip及设备状态&#125;&#123;</span><br><span class="line">        #    ip_hash;</span><br><span class="line">        #    server 127.0.0.1:9090 down;</span><br><span class="line">        #    server 127.0.0.1:8080 weight=2;</span><br><span class="line">        #    server 127.0.0.1:6060;</span><br><span class="line">        #    server 127.0.0.1:7070 backup;</span><br><span class="line">        #&#125;</span><br><span class="line">        #在需要使用负载均衡的server中增加 proxy_pass http://bakend/;</span><br><span class="line"></span><br><span class="line">        #每个设备的状态设置为:</span><br><span class="line">        #1.down表示单前的server暂时不参与负载</span><br><span class="line">        #2.weight为weight越大，负载的权重就越大。</span><br><span class="line">        #3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误</span><br><span class="line">        #4.fail_timeout:max_fails次失败后，暂停的时间。</span><br><span class="line">        #5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。</span><br><span class="line"></span><br><span class="line">        #nginx支持同时设置多组的负载均衡，用来给不用的server来使用。</span><br><span class="line">        #client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug</span><br><span class="line">        #client_body_temp_path设置记录文件的目录 可以设置最多3层目录</span><br><span class="line">        #location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #虚拟主机的配置</span><br><span class="line">    server</span><br><span class="line">    &#123;</span><br><span class="line">        #监听端口</span><br><span class="line">        listen 80;</span><br><span class="line"></span><br><span class="line">        #域名可以有多个，用空格隔开</span><br><span class="line">        server_name www.jd.com jd.com;</span><br><span class="line">        index index.html index.htm index.php;</span><br><span class="line">        root /data/www/jd;</span><br><span class="line"></span><br><span class="line">        #对******进行负载均衡</span><br><span class="line">        location ~ .*.(php|php5)?$</span><br><span class="line">        &#123;</span><br><span class="line">            fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">            fastcgi_index index.php;</span><br><span class="line">            include fastcgi.conf;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #图片缓存时间设置</span><br><span class="line">        location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$</span><br><span class="line">        &#123;</span><br><span class="line">            expires 10d;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #JS和CSS缓存时间设置</span><br><span class="line">        location ~ .*.(js|css)?$</span><br><span class="line">        &#123;</span><br><span class="line">            expires 1h;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #日志格式设定</span><br><span class="line">        #$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；</span><br><span class="line">        #$remote_user：用来记录客户端用户名称；</span><br><span class="line">        #$time_local： 用来记录访问时间与时区；</span><br><span class="line">        #$request： 用来记录请求的url与http协议；</span><br><span class="line">        #$status： 用来记录请求状态；成功是200，</span><br><span class="line">        #$body_bytes_sent ：记录发送给客户端文件主体内容大小；</span><br><span class="line">        #$http_referer：用来记录从那个页面链接访问过来的；</span><br><span class="line">        #$http_user_agent：记录客户浏览器的相关信息；</span><br><span class="line">        #通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。</span><br><span class="line">        log_format access &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">        &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">        &apos;&quot;$http_user_agent&quot; $http_x_forwarded_for&apos;;</span><br><span class="line"></span><br><span class="line">        #定义本虚拟主机的访问日志</span><br><span class="line">        access_log  /usr/local/nginx/logs/host.access.log  main;</span><br><span class="line">        access_log  /usr/local/nginx/logs/host.access.404.log  log404;</span><br><span class="line"></span><br><span class="line">        #对 &quot;/&quot; 启用反向代理</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://127.0.0.1:88;</span><br><span class="line">            proxy_redirect off;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line"></span><br><span class="line">            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line"></span><br><span class="line">            #以下是一些反向代理的配置，可选。</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line"></span><br><span class="line">            #允许客户端请求的最大单文件字节数</span><br><span class="line">            client_max_body_size 10m;</span><br><span class="line"></span><br><span class="line">            #缓冲区代理缓冲用户端请求的最大字节数，</span><br><span class="line">            #如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。</span><br><span class="line">            #无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误</span><br><span class="line">            client_body_buffer_size 128k;</span><br><span class="line"></span><br><span class="line">            #表示使nginx阻止HTTP应答代码为400或者更高的应答。</span><br><span class="line">            proxy_intercept_errors on;</span><br><span class="line"></span><br><span class="line">            #后端服务器连接的超时时间_发起握手等候响应超时时间</span><br><span class="line">            #nginx跟后端服务器连接超时时间(代理连接超时)</span><br><span class="line">            proxy_connect_timeout 90;</span><br><span class="line"></span><br><span class="line">            #后端服务器数据回传时间(代理发送超时)</span><br><span class="line">            #后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据</span><br><span class="line">            proxy_send_timeout 90;</span><br><span class="line"></span><br><span class="line">            #连接成功后，后端服务器响应时间(代理接收超时)</span><br><span class="line">            #连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）</span><br><span class="line">            proxy_read_timeout 90;</span><br><span class="line"></span><br><span class="line">            #设置代理服务器（nginx）保存用户头信息的缓冲区大小</span><br><span class="line">            #设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小</span><br><span class="line">            proxy_buffer_size 4k;</span><br><span class="line"></span><br><span class="line">            #proxy_buffers缓冲区，网页平均在32k以下的设置</span><br><span class="line">            #设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k</span><br><span class="line">            proxy_buffers 4 32k;</span><br><span class="line"></span><br><span class="line">            #高负荷下缓冲大小（proxy_buffers*2）</span><br><span class="line">            proxy_busy_buffers_size 64k;</span><br><span class="line"></span><br><span class="line">            #设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长</span><br><span class="line">            #设定缓存文件夹大小，大于这个值，将从upstream服务器传</span><br><span class="line">            proxy_temp_file_write_size 64k;</span><br><span class="line">        &#125;</span><br><span class="line">        #设定查看Nginx状态的地址</span><br><span class="line">        location /NginxStatus &#123;</span><br><span class="line">            stub_status on;</span><br><span class="line">            access_log on;</span><br><span class="line">            auth_basic &quot;NginxStatus&quot;;</span><br><span class="line">            auth_basic_user_file confpasswd;</span><br><span class="line">            #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #本地动静分离反向代理配置</span><br><span class="line">        #所有jsp的页面均交由tomcat或resin处理</span><br><span class="line">        location ~ .(jsp|jspx|do)?$ &#123;</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_pass http://127.0.0.1:8080;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #所有静态文件由nginx直接读取不经过tomcat或resin</span><br><span class="line">        location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|</span><br><span class="line">        pdf|xls|mp3|wma)$</span><br><span class="line">        &#123;</span><br><span class="line">            expires 15d;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location ~ .*.(js|css)?$</span><br><span class="line">        &#123;</span><br><span class="line">            expires 1h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">######Nginx配置文件nginx.conf中文详解#####</span><br></pre></td></tr></table></figure>
<h2 id="11-5-Netty"><a href="#11-5-Netty" class="headerlink" title="11.5 Netty"></a>11.5 Netty</h2><h2 id="11-6-Mybatis"><a href="#11-6-Mybatis" class="headerlink" title="11.6 Mybatis"></a>11.6 Mybatis</h2><h1 id="12-测试环境搭建CI和CD"><a href="#12-测试环境搭建CI和CD" class="headerlink" title="12. 测试环境搭建CI和CD"></a>12. 测试环境搭建CI和CD</h1><h2 id="12-1-Jenkins"><a href="#12-1-Jenkins" class="headerlink" title="12.1 Jenkins"></a>12.1 Jenkins</h2><p>Q.Jenkins你都用过哪些插件？<br><br>A：<br></p>
<ul>
<li>push over ssh</li>
<li>gitlab authentication</li>
<li>git</li>
<li>Build periodically</li>
</ul>
<p>Q.Jenkins你是如何做备份的？<br><br>A:<br><br>使用Backup插件备份或者直接备份Jenkins主目录中的所有文件</p>
<p>Q.如果搭建分布式的Jenkins构建环境？<br><br>A:<br></p>
<ol>
<li>打开Configure Global Security配置中的Enable security选项</li>
<li>在 Jenkins 上添加 slave 节点的配置(Jenkins-&gt;Manage Jenkins-&gt;Manage Nodes)</li>
<li>输入 slave 节点的名称，并选择 “Permanent Agent” 类型，点击 OK 后进入详细信息的设置界面</li>
<li>在slave配置页面，点击上图中的 “Launch” 按钮，在浏览器的提示下把一个叫 slave-agent.jnlp 的文件保存到本地。<br>然后以管理员的权限启动命令行， 执行 slave-agent.jnlp 文件，最终会启动一个小程序<br>Q.你们是如果做持续集成的？<br>A：</li>
</ol>
<p>Q.Jenkins输出日志有乱码，怎么解决？<br>A：<br>1、配置用户或者系统变量，修改$HOME/.bash_profile或者/etc/.profile为LANG=en_US.UTF-8<br>    env | grep LANG  可以看一下是否设置成en_US.UTF-8<br>2、重启jenkins<br>    查看jenkins页面-系统信息-环境变量的file.encoding 为 UTF-8</p>
<h2 id="12-2-devops（docker部署）"><a href="#12-2-devops（docker部署）" class="headerlink" title="12.2 devops（docker部署）"></a>12.2 devops（docker部署）</h2><h3 id="镜像相关"><a href="#镜像相关" class="headerlink" title="镜像相关"></a>镜像相关</h3><p>Q.常用的docker命令？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">docker run </span><br><span class="line">docker start</span><br><span class="line">docker ps -a</span><br><span class="line">Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...]  </span><br><span class="line"> </span><br><span class="line">  -d, --detach=false         指定容器运行于前台还是后台，默认为false   </span><br><span class="line">  -i, --interactive=false   打开STDIN，用于控制台交互  </span><br><span class="line">  -t, --tty=false            分配tty设备，该可以支持终端登录，默认为false  </span><br><span class="line">  -u, --user=&quot;&quot;              指定容器的用户  </span><br><span class="line">  -a, --attach=[]            登录容器（必须是以docker run -d启动的容器）</span><br><span class="line">  -w, --workdir=&quot;&quot;           指定容器的工作目录 </span><br><span class="line">  -c, --cpu-shares=0        设置容器CPU权重，在CPU共享场景使用  </span><br><span class="line">  -e, --env=[]               指定环境变量，容器中可以使用该环境变量  </span><br><span class="line">  -m, --memory=&quot;&quot;            指定容器的内存上限  </span><br><span class="line">  -P, --publish-all=false    指定容器暴露的端口  </span><br><span class="line">  -p, --publish=[]           指定容器暴露的端口 </span><br><span class="line">  -h, --hostname=&quot;&quot;          指定容器的主机名  </span><br><span class="line">  -v, --volume=[]            给容器挂载存储卷，挂载到容器的某个目录  </span><br><span class="line">  --volumes-from=[]          给容器挂载其他容器上的卷，挂载到容器的某个目录</span><br><span class="line">  --cap-add=[]               添加权限，权限清单详见：http://linux.die.net/man/7/capabilities  </span><br><span class="line">  --cap-drop=[]              删除权限，权限清单详见：http://linux.die.net/man/7/capabilities  </span><br><span class="line">  --cidfile=&quot;&quot;               运行容器后，在指定文件中写入容器PID值，一种典型的监控系统用法  </span><br><span class="line">  --cpuset=&quot;&quot;                设置容器可以使用哪些CPU，此参数可以用来容器独占CPU  </span><br><span class="line">  --device=[]                添加主机设备给容器，相当于设备直通  </span><br><span class="line">  --dns=[]                   指定容器的dns服务器  </span><br><span class="line">  --dns-search=[]            指定容器的dns搜索域名，写入到容器的/etc/resolv.conf文件  </span><br><span class="line">  --entrypoint=&quot;&quot;            覆盖image的入口点  </span><br><span class="line">  --env-file=[]              指定环境变量文件，文件格式为每行一个环境变量  </span><br><span class="line">  --expose=[]                指定容器暴露的端口，即修改镜像的暴露端口  </span><br><span class="line">  --link=[]                  指定容器间的关联，使用其他容器的IP、env等信息  </span><br><span class="line">  --lxc-conf=[]              指定容器的配置文件，只有在指定--exec-driver=lxc时使用  </span><br><span class="line">  --name=&quot;&quot;                  指定容器名字，后续可以通过名字进行容器管理，links特性需要使用名字  </span><br><span class="line">  --net=&quot;bridge&quot;             容器网络设置:</span><br><span class="line">				                bridge 使用docker daemon指定的网桥     </span><br><span class="line">				                host 	//容器使用主机的网络  </span><br><span class="line">				                container:NAME_or_ID  &gt;//使用其他容器的网路，共享IP和PORT等网络资源  </span><br><span class="line">				                none 容器使用自己的网络（类似--net=bridge），但是不进行配置 </span><br><span class="line">  --privileged=false         指定容器是否为特权容器，特权容器拥有所有的capabilities  </span><br><span class="line">  --restart=&quot;no&quot;             指定容器停止后的重启策略:</span><br><span class="line">				                no：容器退出时不重启  </span><br><span class="line">				                on-failure：容器故障退出（返回值非零）时重启 </span><br><span class="line">				                always：容器退出时总是重启  </span><br><span class="line">  --rm=false                 指定容器停止后自动删除容器(不支持以docker run -d启动的容器)  </span><br><span class="line">  --sig-proxy=true           设置由代理接受并处理信号，但是SIGCHLD、SIGSTOP和SIGKILL不能被代理</span><br></pre></td></tr></table></figure></p>
<p>Q.Dockerfile中Run, CMD和EntryPoint的区别？<br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN命令执行命令并创建新的镜像层，通常用于安装软件包</span><br><span class="line">CMD命令设置容器启动后默认执行的命令及其参数，但CMD设置的命令能够被docker run命令后面的命令行参数替换</span><br><span class="line">ENTRYPOINT配置容器启动时的执行命令（不会被忽略，一定会被执行，即使运行 docker run时指定了其他命令）</span><br></pre></td></tr></table></figure></p>
<p>Q.Docker的docker.sock是什么？有什么作用？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Docker守护进程(Docker daemon)默认监听的Unix域套接字(Unix domain socket)，容器中的进程可以通过它与Docker守护进程进行通信。</span><br><span class="line">![image](https://images2015.cnblogs.com/blog/1105508/201704/1105508-20170417161657571-1124625437.png)</span><br><span class="line">Docker守护进程会监听Unix域套接字：/var/run/docker.sock。这一点可以通过Docker daemon的配置选项看出来(在ubuntu上执行cat /etc/default/docker )：</span><br><span class="line">&gt; -H unix:///var/run/docker.sock</span><br></pre></td></tr></table></figure></p>
<p>Q.docker容器与虚拟机有什么区别？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VM(VMware)在宿主机器、宿主机器操作系统的基础上创建虚拟层、虚拟化的操作系统、虚拟化的仓库，然后再安装应用；</span><br><span class="line">Container(Docker容器)，在宿主机器、宿主机器操作系统上创建Docker引擎，在引擎的基础上再安装应用。</span><br></pre></td></tr></table></figure></p>
<p>Q.使用Docker api创建和启动镜像？<br><br>A:<br></p>
<ol>
<li>创建nginx容器<br>curl命令通过Unix套接字发送{“Image”:”nginx”}到Docker守护进程的/containers/create接口，这个将会基于Nginx镜像创建容器并返回容器的ID。<blockquote>
<p>curl -XPOST –unix-socket /var/run/docker.sock -d ‘{“Image”:”nginx”}’ -H ‘Content-Type: application/json’ <a href="http://localhost/containers/create" target="_blank" rel="noopener">http://localhost/containers/create</a><br>2.启动nginx容器<br>使用返回的容器ID，调用/containers/<id>/start接口，即可启动新创建的容器。<br>curl -XPOST –unix-socket /var/run/docker.sock <a href="http://localhost/containers/fcb6...7d65/start" target="_blank" rel="noopener">http://localhost/containers/fcb6...7d65/start</a></id></p>
</blockquote>
</li>
</ol>
<p>Q.如果批量清理临时镜像文件？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker rmi $(sudo docker images -q -f danging=true)命令</span><br></pre></td></tr></table></figure></p>
<p>Q.如何查看镜像支持的环境变量？<br><br>A：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run IMAGE env</span><br></pre></td></tr></table></figure></p>
<p>Q.本地的镜像文件放在那里？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">于Docker相关的本地资源存放在/var/lib/docker/目录下，其中container目录存放容器信息，graph目录存放镜像信息，aufs目录下存放具体的镜像底层文件。</span><br></pre></td></tr></table></figure></p>
<p>Q.构建Docker镜像应该遵循哪些原则？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">整体远侧上，尽量保持镜像功能的明确和内容的精简，要点包括： </span><br><span class="line"># 尽量选取满足需求但较小的基础系统镜像，建议选择debian:wheezy镜像，仅有86MB大小 </span><br><span class="line"># 清理编译生成文件、安装包的缓存等临时文件 </span><br><span class="line"># 安装各个软件时候要指定准确的版本号，并避免引入不需要的依赖 </span><br><span class="line"># 从安全的角度考虑，应用尽量使用系统的库和依赖 </span><br><span class="line"># 使用Dockerfile创建镜像时候要添加.dockerignore文件或使用干净的工作目录</span><br></pre></td></tr></table></figure></p>
<h3 id="容器相关"><a href="#容器相关" class="headerlink" title="容器相关"></a>容器相关</h3><p>Q. 容器退出后，通过docker ps 命令查看不到，数据会丢失么？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">容器退出后会处于终止（exited）状态，此时可以通过 docker ps -a 查看，其中数据不会丢失，还可以通过docker start 来启动，只有删除容器才会清除数据。</span><br></pre></td></tr></table></figure></p>
<p>Q.如何停止所有正在运行的容器？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker kill $(sudo docker ps -q)</span><br></pre></td></tr></table></figure></p>
<p>Q.如何清理批量后台停止的容器？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用docker rm $（sudo docker ps -a -q）</span><br></pre></td></tr></table></figure></p>
<p>Q.如何临时退出一个正在交互的容器的终端，而不终止它？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">按Ctrl+p，后按Ctrl+q，如果按Ctrl+c会使容器内的应用进程终止，进而会使容器终止</span><br></pre></td></tr></table></figure></p>
<p>Q.很多应用容器都是默认后台运行的，怎么查看它们的输出和日志信息？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用docker logs，后面跟容器的名称或者ID信息</span><br></pre></td></tr></table></figure></p>
<p>Q.使用docker port 命令映射容器的端口时，系统报错Error: No public port ‘80’ published for …，是什么意思？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">创建镜像时Dockerfile要指定正确的EXPOSE的端口，容器启动时指定PublishAllport=true</span><br></pre></td></tr></table></figure></p>
<p>Q.可以在一个容器中同时运行多个应用进程吗？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一般不推荐在同一个容器内运行多个应用进程，如果有类似需求，可以通过额外的进程管理机制，比如supervisord来管理所运行的进程</span><br></pre></td></tr></table></figure></p>
<p>Q.如何控制容器占用系统资源（CPU，内存）的份额？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在使用docker create命令创建容器或使用docker run 创建并运行容器的时候，可以使用-c|–cpu-shares[=0]参数来调整同期使用CPU的权重，使用-m|–memory参数来调整容器使用内存的大小。</span><br></pre></td></tr></table></figure></p>
<h3 id="仓库相关"><a href="#仓库相关" class="headerlink" title="仓库相关"></a>仓库相关</h3><p>Q.仓库（Repository）、注册服务器（Registry）、注册索引（Index）有何关系？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先，仓库是存放一组关联镜像的集合，比如同一个应用的不同版本的镜像，注册服务器是存放实际的镜像的地方，注册索引则负责维护用户的账号，权限，搜索，标签等管理。注册服务器利用注册索引来实现认证等管理。</span><br></pre></td></tr></table></figure></p>
<p>Q.从非官方仓库（如：dl.dockerpool.com）下载镜像的时候，有时候会提示“Error：Invaild registry endpoint <a href="https://dl.docker.com:5000/v1/…”" target="_blank" rel="noopener">https://dl.docker.com:5000/v1/…”</a>?<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Docker 自1.3.0版本往后以来，加强了对镜像安全性的验证，需要手动添加对非官方仓库的信任。</span><br><span class="line">DOCKER_OPTS=”–insecure-registry dl.dockerpool.com:5000”</span><br><span class="line">重启docker服务</span><br></pre></td></tr></table></figure></p>
<h3 id="配置相关"><a href="#配置相关" class="headerlink" title="配置相关"></a>配置相关</h3><p>Q.Docker的配置文件放在那里。如何修改配置？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ubuntu系统下Docker的配置文件是/etc/default/docker，CentOS系统配置文件存放在/etc/sysconfig/docker</span><br></pre></td></tr></table></figure></p>
<p>Q.如何更改Docker的默认存储设置？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Docker的默认存放位置是/var/lib/docker,如果希望将Docker的本地文件存储到其他分区，可以使用Linux软连接的方式来做。</span><br></pre></td></tr></table></figure></p>
<p>Q.Docker与LXC（Linux Container）有何不同？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LXC利用Linux上相关技术实现容器，Docker则在如下的几个方面进行了改进：</span><br><span class="line">1. 移植性：通过抽象容器配置，容器可以实现一个平台移植到另一个平台；</span><br><span class="line">2. 镜像系统：基于AUFS的镜像系统为容器的分发带来了很多的便利，同时共同的镜像层只需要存储一份，实现高效率的存储；</span><br><span class="line">3. 版本管理：类似于GIT的版本管理理念，用户可以更方面的创建、管理镜像文件；</span><br><span class="line">4. 仓库系统：仓库系统大大降低了镜像的分发和管理的成本；</span><br><span class="line">5. 周边工具：各种现有的工具（配置管理、云平台）对Docker的支持，以及基于Docker的Pass、CI等系统，让Docker的应用更加方便和多样化。</span><br></pre></td></tr></table></figure></p>
<p>Q.如何将一台宿主机的docker环境迁移到另外一台宿主机？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">停止Docker服务，将整个docker存储文件复制到另外一台宿主机上，然后调整另外一台宿主机的配置即可</span><br></pre></td></tr></table></figure></p>
<h1 id="13-Spring和Spring-Boot"><a href="#13-Spring和Spring-Boot" class="headerlink" title="13. Spring和Spring Boot"></a>13. Spring和Spring Boot</h1><p>Q.Spring的七大功能模块？<br><br>A:<br><br><img src="http://my.csdn.net/uploads/201205/27/1338117197_8461.gif" alt="image"></p>
<ol>
<li>spring core  核心容器提供Spring框架的基本功能。Spring以bean的方式组织和管理Java应用中的各个组件及其关系。Spring使用BeanFactory来产生和管理Bean，它是工厂模式的实现。BeanFactory使用控制反转(IoC)模式将应用的配置和依赖性规范与实际的应用程序代码分开。BeanFactory使用依赖注入的方式提供给组件依赖。</li>
<li>spring context   Spring上下文是一个配置文件，向Spring框架提供上下文信息。Spring上下文包括企业服务，如JNDI、EJB、电子邮件、国际化、校验和调度功能。</li>
<li>spring aop   通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring框架中。所以，可以很容易地使 Spring框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。</li>
<li>spring dao   DAO模式主要目的是将持久层相关问题与一般的的业务规则和工作流隔离开来。Spring 中的DAO提供一致的方式访问数据库，不管采用何种持久化技术，Spring都提供一直的编程模型。Spring还对不同的持久层技术提供一致的DAO方式的异常层次结构。</li>
<li>spring orm   Spring 与所有的主要的ORM映射框架都集成的很好，包括Hibernate、JDO实现、TopLink和IBatis SQL Map等。Spring为所有的这些框架提供了模板之类的辅助类，达成了一致的编程风格。</li>
<li>spring web   Web上下文模块建立在应用程序上下文模块之上，为基于Web的应用程序提供了上下文。Web层使用Web层框架，可选的，可以是Spring自己的MVC框架，或者提供的Web框架，如Struts、Webwork、tapestry和jsf。</li>
<li>spring webmvc    MVC框架是一个全功能的构建Web应用程序的MVC实现。通过策略接口，MVC框架变成为高度可配置的。Spring的MVC框架提供清晰的角色划分：控制器、验证器、命令对象、表单对象和模型对象、分发器、处理器映射和视图解析器。Spring支持多种视图技术。</li>
</ol>
<p>Q.Spring如何bean顺序加载？<br><br>A:<br></p>
<ul>
<li>使用@Order(1)</li>
<li>实现ordered接口</li>
</ul>
<p>Q.BeanFactory和AppicationContext有什么区别?<br><br>A:<br><br>beanfactory顾名思义，它的核心概念就是bean工厂，用作于bean生命周期的管理，而applicationcontext这个概念就比较丰富了，单看名字（应用上下文）就能看出它包含的范围更广，它继承自bean factory但不仅仅是继承自这一个接口，还有继承了其他的接口，所以它不仅仅有bean factory相关概念，更是一个应用系统的上下文，其设计初衷应该是一个包罗万象的对外暴露的一个综合的API。</p>
<p>Q.Spring bean声明周期详解？<br><br>A:<br><br><a href="https://blog.csdn.net/a327369238/article/details/52193822" target="_blank" rel="noopener">https://blog.csdn.net/a327369238/article/details/52193822</a><br>我们知道一个对象的生命周期：创建（实例化-初始化）-使用-销毁，而在Spring中，Bean对象周期当然遵从这一过程，但Spring提供了许多对外接口，允许开发者对三个过程（实例化、初始化、销毁）的前后做一些操作。<br>　　这里就实例化、初始化区别做一个说明，在Spring Bean中，实例化是为bean对象开辟空间（具体可以理解为构造函数的调用），初始化则是对属性的初始化，说的具体点，这里的属性初始化应该是属性的注入（构造函数也可以有属性的初始化语句，但不属于这一部分），属性注入是通过setter方法注入属性（不管是注解方式还是bean配置property属性方式，其实质都是通过属性的setter方法实现的）。</p>
<p>Bean具体生命周期</p>
<ul>
<li><p>postProcessBeanFactory(ConfigurableListableBeanFactory c)<br>  工厂后处理器（这名字其实只是一个翻译，感觉意义有的时候不一定正确），这个方法其实和Bean生命周期没多少关系，是IoC容器（ApplicationContext）初始化的一部分，详细的可以参考IoC容器初始化一节。具体是容器每一次刷新时（初始化）调用，它是对BeanDefinition进行后处理（BeanDefinition可以参考： Spring IoC容器结构），具体的作用就是可以修改配置文件的各个bean的配置。<br>实现：写一个类，实现BeanFactoryPostProcessor接口，重写该方法，并在Spring配置文件中配置该类的一个bean。</p>
</li>
<li><p>postProcessBeforeInstantiation(Class&lt;？&gt;c,String beanName)<br>  所有bean对象（注1）实例化之前执行，具体点就是执行每个bean类构造函数之前。<br>实现：写一个类，实现InstantiationAwareBeanPostProcessor接口，重写该方法，在Spring配置文件中配置该类的一个bean。返回一个Object，但是实际上你返回一个null即可。<br>bean实例化，调用bean类构造函数</p>
</li>
<li><p>postProcessAfterInstantiation(Object bean,String beanName)<br>  bean类实例化之后，初始化之前调用<br>实现：同第2步，重写该方法，但注意，返回类型这里是boolean，默认是false，你需要更改为true，否则无法注入属性</p>
</li>
<li><p>postProcessPropertyValue(属性名太长，详细查看代码实现)<br>属性注入之前调用<br>实现：同第2步，重写该方法，注意返回类型是PropertyValue，默认返回null，这里需改为返回第一个参数，详见代码章节3。</p>
</li>
<li><p>setBeanName(String beanName)<br>  属性注入后调用，该方法作用是让bean类知道自己所在的Bean的name或id属性。<br>实现：bean类实现BeanNameAware接口，重写该方法。</p>
</li>
<li><p>setBeanFactory(BeanFactory factory)<br>  setBeanName后调用，该方法作用是让bean类知道自己所在的BeanFactory的属性（传入bean所在BeanFactory类型参数）。<br>实现：bean类实现BeanFactoryAware接口，实现该方法。</p>
</li>
<li><p>postProcessBeforeInitialization(Object bean,String beanName)<br>  BeanPostProcessor作用是对bean实例化、初始化做些预处理操作（注2）<br>实现：写一个类，实现BeanPostProcessor接口，注意返回类型为Object，默认返回null，需要返回参数中bean。</p>
</li>
<li><p>postProcessBeforeInitialization(Object bean,Strign beanName)<br>实现：同第2步，实现该方法，注意点同第8步。（注3）</p>
</li>
<li><p>afterPropertiesSet()<br>实现：bean类实现InitializingBean接口，重写该方法。初始化工作，但实现该接口这种方法和Spring耦合，不推荐（这一点DisposableBean一样）。</p>
</li>
<li><p>xml_init()<br>实现：spring bean配置文件中配置bean属性init-method=”xml_init”，这个方法名开发者自己定义，与Spring代码解耦。另外需要注意的是，init-method指定的方法不能有参数，有参数抛异常（这一点destroy-method一样）。</p>
</li>
<li><p>postProcessAfterInitialization(Object bean,Strign beanName)<br>实现：同第8步，注意点相同。</p>
</li>
<li><p>postProcessAfterInitialization(Object bean,Strign beanName)<br>实现：同第2步，注意点同第9步。<br>程序执行，bean工作</p>
</li>
<li><p>destroy()<br>bean销毁前执行<br>实现：bean类实现DisposableBean接口</p>
</li>
<li><p>xml_destroy()<br>实现：spring bean配置文件中配置bean属性destroy-method=”xml_destroy”，这个方法名开发者自己定义。</p>
</li>
</ul>
<p>Q.Spring IOC 如何实现?<br><br>A:<br><br>首先想说说IoC（Inversion of Control，控制反转）。这是spring的核心，贯穿始终。所谓IoC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。</p>
<p>Q.Spring DI依赖注入？<br><br>A:<br><br>IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。</p>
<p>Q.说说 Spring AOP?<br><br>A:<br><br>AOP（Aspect-OrientedProgramming，面向方面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。</p>
<p>Q.Spring AOP 实现原理<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为；那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹。</span><br><span class="line"></span><br><span class="line">使用“横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。Aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。正如Avanade公司的高级方案构架师Adam Magee所说，AOP的核心思想就是“将应用程序中的商业逻辑同对其提供支持的通用服务进行分离。”</span><br></pre></td></tr></table></figure></p>
<p>Q.拦截器(interceper)和过滤器(filter)的区别？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 适用范围不同。 Filter是Servlet规范规定的，只能用于Web程序中。而拦截器既可以用于Web程序，也可以用于Application、Swing中。</span><br><span class="line">2. 规范不同。Filter是在Servlet规范中定义的，是Servlet容器支持的。而拦截器是Spring容器内的，是Spring框架支持的。</span><br><span class="line">3. 使用的资源不同。 同其他代码块一样，拦截器也是一个Spring的组件，归Spring管理，配置在Spring文件中，因此能使用Spring里的任何资源、对象，例如Service、对象、数据源、事务管理，通过IOC注入到拦截器即可；而Filter不能。</span><br><span class="line">4.深度不同。Filter只在Servlet前后起作用。而拦截器能够深入到方法前后、异常抛出前后等，因此拦截器的使用有更大的弹性。所以在Spring框架的程序中，要优先使用拦截器。</span><br></pre></td></tr></table></figure></p>
<p>Q.动态代理（cglib 与 JDK）<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。</span><br><span class="line">而cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。</span><br><span class="line"></span><br><span class="line">1、如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP</span><br><span class="line">2、如果目标对象实现了接口，可以强制使用CGLIB实现AOP</span><br><span class="line">3、如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换</span><br><span class="line"></span><br><span class="line">如何强制使用CGLIB实现AOP？&lt;br&gt;</span><br><span class="line">（1）添加CGLIB库，SPRING_HOME/cglib/*.jar</span><br><span class="line">（2）在spring配置文件中加入</span><br></pre></td></tr></table></figure></p>
<p>Q. JDK动态代理和CGLIB字节码生成的区别？<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）JDK动态代理只能对实现了接口的类生成代理，而不能针对类</span><br><span class="line">（2）CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法</span><br><span class="line">因为是继承，所以该类或方法最好不要声明成final</span><br></pre></td></tr></table></figure></p>
<p>Q.Spring 事务实现方式<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- 编程时事务，依赖于2大类，分别是上篇文章提到的PlatformTransactionManager，与模版类TransactionTemplate（推荐使用）。</span><br><span class="line">1. PlatformTransactionManager，事务管理器配置</span><br><span class="line">2. 使用TransactionTemplate，该类继承了接口DefaultTransactionDefinition，用于简化事务管理，事务管理由模板类定义，主要是通过TransactionCallback回调接口或TransactionCallbackWithoutResult回调接口指定，通过调用模板类的参数类型为TransactionCallback或TransactionCallbackWithoutResult的execute方法来自动享受事务管理。</span><br><span class="line">    TransactionTemplate模板类使用的回调接口</span><br><span class="line">    TransactionCallback：通过实现该接口的“T doInTransaction(TransactionStatus status) ”方法来定义需要事务管理的操作代码；</span><br><span class="line">    TransactionCallbackWithoutResult：继承TransactionCallback接口，提供“void doInTransactionWithoutResult(TransactionStatus status)”便利接口用于方便那些不需要返回值的事务操作代码。</span><br><span class="line"></span><br><span class="line">- 声明式事务</span><br><span class="line">1. Spring的&lt;tx:advice&gt;定义事务通知与AOP相关配置实现</span><br><span class="line">2. 另为一种通过@Transactional实现事务管理实现</span><br><span class="line"></span><br><span class="line">使用@Transactional注意点：&lt;br&gt;</span><br><span class="line">- 如果在接口、实现类或方法上都指定了@Transactional 注解，则优先级顺序为方法&gt;实现类&gt;接口</span><br><span class="line">- 建议只在实现类或实现类的方法上使用@Transactional，而不要在接口上使用，这是因为如果使用JDK代理机制（基于接口的代理）是没问题；而使用使用CGLIB代理（继承）机制时就会遇到问题，因为其使用基于类的代理而不是接口，这是因为接口上的@Transactional注解是“不能继承的”；</span><br></pre></td></tr></table></figure></p>
<p>Q.Spring 事务底层原理<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 划分处理单元-IOC</span><br><span class="line">由于spring解决的问题是对单个数据库进行局部事务处理的，具体的实现首相用spring中的IOC划分了事务处理单元。并且将对事务的各种配置放到了ioc容器中（设置事务管理器，设置事务的传播特性及隔离机制）</span><br><span class="line">2. AOP拦截需要进行事务处理的类</span><br><span class="line">Spring事务处理模块是通过AOP功能来实现声明式事务处理的，具体操作（比如事务实行的配置和读取，事务对象的抽象），用TransactionProxyFactoryBean接口来使用AOP功能，生成proxy代理对象，通过TransactionInterceptor完成对代理方法的拦截，将事务处理的功能编织到拦截的方法中。</span><br><span class="line"></span><br><span class="line">读取ioc容器事务配置属性，转化为spring事务处理需要的内部数据结构（TransactionAttributeSourceAdvisor），转化为TransactionAttribute表示的数据对象。</span><br><span class="line"></span><br><span class="line">3. 对事务处理实现(事务的生成，提交，回滚，挂起)</span><br><span class="line"></span><br><span class="line">spring委托给具体的事务处理器实现。实现了一个抽象和适配。适配的具体事务处理器：DataSource数据源支持、hibernate数据源事务处理支持、JDO数据源事务处理支持，JPA、JTA数据源事务处理支持。这些支持都是通过设计PlatformTransactionManager、AbstractPlatforTransaction一系列事务处理的支持。为常用数据源支持提供了一系列的TransactionManager。</span><br></pre></td></tr></table></figure></p>
<p>Q.如何自定义注解实现功能<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">可以结合spring的AOP，对注解进行拦截，提取注解。</span><br><span class="line">大致流程为:</span><br><span class="line">1. 新建一个注解@MyLog，加在需要注解申明的方法上面</span><br><span class="line">2. 新建一个类MyLogAspect，通过@Aspect注解使该类成为切面类。</span><br><span class="line">3. 通过@Pointcut 指定切入点 ，这里指定的切入点为MyLog注解类型，也就是被@MyLog注解修饰的方法，进入该切入点。</span><br><span class="line">4. MyLogAspect中的方法通过加通知注解（@Before、@Around、@AfterReturning、@AfterThrowing、@After等各种通知）指定要做的业务操作。</span><br></pre></td></tr></table></figure></p>
<p>Q.Spring MVC 运行流程<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1.用户发送请求到DispatchServlet</span><br><span class="line">2.DispatchServlet根据请求路径查询具体的Handler</span><br><span class="line">3.HandlerMapping返回一个HandlerExcutionChain给DispatchServlet</span><br><span class="line">　HandlerExcutionChain：Handler和Interceptor集合</span><br><span class="line">4.DispatchServlet调用HandlerAdapter适配器</span><br><span class="line">5.HandlerAdapter调用具体的Handler处理业务</span><br><span class="line">6.Handler处理结束返回一个具体的ModelAndView给适配器</span><br><span class="line">ModelAndView:model–&gt;数据模型，view–&gt;视图名称</span><br><span class="line">7.适配器将ModelAndView给DispatchServlet</span><br><span class="line">8.DispatchServlet把视图名称给ViewResolver视图解析器</span><br><span class="line">9.ViewResolver返回一个具体的视图给DispatchServlet</span><br><span class="line">10.渲染视图</span><br><span class="line">11.展示给用户</span><br><span class="line"></span><br><span class="line">- 注释：</span><br><span class="line">前端控制器 DispatcherServlet：接收请求、响应结果，相当于转发器，有了DispatcherServlet 就减少了其它组件之间的耦合度。</span><br><span class="line">处理器映射器 HandlerMapping：根据请求的URL来查找Handler</span><br><span class="line">处理器适配器 HandlerAdapter：负责执行Handler</span><br><span class="line">处理器 Handler：处理器，需要程序员开发</span><br><span class="line">视图解析器 ViewResolver：进行视图的解析，根据视图逻辑名将ModelAndView解析成真正的视图（view）</span><br><span class="line">视图View：View是一个接口， 它的实现类支持不同的视图类型，如jsp，freemarker，pdf等等</span><br></pre></td></tr></table></figure></p>
<p>Q.Spring MVC 启动流程<br><br>A：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- Instantiate an instance of each event listener identified by a &lt;listener&gt; element in the deployment descriptor.</span><br><span class="line">- For instantiated listener instances that implement ServletContextListener, call the contextInitialized() method.</span><br><span class="line">- Instantiate an instance of each filter identified by a &lt;filter&gt; element in the deployment descriptor and call each filter instance&apos;s init() method.</span><br><span class="line">- Instantiate an instance of each servlet identified by a &lt;servlet&gt; element that includes a &lt;load-on-startup&gt; element in the order defined by the load-on-startup element values, and call each servlet instance&apos;s init() method.</span><br></pre></td></tr></table></figure></p>
<p>Q.Spring 的单例实现原理<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Spring为实现单例类可继承，使用的是单例注册表的方式（登记式单例)</span><br><span class="line"></span><br><span class="line">登记式单例实际上维护的是一组单例类的实例，将这些实例存储到一个Map(登记簿)中，对于已经登记过的单例，则从工厂直接返回，对于没有登记的，则先登记，而后返回</span><br><span class="line"></span><br><span class="line">1. 使用map实现注册表； </span><br><span class="line">2. 使用protect修饰构造方法； </span><br><span class="line"></span><br><span class="line">有的时候，我们不希望在一开始的时候就把一个类写成单例模式，但是在运用的时候，我们却可以像单例一样使用他.最典型的例子就是spring，他的默认类型就是单例，spring是如何做到把不是单例的类变成单例呢？</span><br><span class="line"></span><br><span class="line">这就用到了登记式单例</span><br><span class="line">其实登记式单例并没有去改变类，他所做的就是起到一个登记的作用，如果没有登记，他就给你登记，并把生成的实例保存起来，下次你要用的时候直接给你。</span><br><span class="line">IOC容器就是做的这个事，你需要就找他去拿，他就可以很方便的实现Bean的管理。</span><br></pre></td></tr></table></figure></p>
<p>登记式单例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Import java.util.HashMap;    </span><br><span class="line">Public <span class="class"><span class="keyword">class</span> <span class="title">RegSingleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//使用一个map来当注册表</span></span><br><span class="line">   Static <span class="keyword">private</span> HashMap registry=<span class="keyword">new</span> HashMap();    </span><br><span class="line">   <span class="comment">//静态块，在类被加载时自动执行，把RegistSingleton自己也纳入容器管理    </span></span><br><span class="line">    Static&#123;    </span><br><span class="line">     RegSingleton rs=<span class="keyword">new</span> RegSingleton();    </span><br><span class="line">     Registry.put(rs.getClass().getName(),rs);    </span><br><span class="line">   &#125;    </span><br><span class="line"><span class="comment">//受保护的默认构造函数，如果为继承关系，则可以调用，克服了单例类不能为继承的缺点    </span></span><br><span class="line"><span class="function">Protected <span class="title">RegSingleton</span><span class="params">()</span></span>&#123;&#125;    </span><br><span class="line"><span class="comment">//静态工厂方法，返回此类的唯一实例    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RegSingleton <span class="title">getInstance</span><span class="params">(String name)</span></span>&#123;    </span><br><span class="line">    <span class="keyword">if</span>(name==<span class="keyword">null</span>)&#123;    </span><br><span class="line">      name=” RegSingleton”;    </span><br><span class="line">    &#125;<span class="keyword">if</span>(registry.get(name)==<span class="keyword">null</span>)&#123;    </span><br><span class="line">      <span class="keyword">try</span>&#123;    </span><br><span class="line">          registry.put(name,Class.forName(name).newInstance());    </span><br><span class="line">       &#125;Catch(Exception ex)&#123;ex.printStackTrace();&#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    Return (RegSingleton)registry.get(name);    </span><br><span class="line">&#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Q.Spring 框架中用到了哪些设计模式<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">代理模式—在AOP和remoting中被用的比较多。</span><br><span class="line">单例模式—在spring配置文件中定义的bean默认为单例模式。</span><br><span class="line">模板方法—用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。</span><br><span class="line">工厂模式—BeanFactory用来创建对象的实例。</span><br><span class="line">适配器–spring aop</span><br><span class="line">装饰器–spring data hashmapper</span><br><span class="line">观察者– spring 时间驱动模型</span><br><span class="line">回调–Spring ResourceLoaderAware回调接口</span><br><span class="line">前端控制器–spring用前端控制器DispatcherServlet对请求进行分发</span><br></pre></td></tr></table></figure></p>
<p>Q.Spring中的@RestController和@Controller有什么区别？<br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Contoller应用于类注解</span><br><span class="line">RestController注解相当于@ResponseBody + @Controller合在一起的作用</span><br><span class="line">1) 如果只是使用@RestController注解Controller，则Controller中的方法无法返回jsp页面，或者html，配置的视图解析器 InternalResourceViewResolver不起作用，返回的内容就是Return 里的内容。</span><br><span class="line"></span><br><span class="line">2) 如果需要返回到指定页面，则需要用 @Controller配合视图解析器InternalResourceViewResolver才行。如果需要返回JSON，XML或自定义mediaType内容到页面，则需要在对应的方法上加上@ResponseBody注解。</span><br></pre></td></tr></table></figure></p>
<p>Q.Spring容器创建对象的三种方式？<br>A:<br></p>
<ol>
<li>调用默认的构造函数（默认）<blockquote>
<p>HelloWorld helloWorld = (HelloWorld)context.getBean(“helloWorld”);  </p>
</blockquote>
</li>
<li><p>使用静态工厂方法</p>
<ul>
<li>指定class属性外 </li>
<li>通过factory-method属性来指定创建bean实例的静态工厂方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id="helloWorld" class="com.jxn.HelloWorldFactory" factory-method="createInstance"&gt;&lt;/bean&gt;  </span><br><span class="line">       注：相当于调用了 HelloWorldFactory.createInstance();  </span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldFactory</span> </span>&#123;  </span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HelloWorld <span class="title">createInstance</span><span class="params">()</span></span>&#123;  </span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> HelloWorld();  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line"></span><br><span class="line">       得到实例对象：HelloWorld helloWorld = (HelloWorld)context.getBean(<span class="string">"helloWorld"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>使用实例工厂方法</p>
<ul>
<li>定义一个工厂类 </li>
<li>通过factory-bean属性指定工厂类，通过factory-method属性指定该工厂类的非静态工厂方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"helloWorldFactory"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.jxn.HelloWorldFactory"</span> /&gt;  </span><br><span class="line">       &lt;bean id=<span class="string">"HelloWorld"</span> factory-bean=<span class="string">"helloWorldFactory"</span> factory-method=<span class="string">"createInstance"</span> /&gt;  </span><br><span class="line">       注：相当于调用了 <span class="keyword">new</span> HelloWorldFactory.createInstance();  </span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldFactory</span> </span>&#123;  </span><br><span class="line">           <span class="function"><span class="keyword">public</span> HelloWorld <span class="title">createInstance</span><span class="params">()</span></span>&#123;  </span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> HelloWorld();  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line"></span><br><span class="line">       得到实例对象：HelloWorld helloWorld = (HelloWorld)context.getBean(<span class="string">"helloWorld"</span>);  </span><br><span class="line"></span><br><span class="line">   注：spring调用工厂方法，在该工厂方法中，由程序员来创建对象。</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>Q.什么是Spring Boot？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。</span><br></pre></td></tr></table></figure></p>
<p>Q.Spring Boot的优点？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 独立运行</span><br><span class="line">2. 简化配置</span><br><span class="line">3. 自动配置</span><br><span class="line">4. 无代码生成和XML配置</span><br><span class="line">5. 应用监控</span><br><span class="line">6. 上手容易</span><br></pre></td></tr></table></figure></p>
<p>Q. Spring Boot的核心配置文件有哪几个？它们的区别是什么？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Spring Boot的核心配置文件是application和bootstrap配置文件</span><br><span class="line">application主要用于SpringBoot项目的自动化配置</span><br><span class="line">bootstrap配置文件有以下场景：</span><br><span class="line"> - 使用Spring Cloud Config配置中心时，需要在boostrap配置文件中添加连接到配置中心的配置属性来加载配置中心的配置信息</span><br><span class="line"> - 固定的不能被覆盖的属性</span><br><span class="line"> - 一些加密/解密的场景</span><br></pre></td></tr></table></figure></p>
<p>Q. Spring boot的配置文件有哪几种格式？他们有什么区别？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Properties</span><br><span class="line">2. yml</span><br><span class="line">.yml格式文件不支持@PropertySource注解</span><br></pre></td></tr></table></figure></p>
<p>Q. Spring Boot的核心注解是哪个？它主要有哪几个注解组成？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：</span><br><span class="line"></span><br><span class="line">@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。</span><br><span class="line">@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude = &#123; DataSourceAutoConfiguration.class &#125;)。</span><br><span class="line">@ComponentScan：Spring组件扫描。</span><br></pre></td></tr></table></figure></p>
<p>Q. 开启SpringBoot特性有哪几种方式？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 继承spring-boot-starter-parent项目</span><br><span class="line">2. 导入spring-boot-dependencies项目依赖</span><br></pre></td></tr></table></figure></p>
<p>Q. SpringBoot需要独立的容器运行吗？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以不需要，内置Tomcat/Jetty等容器</span><br></pre></td></tr></table></figure></p>
<p>Q. 运行SpringBoot有哪几种方式？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 打包用命令或者放到容器中运行</span><br><span class="line">2. 用Maven或者Gradle插件运行</span><br><span class="line">3. 直接执行main方法运行</span><br></pre></td></tr></table></figure></p>
<p>Q. Spring Boot 自动配置原理是什么？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注解 @EnableAutoConfiguration, @Configuration, @ConditionalOnClass 就是自动配置的核心，首先它得是一个配置文件，其次根据类路径下是否有这个类去自动配置。</span><br></pre></td></tr></table></figure></p>
<p>Q. 你如何理解 Spring Boot 中的 Starters？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Starters可以理解为启动器，它包含了一系列可以集成到应用里面的依赖包，你可以一站式集成 Spring 及其他技术，而不需要到处找示例代码和依赖包。如你想使用 Spring JPA 访问数据库，只要加入 spring-boot-starter-data-jpa 启动器依赖就能使用了。</span><br><span class="line"></span><br><span class="line">Starters包含了许多项目中需要用到的依赖，它们能快速持续的运行，都是一系列得到支持的管理传递性依赖。</span><br></pre></td></tr></table></figure></p>
<p>Q.如何在 Spring Boot 启动的时候运行一些特定的代码？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以实现接口 ApplicationRunner 或者 CommandLineRunner，这两个接口实现方式一样，它们都只提供了一个 run 方法，</span><br></pre></td></tr></table></figure></p>
<p>Q.Spring Boot 有哪几种读取配置的方式？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spring Boot 可以通过 @PropertySource,@Value,@Environment, @ConfigurationProperties 来绑定变量，</span><br></pre></td></tr></table></figure></p>
<p>Q.Spring Boot 支持哪些日志框架？推荐和默认的日志框架是哪个？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spring Boot 支持 Java Util Logging, Log4j2, Logback 作为日志框架，如果你使用 Starters 启动器，Spring Boot 将使用 Logback 作为默认日志框架，</span><br></pre></td></tr></table></figure></p>
<p>Q.Spring boot热部署有哪几种方式?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. Spring Loaded</span><br><span class="line">2. Spring-boot-devtools</span><br></pre></td></tr></table></figure></p>
<p>Q.你如何理解 Spring Boot 配置加载顺序？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在 Spring Boot 里面，可以使用以下几种方式来加载配置。</span><br><span class="line"></span><br><span class="line">1）properties文件；</span><br><span class="line">2）YAML文件；</span><br><span class="line">3）系统环境变量；</span><br><span class="line">4）命令行参数；</span><br></pre></td></tr></table></figure></p>
<p>Q.Spring Boot 如何定义多套不同环境配置？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">运行时指定具体的配置文件,例如：</span><br><span class="line">1. application.properties</span><br><span class="line">2. application-dev.properties</span><br><span class="line">3. application-test.properties</span><br></pre></td></tr></table></figure></p>
<p>Q.Spring Boot 可以兼容老 Spring 项目吗，如何做？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以兼容，使用@ImportResource注解导入老 Spring 项目配置文件。</span><br></pre></td></tr></table></figure></p>
<p>Q.保护 Spring Boot 应用有哪些方法？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 在生产中使用HTTPS</span><br><span class="line">2. 使用Snyk检查你的依赖关系</span><br><span class="line">3. 升级到最新版本</span><br><span class="line">4. 启用CSRF保护</span><br><span class="line">5. 使用内容安全策略防止XSS攻击</span><br></pre></td></tr></table></figure></p>
<p>Q.Spring Boot 2.X 有什么新特性？与 1.X 有什么区别？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 配置变更</span><br><span class="line">2. JDK 版本升级</span><br><span class="line">3. 第三方类库升级</span><br><span class="line">4. 响应式 Spring 编程支持</span><br><span class="line">5. HTTP/2 支持</span><br><span class="line">6. 配置属性绑定</span><br></pre></td></tr></table></figure></p>
<h1 id="14-微服务篇"><a href="#14-微服务篇" class="headerlink" title="14. 微服务篇"></a>14. 微服务篇</h1><p>Q. 前后端分离是如何做的？<br><br>A:<br><br>前端的工作：实现整一个前端页面以及交互逻辑，以及利用ajax与nodejs服务器（中间层)交互<br>后端的工作：提供API接口，利用redis来管理session,与数据库交互</p>
<p>Q. 微服务有哪些框架?<br><br>A:<br><br>Spring Cloud 和dubbo</p>
<p>Q. 如何解决跨域问题？<br><br>A:<br><br>同源指的是协议，端口，域名全部相同。</p>
<p>同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。<br>解决跨域方法：</p>
<ol>
<li>通过jsonp跨域</li>
<li>通过修改document.domain来跨子域</li>
<li>使用window.name来进行跨域</li>
</ol>
<p>Q. 你怎么理解 RPC 框架<br><br>A:<br><br>RPC（Remote Promote Call） 一种进程间通信方式。允许像调用本地服务一样调用远程服务。<br>RPC框架的主要目标就是让远程服务调用更简单、透明。RPC框架负责屏蔽底层的传输方式（TCP或者UDP）、序列化方式（XML/JSON/二进制）和通信细节。开发人员在使用的时候只需要了解谁在什么位置提供了什么样的远程服务接口即可，并不需要关心底层通信细节和调用过程。</p>
<p>Q. 说说RPC的实现原理？<br><br>A:<br><br><img src="https://images2015.cnblogs.com/blog/522490/201510/522490-20151003120412386-363334260.png" alt="avatar"></p>
<p>1）服务消费方（client）调用以本地调用方式调用服务；<br>2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；<br>3）client stub找到服务地址，并将消息发送到服务端；<br>4）server stub收到消息后进行解码；<br>5）server stub根据解码结果调用本地的服务；<br>6）本地服务执行并将结果返回给server stub；<br>7）server stub将返回结果打包成消息并发送至消费方；<br>8）client stub接收到消息，并进行解码；<br>9）服务消费方得到最终结果。<br>　　RPC的目标就是要2~8这些步骤都封装起来，让用户对这些细节透明。</p>
<p>Q. 说说 Dubbo 的实现原理?<br><br>A:<br><br>Dubbo是一种分布式服务框架。 Webservice也是一种服务框架，但是webservice并不是分布式的服务框架，他需要结合F5实现负载均衡。因此，dubbo除了可以提供服务之外，还可以实现软负载均衡。它还提供了两个功能Monitor 监控中心和调用中心。这两个是可选的，需要单独配置。</p>
<p>Dubbo的计数架构图如下：<br><img src="https://img-blog.csdn.net/20140217213519328?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcGF1bF93ZWkyMDA4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="avatar"></p>
<p>我们解释以下这个架构图：<br>Consumer服务消费者，Provider服务提供者。Container服务容器。消费当然是invoke提供者了，invoke这条实线按照图上的说明当然同步的意思了，多说一句，在实际调用过程中，Provider的位置对于Consumer来说是透明的，上一次调用服务的位置（IP地址）和下一次调用服务的位置，是不确定的。这个地方就是实现了软负载。</p>
<p>服务提供者先启动start，然后注册register服务。</p>
<p>消费订阅subscribe服务，如果没有订阅到自己想获得的服务，它会不断的尝试订阅。新的服务注册到注册中心以后，注册中心会将这些服务通过notify到消费者。</p>
<p>Monitor这是一个监控，图中虚线表明Consumer 和Provider通过异步的方式发送消息至Monitor，Consumer和Provider会将信息存放在本地磁盘，平均1min会发送一次信息。Monitor在整个架构中是可选的（图中的虚线并不是可选的意思），Monitor功能需要单独配置，不配置或者配置以后，Monitor挂掉并不会影响服务的调用。<br><img src="https://img-blog.csdn.net/20140217213535734?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcGF1bF93ZWkyMDA4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="avatar"></p>
<p>Q. 你怎么理解 RESTful?<br><br>A:<br><br>一种软件架构风格，设计风格而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p>
<p>Q.说说如何设计一个良好的 API?<br><br>A:<br></p>
<ol>
<li>简明易懂</li>
<li>api表面积尽可能小</li>
<li>减少模板</li>
<li>返回有意义的错误状态</li>
<li>异常应该有真正的含义</li>
<li>建立文档</li>
</ol>
<p>Q.如何理解RESTful API的幂等性?<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP幂等方法，是指无论调用多少次都不会有不同结果的 HTTP 方法。不管你调用一次，还是调用一百次，一千次，结果都是相同的。</span><br></pre></td></tr></table></figure></p>
<p>Q.如何保证接口的幂等性?<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">为了解决以上问题，就需要保证接口的幂等性，接口的幂等性实际上就是接口可重复调用，在调用方多次调用的情况下，接口最终得到的结果是一致的。</span><br><span class="line">- 全局唯一ID</span><br><span class="line">- 去重表</span><br><span class="line">- 多版本控制</span><br><span class="line">- 状态机控制</span><br></pre></td></tr></table></figure></p>
<p>Q.说说 CAP 定理、 BASE 理论?<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CAP原则又称CAP定理，指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。</span><br><span class="line">分布式系统的CAP理论：理论首先把分布式系统中的三个特性进行了如下归纳：</span><br><span class="line">    - 一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</span><br><span class="line">    - 可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</span><br><span class="line">    - 分区容忍性（P）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</span><br><span class="line"></span><br><span class="line">BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写，BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的结论，是基于CAP定理逐步演化而来的，其核心思想是即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。</span><br><span class="line">    - 基本可用:</span><br><span class="line">        基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性——但请注意，这绝不等价于系统不可用，以下两个就是“基本可用”的典型例子。</span><br><span class="line">        1. 响应时间上的损失：正常情况下，一个在线搜索引擎需要0.5秒内返回给用户相应的查询结果，但由于出现异常（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了1~2秒。</span><br><span class="line">        2. 功能上的损失：正常情况下，在一个电子商务网站上进行购物，消费者几乎能够顺利地完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。</span><br><span class="line">    - 最终一致性:最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性</span><br><span class="line">    - 弱状态：是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性</span><br></pre></td></tr></table></figure></p>
<p>Q.怎么考虑数据一致性问题？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 二阶段提交协议</span><br><span class="line">2. 可靠消息最后一致性</span><br></pre></td></tr></table></figure></p>
<p>Q.说说最终一致性的实现方案<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">可靠消息最终一致性方案本质上是 利用 MQ 组件实现的二阶段提交。此方案涉及 3 个模块：</span><br><span class="line">1. 上游应用，执行业务并发送 MQ 消息。</span><br><span class="line">2. 可靠消息服务和 MQ 消息组件，协调上下游消息的传递，并确保上下游数据的一致性。</span><br><span class="line">3. 下游应用，监听 MQ 的消息并执行自身业务。</span><br></pre></td></tr></table></figure></p>
<p>Q.你怎么看待微服务<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间相互协调、互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务和服务之间采用轻量级的通信机制相互沟通（通常是基于HTTP的Restful API).每个服务都围绕着具体的业务进行构建，并且能够被独立的部署到生产环境、类生产环境等。另外，应尽量避免统一的、集中的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构</span><br><span class="line"></span><br><span class="line">优点：</span><br><span class="line">1:提升开发交流，每个服务足够内聚，足够小，代码容易理解；</span><br><span class="line">2:服务独立测试、部署、升级、发布；</span><br><span class="line">3:按需定制的DFX，资源利用率，每个服务可以各自进行x扩展和z扩展，而且，每个服务可以根据自己的需要部署到合适的硬件服务器上；每个服务按</span><br><span class="line">4:需要选择HA的模式，选择接受服务的实例个数；</span><br><span class="line">5:容易扩大开发团队，可以针对每个服务（service）组件开发团队；</span><br><span class="line">6:提高容错性（fault isolation），一个服务的内存泄露并不会让整个系统瘫痪；</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">没有银弹，微服务提高了系统的复杂度；开发人员要处理分布式系统的复杂性；服务之间的分布式通信问题；服务的注册与发现问题；服务之间的分布式事务问题；数据隔离再来的报表处理问题；服务之间的分布式一致性问题；服务管理的复杂性，服务的编排；不同服务实例的管理。</span><br></pre></td></tr></table></figure></p>
<p>Q.微服务与 SOA 的区别<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- 微服务剔除SOA中复杂的ESB企业服务总线，所有的业务智能逻辑在服务内部处理，使用Http（Rest API）进行轻量化通讯</span><br><span class="line">- SOA强调按水平架构划分为：前、后端、数据库、测试等，微服务强调按垂直架构划分，按业务能力划分，每个服务完成一种特定的功能，服务即产品</span><br><span class="line">- SOA将组件以library的方式和应用部署在同一个进程中运行，微服务则是各个服务独立运行。</span><br><span class="line">- 传统应用倾向于使用统一的技术平台来解决所有问题，微服务可以针对不同业务特征选择不同技术平台，去中心统一化，发挥各种技术平台的特长。</span><br><span class="line">- SOA架构强调的是异构系统之间的通信和解耦合；（一种粗粒度、松耦合的服务架构）</span><br><span class="line">- 微服务架构强调的是系统按业务边界做细粒度的拆分和部署。</span><br></pre></td></tr></table></figure></p>
<p>Q.如何拆分服务<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">服务拆分是对系统而言，是通过某个维度（一般是系统高可用）去做到服务责任单一，比方说，商城系统有详情页，订单等模块，对于大型商城，详情页的读多写少，这个时候可以做成一个微服务。原则是拆分粒度应该保证微服务具有业务的独立性和完整性，服务的拆分围绕业务模块进行拆分</span><br></pre></td></tr></table></figure></p>
<p>Q.微服务如何进行数据库管理？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">保持每个微服务的持久化数据是私有的并且只能通过该服务的API访问</span><br><span class="line">保持服务持久化数据的私有有一些不同的方式:</span><br><span class="line">- Private-tables-per-service —— 每个服务拥有一个必须只能被该服务访问的表集</span><br><span class="line">- Schema-per-service —— 每个服务都有一个私有的数据库schema</span><br><span class="line">- Database-server-per-service —— 每个服务都有自己的数据库服务器</span><br></pre></td></tr></table></figure></p>
<p>Q.如何应对微服务的链式调用异常?<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一般情况下，每个微服务之间是独立的，如果某个服务宕机，只会影响到当前服务，而不会对整个业务系统产生影响。但是，服务端可能会在多个微服务之间产生一条链式调用，并把整合后的信息返回给客户端。在调用过程中，如果某个服务宕机或者网络不稳定可能造成整个请求失败。因此，为了应对微服务的链式调用异常，我们需要在设计微服务调用链时不宜过长，以免客户端长时间等待，以及中间环节出现错误造成整个请求失败。此外，可以</span><br><span class="line">考虑使用消息队列进行业务解耦，并且使用缓存避免微服务的链式调用从而提高该接口的可用性。</span><br></pre></td></tr></table></figure></p>
<p>Q.对于快速追踪与定位问题<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在微服务复杂的链式调用中，我们会比单体架构更难以追踪与定位问题。因此，在设计的时候，需要特别注意。一种比较好的方案是，当 RESTful API 接口出现非 2xx 的 HTTP 错误码响应时，采用全局的异常结构响应信息。其中，code 字段用来表示某类错误的错误码，在微服务中应该加上“&#123;biz_name&#125;/”前缀以便于定位错误发生在哪个业务系统上。我们来看一个案例，假设“用户中心”某个接口没有权限获取资源而出现错误，我们的业务系统可以响应“UC/AUTH_DENIED”，并且通过自动生成的 UUID 值的 request_id 字段，在日志系统中获得错误的详细信息。</span><br><span class="line">此外，我们需要在记录日志时，标记出错误来源以及错误详情便于更好地分析与定位问题。</span><br></pre></td></tr></table></figure></p>
<p>Q.微服务的安全<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OAuth 是一个关于授权的开放网络标准，它允许第三方网站在用户授权的前提下访问用户在服务商那里存储的各种信息。实际上，OAuth 2.0 允许用户提供一个令牌给第三方网站，一个令牌对应一个特定的第三方网站，同时该令牌只能在特定的时间内访问特定的资源。用户在客户端使用用户名和密码在用户中心获得授权，然后客户端在访问应用是附上 Token 令牌。此时，应用接收到客户端的 Token 令牌到用户中心进行认证。</span><br></pre></td></tr></table></figure></p>
<h2 id="dubbo"><a href="#dubbo" class="headerlink" title="dubbo"></a>dubbo</h2><p>Q.Dubbo是什么？<br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Dubbo是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。简单的说，dubbo就是个服务框架，如果没有分布式的需求，其实是不需要用的，只有在分布式的时候，才有dubbo这样的分布式服务框架的需求，并且本质上是个服务调用的东东，说白了就是个远程服务调用的分布式框架（告别Web Service模式中的WSdl，以服务者与消费者的方式在dubbo上注册）</span><br><span class="line">其核心部分包含:</span><br><span class="line">1. 远程通讯: 提供对多种基于长连接的NIO框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。</span><br><span class="line">2. 集群容错: 提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。</span><br><span class="line">3. 自动发现: 基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。</span><br></pre></td></tr></table></figure></p>
<p>Q.为什么要用Dubbo？<br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。      </span><br><span class="line">2.软负载均衡及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点。</span><br><span class="line">3. 服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。</span><br></pre></td></tr></table></figure></p>
<p>Q.Dubbo 和 Spring Cloud 有什么区别？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dubbo底层是使用Netty这样的NIO框架，是基于TCP协议传输的，配合以Hession序列化完成RPC通信。而SpringCloud是基于Http协议+rest接口调用远程过程的通信，相对来说，Http请求会有更大的报文，占的带宽也会更多。但是REST相比RPC更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这在强调快速演化的微服务环境下，显得更为合适，至于注重通信速度还是方便灵活性，具体情况具体考虑。</span><br></pre></td></tr></table></figure></p>
<p>Q.dubbo都支持什么协议，推荐用哪种?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dubbo支持dubbo、rmi、hessian、http、webservice、thrift、redis等多种协议，但是Dubbo官网是推荐我们使用Dubbo协议的。</span><br></pre></td></tr></table></figure></p>
<p>Q.Dubbo为什么不需要启动Tomcat容器？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dubbo服务容器是一个standalone的启动程序，因为后台服务不需要Tomcat或JBoss等Web容器的功能，如果硬要用Web容器去加载服务提供方，增加复杂性，也浪费资源。 服务容器只是一个简单的Main方法，并加载一个简单的Spring容器，用于暴露服务。 服务容器的加载内容可以扩展，内置了spring, jetty, log4j等加载，可通过Container扩展点进行扩展</span><br></pre></td></tr></table></figure></p>
<p>Q.Dubbo内置了哪几种服务容器?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. SpringContainer</span><br><span class="line">2. Log4jContainer</span><br><span class="line">3. JettyContainer</span><br><span class="line">4. JavaConfigContainer</span><br><span class="line">5. LogbackContainer</span><br></pre></td></tr></table></figure></p>
<p>Q.Dubbo里面有哪几种节点角色?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Provider: 暴露服务的服务提供方。</span><br><span class="line">Consumer: 调用远程服务的服务消费方。</span><br><span class="line">Registry: 服务注册与发现的注册中心。</span><br><span class="line">Monitor: 统计服务的调用次调和调用时间的监控中心。</span><br><span class="line">Container: 服务运行容器。</span><br></pre></td></tr></table></figure></p>
<p>Q.Dubbo默认使用什么注册中心，还有别的选择吗?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">推荐使用zookeeper注册中心，还有redis等不推荐。</span><br></pre></td></tr></table></figure></p>
<p>Q.Dubbo有哪几种配置方式？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. XML 配置文件方式</span><br><span class="line">2. properties 配置文件方式</span><br><span class="line">3. annotation 配置方式</span><br><span class="line">4. API 配置方式</span><br></pre></td></tr></table></figure></p>
<p>Q.Dubbo 核心的配置有哪些？</p>
<ol>
<li>启动时检查<br> &lt;dubbo:reference interface=”com.foo.BarService” check=”false” /&gt;</li>
<li>集群容错<ul>
<li>Failover Cluster 失败自动切换，重试两次 &lt;dubbo:service retries=”2” /&gt;</li>
<li>Failfast Cluster 快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</li>
<li>Failsafe Cluster 失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</li>
<li>Failback Cluster 失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</li>
<li>Forking Cluster 并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=”2” 来设置最大并行数。</li>
<li>Broadcast Cluster 广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。</li>
</ul>
</li>
<li>负载均衡<ul>
<li>Random LoadBalance <ul>
<li>随机，按权重设置随机概率（默认）。</li>
</ul>
</li>
<li>RoundRobin LoadBalance <ul>
<li>轮询，按公约后的权重设置轮询比率。</li>
<li>存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</li>
</ul>
</li>
<li>LeastActive LoadBalance<ul>
<li>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。</li>
<li>使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</li>
</ul>
</li>
<li>ConsistentHash LoadBalance<ul>
<li>一致性 Hash，相同参数的请求总是发到同一提供者。</li>
<li>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</li>
<li>缺省只对第一个参数 Hash，如果要修改，请配置 &lt;dubbo:parameter key=”hash.arguments” value=”0,1” /&gt;</li>
<li>缺省用 160 份虚拟节点，如果要修改，请配置 &lt;dubbo:parameter key=”hash.nodes” value=”320” /&gt;</li>
</ul>
</li>
</ul>
</li>
<li><p>线程模型<br> 需要通过不同的派发策略和不同的线程池配置的组合来应对不同的场景:</p>
<blockquote>
<p>&lt;dubbo:protocol name=”dubbo” dispatcher=”all” threadpool=”fixed” threads=”100” /&gt;</p>
<ul>
<li>Dispatcher<ul>
<li>all 所有消息都派发到线程池，包括请求，响应，连接事件，断开事件，心跳等。</li>
<li>direct 所有消息都不派发到线程池，全部在 IO 线程上直接执行。</li>
<li>message 只有请求响应消息派发到线程池，其它连接断开事件，心跳等消息，直接在 IO 线程上执行。</li>
<li>execution 只请求消息派发到线程池，不含响应，响应和其它连接断开事件，心跳等消息，直接在 IO 线程上执行。</li>
<li>connection 在 IO 线程上，将连接断开事件放入队列，有序逐个执行，其它消息派发到线程池。</li>
</ul>
</li>
<li>ThreadPool</li>
</ul>
</blockquote>
<pre><code>- fixed 固定大小线程池，启动时建立线程，不关闭，一直持有。(缺省)
- cached 缓存线程池，空闲一分钟自动删除，需要时重建。
- limited 可伸缩线程池，但池中的线程数只会增长不会收缩。只增长不收缩的目的是为了避免收缩时突然来了大流量引起的性能问题。
- eager 优先创建Worker线程池。在任务数量大于corePoolSize但是小于maximumPoolSize时，优先创建Worker来处理任务。当任务数量大于maximumPoolSize时，将任务放入阻塞队列中。阻塞队列充满时抛出RejectedExecutionException。(相比于cached:cached在任务数量超过maximumPoolSize时直接抛出异常而不是将任务放入阻塞队列)
</code></pre></li>
<li>多协议<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"world"</span>  /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">"registry"</span> <span class="attr">address</span>=<span class="string">"10.20.141.150:9090"</span> <span class="attr">username</span>=<span class="string">"admin"</span> <span class="attr">password</span>=<span class="string">"hello1234"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 多协议配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20880"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"rmi"</span> <span class="attr">port</span>=<span class="string">"1099"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用dubbo协议暴露服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.hello.api.HelloService"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span> <span class="attr">ref</span>=<span class="string">"helloService"</span> <span class="attr">protocol</span>=<span class="string">"dubbo"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用rmi协议暴露服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.hello.api.DemoService"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span> <span class="attr">ref</span>=<span class="string">"demoService"</span> <span class="attr">protocol</span>=<span class="string">"rmi"</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>dubbo<br>  连接个数：单连接<br>  连接方式：长连接<br>  传输协议：TCP<br>  传输方式：NIO 异步传输<br>  序列化：Hessian 二进制序列化<br>  适用范围：传入传出参数数据包较小（建议小于100K），消费者比提供者个数多，单一消费者无法压满提供者，尽量不要用 dubbo 协议传输大文件或超大字符串。<br>  适用场景：常规远程服务方法调用</li>
<li>rmi<br>  连接个数：多连接<br>  连接方式：短连接<br>  传输协议：TCP<br>  传输方式：同步传输<br>  序列化：Java 标准二进制序列化<br>  适用范围：传入传出参数数据包大小混合，消费者与提供者个数差不多，可传文件。<br>  适用场景：常规远程服务方法调用，与原生RMI服务互操作</li>
<li>hessian<br>  连接个数：多连接<br>  连接方式：短连接<br>  传输协议：HTTP<br>  传输方式：同步传输<br>  序列化：Hessian二进制序列化<br>  适用范围：传入传出参数数据包较大，提供者比消费者个数多，提供者压力较大，可传文件。<br>  适用场景：页面传输，文件传输，或与原生hessian服务互操作</li>
</ul>
<ol start="6">
<li>多版本<br> 老版本服务：<blockquote>
<p>&lt;dubbo:service interface=”com.foo.BarService” version=”1.0.0” /&gt;<br> 新版本服务：<br>&lt;dubbo:service interface=”com.foo.BarService” version=”2.0.0” /&gt;</p>
</blockquote>
</li>
<li>服务分组<br> 当一个接口有多种实现时，可以用 group 区分。</li>
<li>隐式传参<br> 有些参数需要RPC带着传递，但是又不想写入到业务代码里。比如实现dubbo调用链。可是使用dubbo的隐式传参，可以通过 RpcContext 上的 setAttachment 和 getAttachment 在服务消费方和提供方之间进行参数的隐式传递。</li>
</ol>
<p>Q.在 Provider 上可以配置的 Consumer 端的属性有哪些?</p>
<ul>
<li>作服务的提供者，比服务使用方更清楚服务性能参数，如调用的超时时间，合理的重试次数，等等</li>
<li>在Provider配置后，Consumer不配置则会使用Provider的配置值，即Provider配置可以作为Consumer的缺省值。否则，Consumer会使用Consumer端的全局设置，这对于Provider不可控的，并且往往是不合理的</li>
<li>配置的覆盖规则：1) 方法级配置别优于接口级别，即小Scope优先 2) Consumer端配置 优于 Provider配置 优于 全局配置，最后是Dubbo Hard Code的配置值</li>
</ul>
<p>Q.Dubbo启动时如果依赖的服务不可用会怎样？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dubbo缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止Spring初始化完成，</span><br></pre></td></tr></table></figure></p>
<p>Q.Dubbo推荐使用什么序列化框架，你知道的还有哪些？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hessian,Kryo,Java</span><br></pre></td></tr></table></figure></p>
<p>Q.注册了多个同一样的服务，如果测试指定的某一个服务呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以配置环境点对点直连，绕过注册中心，将以服务接口为单位，忽略注册中心的提供者列表</span><br></pre></td></tr></table></figure></p>
<p>Q.当一个服务接口有多种实现时怎么做？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当一个接口有多种实现时，可以用 group 属性来分组，服务提供方和消费方都指定同一个 group 即可。</span><br></pre></td></tr></table></figure></p>
<p>Q.Dubbo可以对结果进行缓存吗？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以，Dubbo 提供了声明式缓存，用于加速热门数据的访问速度，以减少用户加缓存的工作量</span><br></pre></td></tr></table></figure></p>
<p>Q.Dubbo服务之间的调用是阻塞的吗？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">默认是同步等待结果阻塞的，支持异步调用。</span><br><span class="line"></span><br><span class="line">Dubbo 是基于 NIO 的非阻塞实现并行调用，客户端不需要启动多线程即可完成并行调用多个远程服务，相对多线程开销较小，异步调用会返回一个 Future 对象。</span><br></pre></td></tr></table></figure></p>
<p>Q.Dubbo支持分布式事务吗？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">Q.Dubbo telnet 命令能做什么？</span><br></pre></td></tr></table></figure></p>
<p>dubbo 通过 telnet 命令来进行服务治理，具体使用看这篇文章《dubbo服务调试管理实用命令》。</p>
<p>telnet localhost 8090<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Q.Dubbo支持服务降级吗？</span><br></pre></td></tr></table></figure></p>
<p>Dubbo 2.2.0 以上版本支持。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Q.Dubbo如何优雅停机？</span><br></pre></td></tr></table></figure></p>
<p>Dubbo 是通过 JDK 的 ShutdownHook 来完成优雅停机的，所以如果使用 kill -9 PID 等强制关闭指令，是不会执行优雅停机的，只有通过 kill PID 时，才会执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Q.服务提供者能实现失效踢出是什么原理？</span><br></pre></td></tr></table></figure></p>
<p>服务失效踢出基于 Zookeeper 的临时节点原理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Q.如何解决服务调用链过长的问题？</span><br></pre></td></tr></table></figure></p>
<p>Dubbo 可以使用 Pinpoint 和 Apache Skywalking(Incubator) 实现分布式服务追踪<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Q.服务读写推荐的容错策略是怎样的？</span><br></pre></td></tr></table></figure></p>
<p>读操作建议使用 Failover 失败自动切换，默认重试两次其他服务器。</p>
<p>写操作建议使用 Failfast 快速失败，发一次调用失败就立即报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Q.Dubbo必须依赖的包有哪些？</span><br></pre></td></tr></table></figure></p>
<p>Dubbo 必须依赖 JDK<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Q.Dubbo的管理控制台能做什么？</span><br></pre></td></tr></table></figure></p>
<p>管理控制台主要包含：路由规则，动态配置，服务降级，访问控制，权重调整，负载均衡，等管理功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Q.说说 Dubbo 服务暴露的过程?</span><br></pre></td></tr></table></figure></p>
<p>Dubbo 会在 Spring 实例化完 bean 之后，在刷新容器最后一步发布 ContextRefreshEvent 事件的时候，通知实现了 ApplicationListener 的 ServiceBean 类进行回调 onApplicationEvent 事件方法，Dubbo 会在这个方法中调用 ServiceBean 父类 ServiceConfig 的 export 方法，而该方法真正实现了服务的（异步或者非异步）发布。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 15. 算法</span><br><span class="line"></span><br><span class="line">## 常考编程</span><br><span class="line"></span><br><span class="line">Q.a与b的值进行互换？</span><br></pre></td></tr></table></figure></p>
<pre><code>//方法一：
int tmp = 0;
tmp = b;
b = a;
a = tmp;
//方法二：
//a = a+b;
//b = a-b;
//a = a -b;
//方法三：
//a ^= b ^= a ^= b;
//方法四：
//a = a+b-(b=a);
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Q.数字从1，2，3，4........无穷，有序，且查找的数字n存在 返回不超过n的最大的2的整数次幂？</span><br></pre></td></tr></table></figure>
<p>static final int tableSizeFor(int cap) {<br>    int n = cap - 1;<br>    n |= n &gt;&gt;&gt; 1;<br>    n |= n &gt;&gt;&gt; 2;<br>    n |= n &gt;&gt;&gt; 4;<br>    n |= n &gt;&gt;&gt; 8;<br>    n |= n &gt;&gt;&gt; 16;<br>    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Q.Java中如何实现单例？单例的几种写法？</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">// 饿汉</span><br><span class="line">// ThreadSafe</span><br><span class="line">public class Singleton2 &#123;</span><br><span class="line">  private static final Singleton2 singleton = new Singleton2();</span><br><span class="line">  private Singleton2() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  public static Singleton2 getInstance() &#123;</span><br><span class="line">    return singleton;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双重锁验证</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态内部类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"singleton create"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InstanceHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Q.斐波那契数？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *斐波那契数列递归</span><br><span class="line"> * F（n）=F(n-1)+F(n-2)（n≥2，n∈N*）</span><br><span class="line"> * @param index</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static int getFib(int index) &#123;</span><br><span class="line">    if (index &lt; 2) &#123;</span><br><span class="line">        return index == 0 ? 0 : 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return getFib(index - 1) + getFib(index - 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 实现方式，基于变量实现</span><br><span class="line">  * @param index </span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static int getFib(int index) &#123;</span><br><span class="line">    if (index &lt; 0) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;else if(index==1||index==2)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        int a=0,b=1,c=1;</span><br><span class="line">        for(int j=3;j&lt;=index;j++)&#123;</span><br><span class="line">            c=a+b;</span><br><span class="line">            a=b;</span><br><span class="line">            b=c;</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Q.栈实现队列功能？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class Stack2Queue &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 用栈的入栈和出栈</span><br><span class="line">     * 来实现队列的入队和出队</span><br><span class="line">     *  stack1是入栈的，stack2是出栈的。</span><br><span class="line">        入队列：直接压入stack1即可</span><br><span class="line">        出队列：如果stack2不为空，把stack2中的栈顶元素直接弹出；</span><br><span class="line">            否则，把stack1的所有元素全部弹出压入stack2中，再弹出stack2的栈顶元素</span><br><span class="line">     * */</span><br><span class="line">    Stack stack1 = new Stack();</span><br><span class="line">    Stack stack2 = new Stack();</span><br><span class="line">    public void add(Object o) &#123;</span><br><span class="line">        stack1.push(o);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Object poll() &#123;</span><br><span class="line">        Object o = null;</span><br><span class="line">        </span><br><span class="line">        if(stack2.length()==0) &#123;</span><br><span class="line">            //把stack1的数据放入stack2，留下最后一个数据</span><br><span class="line">            while(stack1.length()&gt;1) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            if(stack1.length()==1) &#123;</span><br><span class="line">                //把stack1的最后的那个数据返回出去</span><br><span class="line">                o = stack1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            o = stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return o;</span><br><span class="line">    &#125;</span><br><span class="line">    public int length() &#123;</span><br><span class="line">        return stack1.length()+stack2.length();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Q.扑克牌洗牌算法？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">   //Fisher-Yates Shuffle算法,从原始数组中随机取一个之前没取过的数字到新的数组中</span><br><span class="line">private static void Shuffle ()</span><br><span class="line">	&#123;	</span><br><span class="line">		string[] cardType = &#123; &quot;红桃&quot;, &quot;黑桃&quot;, &quot;方块&quot;, &quot;梅花&quot; &#125;;</span><br><span class="line">		string[] cardValue = &#123; &quot;A&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;, &quot;J&quot;, &quot;Q&quot;, &quot;K&quot; &#125;;</span><br><span class="line">		// 所有的卡牌，未打乱状态</span><br><span class="line">		List&lt;string&gt; allCard = new List&lt;string&gt;();</span><br><span class="line">		// 打乱后的结果</span><br><span class="line">		List&lt;string&gt; result = new List&lt;string&gt; ();</span><br><span class="line">		// 生成52张牌，放到allCard数组里</span><br><span class="line">		for (int i = 0; i &lt; cardType.Length; i++) &#123;</span><br><span class="line">			for (int j = 0; j &lt; cardValue.Length; j++) &#123;</span><br><span class="line">				allCard.Add(cardType[i] + cardValue[j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		// 定义随机数</span><br><span class="line">		Random random = new Random ();</span><br><span class="line">		// 循环52次，把未打乱的卡牌数组乱序存到新的数组里</span><br><span class="line">		for (int i = 0; i &lt; cardType.Length * cardValue.Length; i++) &#123;</span><br><span class="line">			// 定义一个随机的下标，范围是 0 ~ 有序数组的长度</span><br><span class="line">			int randomIndex = random.Next(0,allCard.Count);</span><br><span class="line">			// 给新数组赋值，值是未打乱卡牌数组中的随机某个位置</span><br><span class="line">			result.Add(allCard[randomIndex]);</span><br><span class="line">			// 将刚才随机过的下标数据从数组中移除</span><br><span class="line">			allCard.RemoveAt(randomIndex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">//Knuth-Durstenfeld Shuffle，就和洗扑克牌一样，保证原来的数字不在原有的位置上</span><br><span class="line">public int[] shuffle() &#123;</span><br><span class="line">       int[] result = src.clone();</span><br><span class="line">       int t ;</span><br><span class="line">       for (int i = result.length - 1; i &gt; 0; i--) &#123;</span><br><span class="line">           int x = ran.nextInt(i+1);</span><br><span class="line">           t = result[i];</span><br><span class="line">           result[i] = result[x];</span><br><span class="line">           result[x] = t;</span><br><span class="line">       &#125;</span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>Q.二叉树的深度–层次遍历/BFS?<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class Tree &#123;</span><br><span class="line">	</span><br><span class="line">	public class TreeNode &#123;</span><br><span class="line">	    int val = 0;</span><br><span class="line">	    TreeNode left = null;</span><br><span class="line">	    TreeNode right = null;</span><br><span class="line">	    public TreeNode(int val) &#123;</span><br><span class="line">	        this.val = val;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">    public int TreeDepth(TreeNode root) &#123;</span><br><span class="line">    	if (root==null) &#123;</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">    	int leftnum = TreeDepth(root.left);</span><br><span class="line">    	int rightnum = TreeDepth(root.right);</span><br><span class="line">		return Math.max(leftnum+1, rightnum+1);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public int TreeDepth2(TreeNode root) &#123;</span><br><span class="line">    	if (root==null) &#123;</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">    	Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">    	queue.add(root);</span><br><span class="line">    	int level = 0;</span><br><span class="line">    	while (!queue.isEmpty()) &#123;</span><br><span class="line">    		level++;</span><br><span class="line">    		int len = queue.size();//这一层的长度</span><br><span class="line">    		TreeNode head = null;</span><br><span class="line">    		for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    			head = queue.poll();//这一层都慢慢去掉；</span><br><span class="line">        		if (head.left!=null) &#123;</span><br><span class="line">        			queue.add(head.left);</span><br><span class="line">    			&#125;</span><br><span class="line">        		if (head.right!=null) &#123;</span><br><span class="line">        			queue.add(head.right);</span><br><span class="line">    			&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Q.请写出冒泡排序?<br><br>A:<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void buubleSortOne(long [] nums)&#123;</span><br><span class="line">    int number = 0;</span><br><span class="line">    long temp = 0;</span><br><span class="line">    for(int i =0 ;i &lt; nums.length - 1; i++)&#123; // 第n轮</span><br><span class="line">        for(int j = 0 ;j &lt; nums.length - 1 - i ; j++)&#123;//循环比较</span><br><span class="line">            number++;</span><br><span class="line">            if(nums[j] &gt; nums[j+1])&#123;//比较大小 [成立交互位置 小的向前移动 大的向后移]</span><br><span class="line">                temp = nums[j];</span><br><span class="line">                nums[j] = nums[j+1];</span><br><span class="line">                nums[j+1] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;sort:&quot;+number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Q.给定一个数组candidates和一个目标值target,求出数组中相加结果为target的数字组合?<br><br>A:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; LList = new ArrayList&lt;List&lt;Integer&gt;&gt;();  // 最终的结果集</span><br><span class="line">        if(candidates == null || candidates.length &lt; 1 || target &lt; 1 )</span><br><span class="line">            return LList;</span><br><span class="line">        Arrays.sort(candidates);  // 排序，使得不用对相同的结果集计算多次</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();  // 临时结果保存</span><br><span class="line">        combinationSumCore(candidates,list, target, 0, LList);  // 核心函数</span><br><span class="line">        return LList;</span><br><span class="line">    &#125;</span><br><span class="line">    public void combinationSumCore(int[] candidates,List&lt;Integer&gt; list, int target, int index, List&lt;List&lt;Integer&gt;&gt; LList)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i = index; i &lt; candidates.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(candidates[i] == target)  // 等于，就加入结果集</span><br><span class="line">            &#123;</span><br><span class="line">                List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();</span><br><span class="line">                result.addAll(list);</span><br><span class="line">                result.add(candidates[i]);</span><br><span class="line">                LList.add(result);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(candidates[i] &lt; target)  // 小于，就继续递归</span><br><span class="line">            &#123;</span><br><span class="line">                List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();</span><br><span class="line">                result.addAll(list);</span><br><span class="line">                result.add(candidates[i]);</span><br><span class="line">                combinationSumCore(candidates, result, target - candidates[i], i, LList);  // 这边i值不变，是因为当前值可以使用多次</span><br><span class="line">            &#125;</span><br><span class="line">            else  // 大于，则后面的数字都大于，因此不可能出现在结果集中</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Q.找出给定数据中任意两个值相加为sum的值?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Map&gt; <span class="title">returnSum</span><span class="params">(<span class="keyword">int</span>[] sums, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        List&lt;Map&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;sums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sums[i]+sums[j] == sum)&amp;&amp;(i!=j))&#123;</span><br><span class="line">                    Map&lt;Integer,Integer&gt; retMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                    retMap.put(sums[i],sums[j]);</span><br><span class="line">                    lists.add(retMap);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists.isEmpty()?Collections.emptyList():lists;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Q.二维数据查询？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static boolean Find2(int [][] array,int target) &#123;</span><br><span class="line">        int rowsNum = array.length;//行的数量</span><br><span class="line">        int colsNum = array[0].length;//列的数量</span><br><span class="line">        int i = rowsNum - 1;</span><br><span class="line">        int j = 0;</span><br><span class="line">        while(i &gt;= 0 &amp;&amp; j &lt; colsNum)&#123;</span><br><span class="line">            if(array[i][j] &gt; target)&#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;else if(array[i][j] &lt; target)&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Q.快速排序？<br><br>A:<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private int partition(int[] array, int low, int high) &#123;</span><br><span class="line">    //选取key</span><br><span class="line">    int key = array[low];</span><br><span class="line">    while (low &lt; high) &#123;</span><br><span class="line">        while (low &lt; high &amp;&amp; array[high] &gt;= key) &#123;</span><br><span class="line">            high--;</span><br><span class="line">        &#125;</span><br><span class="line">        array[low] = array[high];</span><br><span class="line">        while (low &lt; high &amp;&amp; array[low] &lt;= key) &#123;</span><br><span class="line">            low++;</span><br><span class="line">        &#125;</span><br><span class="line">        array[high] = array[low];</span><br><span class="line">    &#125;</span><br><span class="line">    array[low] = key;</span><br><span class="line">    return low;</span><br><span class="line">&#125;</span><br><span class="line">private void sort(int[] data, int low, int high) &#123;</span><br><span class="line">    if (low &lt; high) &#123;</span><br><span class="line">        int boundary = partition(data, low, high);</span><br><span class="line">        //递归低位分区</span><br><span class="line">        sort(data,low, boundary - 1);</span><br><span class="line">        //递归高位分区</span><br><span class="line">        sort(data,boundary + 1, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Q.两个有序数组判断存在相同元素?<br><br>A:<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 判断两个有序数组是否存在相同元素</span><br><span class="line"> * Created by sx on 2017/12/15.</span><br><span class="line"> */</span><br><span class="line">public class hasSameElement &#123;</span><br><span class="line">     static boolean  is_has_same_element(int[] arry1,int[] arry2)</span><br><span class="line">    &#123;</span><br><span class="line">        //边界判断</span><br><span class="line">        if(arry1.length==0 || arry2.length ==0)  return  false;</span><br><span class="line"></span><br><span class="line">        // 遍历数组1,二分查找数组2</span><br><span class="line">        for (int i = 0; i &lt;arry1.length ; i++) &#123;</span><br><span class="line">            int num = arry1[i];</span><br><span class="line"></span><br><span class="line">            if(bs(arry2,0,arry2.length-1,num))</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(&quot;数组1位置:&quot;+i);</span><br><span class="line">                return  true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return  false;</span><br><span class="line">    &#125;</span><br><span class="line">    // 二分查找</span><br><span class="line">    static boolean bs(int[]  arry,int start,int end,int key)</span><br><span class="line">    &#123;</span><br><span class="line">        if(start&gt;end)  return  false;</span><br><span class="line">        int middle =(start + end) &gt;&gt;&gt; 1;  //int middle =  (start+end)/2;</span><br><span class="line">        if(key==arry[middle])</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;数组2位置:&quot;+middle);</span><br><span class="line">            return  true;</span><br><span class="line">        &#125;</span><br><span class="line">        if(key&lt;arry[middle])  return  bs(arry,start,middle-1,key);</span><br><span class="line">        if(key&gt;arry[middle])  return  bs(arry,middle+1,end,key);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int arry1[]  = &#123;3,5,7,8&#125;;</span><br><span class="line">        int arry2[]  = &#123;1,8&#125;;    // 两个有序数组</span><br><span class="line">        System.out.println(is_has_same_element(arry1,arry2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Q.1~9999数列中数字3出现的次数。用递推方法解出?<br><br>A:<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0~9999之间：百位十位 个位共有10个0~999（0～999， 1000～1999，9000～9999），故有10*300=3000次，而千位为1的有1000次，共3000+1000=4000次</span><br><span class="line">4000=10*300+1000</span><br><span class="line">规律：</span><br><span class="line">0~9：1</span><br><span class="line">0~99：20=10*1+10</span><br><span class="line">0~999：300=10*20+100</span><br><span class="line">0~9999：4000=10*300+1000</span><br><span class="line">0~99999：50000=10*4000+10000</span><br><span class="line">0~999999：600000=10*50000+100000</span><br><span class="line">f（1）=1</span><br><span class="line">f(2)=10*f(1)+10 **1</span><br><span class="line">f(3)=10*f(2)+10 **2</span><br><span class="line">f(4)=10*f(3)+10 **3</span><br><span class="line">..</span><br><span class="line">f(n)=10*f(n-1) + 10*(n-1)</span><br></pre></td></tr></table></figure>
<p>Q.从一个数组中找出前4个最大的数，用最优解?<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sorted(arrary[])[:4]</span><br></pre></td></tr></table></figure></p>
<p>Q.写一段程序，删除字符串a中包含的字符串b，举例 输入a = “asdw”,b = “sd” 返回 字符串 “aw”，并且测试这个程序。<br><br>A:<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String str, String targetStr)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span>||targetStr==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        <span class="keyword">if</span> (str.length() &gt; =targetStr.length()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((i + targetStr.length()) &gt; str.length()) &#123;</span><br><span class="line">                    sb.append(str.substring(i, str.length()));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!str.substring(i, (i + targetStr.length())).equals(targetStr)) &#123;</span><br><span class="line">                    sb.append(str.substring(i, i + <span class="number">1</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    i = i + targetStr.length() - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            sb.append(str);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>Q.写一个方法，把字符串转为数字，比如 str=”1234”，变成 int 1234。并且测试这个程序。<br><br>A: <br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Int in = Integer.Parse(str)</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int myAtoi(String str) &#123;</span><br><span class="line">      </span><br><span class="line">    str = str.trim();</span><br><span class="line">    if (str.isEmpty()) return 0;</span><br><span class="line"> </span><br><span class="line">    // 正负号标记</span><br><span class="line">    int sign = 1;</span><br><span class="line"> </span><br><span class="line">    // 转换值</span><br><span class="line">    int base = 0;</span><br><span class="line"> </span><br><span class="line">    // 索引位数</span><br><span class="line">    int i = 0;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    // 判断正负号</span><br><span class="line">    if (str.charAt(i) == &apos;-&apos; || str.charAt(i) == &apos;+&apos;)</span><br><span class="line">        sign = str.charAt(i++) == &apos;-&apos; ? -1 : 1;</span><br><span class="line"> </span><br><span class="line">    // 索引有效数字字符</span><br><span class="line">    while (i &lt; str.length() &amp;&amp; str.charAt(i) &gt;= &apos;0&apos; &amp;&amp; str.charAt(i) &lt;= &apos;9&apos;) &#123; </span><br><span class="line">        // 如果base &gt; MAX_VALUE/10，那么base*10 + new_value &gt; base*10 &gt; MAX_VALUE，这种情况下就会发生溢出。</span><br><span class="line">        // 若base == INT_MAX/10，而且new_value = str.charAt(i++) - &apos;0&apos;`大于`7`，也会发生溢出。因为MAX_VALUE = 2147483647</span><br><span class="line">        if (base &gt; Integer.MAX_VALUE / 10 || (base == Integer.MAX_VALUE / 10 &amp;&amp; str.charAt(i) - &apos;0&apos; &gt; 7)) &#123;</span><br><span class="line">            return (sign == 1) ? Integer.MAX_VALUE : Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        // 计算转换值</span><br><span class="line">        base = 10 * base + (str.charAt(i++) - &apos;0&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 计算结果值</span><br><span class="line">    return base * sign;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Q.回文算法?<br><br>A:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">方法<span class="number">1</span>：两头往中间扫</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPalindrome1</span><span class="params">(String A)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] arrayA = A.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = arrayA.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(A.equals(<span class="string">""</span>) || A.equals(<span class="keyword">null</span>))    <span class="comment">//非法输入</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(top &lt; end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arrayA[top++] != arrayA[end--])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>Q.素数?<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断一个数是不是素数：只能被1和本身整除</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 说明：从2开始除，不需要到n，也就是循环条件是 &lt; n 就可以，这之间只要被整除了，那么他就不是素数了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">numberIsPrime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>Q.有序单链表翻转？<br><br>A:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> index, Node next)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.index = index;</span><br><span class="line">      <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Node next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverseListNode</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">        <span class="comment">//单链表为空或只有一个节点，直接返回原单链表</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.getNext() == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//前一个节点指针</span></span><br><span class="line">        Node preNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//当前节点指针</span></span><br><span class="line">        Node curNode = head;</span><br><span class="line">        <span class="comment">//下一个节点指针</span></span><br><span class="line">        Node nextNode = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span> (curNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            nextNode = curNode.getNext();<span class="comment">//nextNode 指向下一个节点</span></span><br><span class="line">            curNode.setNext(preNode);<span class="comment">//将当前节点next域指向前一个节点</span></span><br><span class="line">            preNode = curNode;<span class="comment">//preNode 指针向后移动</span></span><br><span class="line">            curNode = nextNode;<span class="comment">//curNode指针向后移动</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> preNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">reverse2</span><span class="params">(Node node, Node prev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">      node.next = prev;</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Node re = reverse2(node.next, node);</span><br><span class="line">      node.next = prev;</span><br><span class="line">      <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Q.合并两个有序链表为一个有序链表？<br><br>A:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        if (l1 == null) return l2;</span><br><span class="line">        if (l2 == null) return l1;</span><br><span class="line">        ListNode listNode = new ListNode(0);</span><br><span class="line">        ListNode returnValue = listNode;</span><br><span class="line">        while (l1 != null &amp;&amp; l2 != null)&#123;</span><br><span class="line">            if (l1.val &gt;= l2.val)&#123;</span><br><span class="line">                listNode.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                listNode.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        if (l1 == null)&#123;</span><br><span class="line">            listNode.next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        if (l2 == null)&#123;</span><br><span class="line">            listNode.next = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        return returnValue.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Q.队列的实现？<br><br>A:<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayQueue&lt;T&gt; <span class="title">arrayQueue</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        queue = <span class="keyword">new</span> Object[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size&gt;queue.length)&#123;</span><br><span class="line">            <span class="keyword">int</span> len = queue.length * <span class="number">2</span>;</span><br><span class="line">            queue = Arrays.copyOf(queue,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">poll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        T data = (T) queue[<span class="number">0</span>];</span><br><span class="line">        System.arraycopy(queue,<span class="number">0</span>,queue,<span class="number">1</span>,size-<span class="number">1</span>);</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(T data)</span></span>&#123;</span><br><span class="line">        ensureCapacity(size+<span class="number">1</span>);</span><br><span class="line">        queue[size++]= data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Q.子串在父串中第一次出现的位置？<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 找到字符串str2在字符串str1中第一次出现的位置，找不到返回-1 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findFirstPositionOfSubString</span><span class="params">(String str1, String str2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> offset = <span class="number">0</span>; </span><br><span class="line">        String substr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>((str1 == <span class="keyword">null</span>) || (str2 == <span class="keyword">null</span>) || (str1.length() &lt; str2.length()))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(offset &lt;= (str1.length() - str2.length()))</span><br><span class="line">            &#123;</span><br><span class="line">                substr = String.copyValueOf(str1.toCharArray(), offset, str2.length());</span><br><span class="line">                <span class="keyword">if</span>(substr.equals(str2))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> offset;</span><br><span class="line">                &#125;</span><br><span class="line">                offset ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>Q.找出指定数组中子数组中和最大的起始下标和结束下标?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arrIndex</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;array.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            temp = array[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;array.length-<span class="number">1</span>; j++)&#123;</span><br><span class="line">                temp = temp + array[j];</span><br><span class="line">                <span class="keyword">if</span> (temp &gt; max)&#123;</span><br><span class="line">                    max = temp;</span><br><span class="line">                    x=i;</span><br><span class="line">                    y=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(String.valueOf(max) + <span class="string">"\t"</span>+String.valueOf(x)+ <span class="string">"\t"</span> +String.valueOf(y));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>Q.验证是否是三角形？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否是三角形</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> b</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">isTriangle</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a&lt;<span class="number">0</span> || b&lt;<span class="number">0</span> || c&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数有误"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> ((a+b&gt;c) &amp;&amp; (a+c&gt;b) &amp;&amp; (b+c&gt;a))&#123;</span><br><span class="line">        logger.info(String.valueOf(a) + String.valueOf(b) + String.valueOf(c));</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        logger.info(<span class="string">"不是三角形"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">## 海量数据处理问题</span><br><span class="line">Q. 海量日志数据，提取出某日访问百度次数最多的那个IP？</span><br><span class="line">A:&lt;br&gt;</span><br></pre></td></tr></table></figure>
<p>算法思想：分而治之+Hash<br>1.IP地址最多有2^32=4G种取值情况，所以不能完全加载到内存中处理；<br>2.可以考虑采用“分而治之”的思想，按照IP地址的Hash(IP)%1024值，把海量IP日志分别存储到1024个小文件中。这样，每个小文件最多包含4MB个IP地址；<br>3.对于每一个小文件，可以构建一个IP为key，出现次数为value的Hash map，同时记录当前出现次数最多的那个IP地址；<br>4.可以得到1024个小文件中的出现次数最多的IP，再依据常规的排序算法得到总体上出现次数最多的IP；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Q.搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节</span><br><span class="line">A:&lt;br&gt;</span><br></pre></td></tr></table></figure></p>
<p>假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。），请你统计最热门的10个查询串，要求使用的内存不能超过1G。</p>
<p> 典型的Top K算法<br>    第一步、先对这批海量数据预处理，在O（N）的时间内用Hash表完成统计；<br>    第二步、借助堆这个数据结构，找出Top K，时间复杂度为N‘logK。即，借助堆结构，我们可以在log量级的时间内查找和调整/移动。因此，维护一个K(该题目中是10)大小的小根堆，然后遍历300万的Query，分别和根元素进行对比所以，我们最终的时间复杂度是：O（N） + N’*O（logK），（N为1000万，N’为300万）</p>
<pre><code>或者：采用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Q.给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？</span><br><span class="line">A:&lt;br&gt;</span><br></pre></td></tr></table></figure>
<p>可以估计每个文件安的大小为5G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。</p>
<ul>
<li><p>遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,…,a999）中。这样每个小文件的大约为300M。</p>
</li>
<li><p>遍历文件b，采取和a相同的方式将url分别存储到1000小文件（记为b0,b1,…,b999）。这样处理后，所有可能相同的url都在对应的小文件（a0vsb0,a1vsb1,…,a999vsb999）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。</p>
</li>
<li><p>求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Q. 海量图片识别，找出其中相似的图片？</span><br><span class="line">A:&lt;br&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li>类目预测：<br> 由于特征对于类目的区分能力有限，同时如果不分类目在全量中搜索性能无法满足。因此，我们通过类目预测来判断商品数据哪个类目。目前拍立淘有10多个大类，涵盖上万个叶子类目。</li>
<li>主题检测：<br> 因为商品的背景复杂，主体常常较小，所以为了减少大量背景干扰和多主体的影响，因此需要将搜索目标从图像中提取出来。下面两幅图反应了对于用户的query，进行主体检测和不进行主体检测的搜索结果差异。</li>
<li>图像特征：<br> 图像特征包括深度特征（CNN深度卷积神经网络）和局部特征。CNN从高层提取特征，突破语义鸿沟。局部特征关注图像的局部特征，可以作为CNN特征的辅助和补充。</li>
<li>检索索引：<br> 搜索的过程可以分成离线和在线。离线过程进行商品图像特征的提取，建立索引。而在线的过程，对query提取特征，到分布式的引擎里面去进行快速的查询。</li>
<li>排序：<br> 针对多种图像特征，和非图像的特征，根据不同的优化函数，我们会对结果进行重新的排序。</li>
</ol>
<p><code>`</code></p>
<!-- flag of hidden posts -->
    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>原文作者：<a href="https://markdevil.github.io">Mark M</a>
            <p>原文链接：<a href="https://markdevil.github.io/2021/03/07/测试开发面试题/">https://markdevil.github.io/2021/03/07/测试开发面试题/</a>
            <p>发表日期：<a href="https://markdevil.github.io/2021/03/07/测试开发面试题/">March 7th 2021, 9:25:22 pm</a>
            <p>更新日期：<a href="https://markdevil.github.io/2021/03/07/测试开发面试题/">October 23rd 2022, 5:45:02 pm</a>
            <p>版权声明：</p>
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
        </li>
        <li class="previous">
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

<!-- City版安装代码已完成 -->
    

    

    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>

            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
    
        
            
                <a href="//github.com/MarkDevil" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:50vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-测试理论"><span class="toc-number">1.</span> <span class="toc-text">1. 测试理论</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#测试情景"><span class="toc-number">2.</span> <span class="toc-text">测试情景</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-测试管理"><span class="toc-number">3.</span> <span class="toc-text">2. 测试管理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-移动测试"><span class="toc-number">4.</span> <span class="toc-text">3. 移动测试</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-服务端测试"><span class="toc-number">5.</span> <span class="toc-text">4. 服务端测试</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-自动化相关"><span class="toc-number">6.</span> <span class="toc-text">5. 自动化相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-工具使用"><span class="toc-number">6.1.</span> <span class="toc-text">5.1 工具使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1-WebDriver"><span class="toc-number">6.1.1.</span> <span class="toc-text">5.1.1 WebDriver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-Appium"><span class="toc-number">6.1.2.</span> <span class="toc-text">5.1.2 Appium</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-3-Jmeter"><span class="toc-number">6.1.3.</span> <span class="toc-text">5.1.3 Jmeter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-4-TestNG"><span class="toc-number">6.1.4.</span> <span class="toc-text">5.1.4 TestNG</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-性能测试"><span class="toc-number">7.</span> <span class="toc-text">6. 性能测试</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-Mysql数据库相关"><span class="toc-number">8.</span> <span class="toc-text">7. Mysql数据库相关</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-Linux"><span class="toc-number">9.</span> <span class="toc-text">8. Linux</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#操作系统"><span class="toc-number">10.</span> <span class="toc-text">操作系统</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-网络相关"><span class="toc-number">11.</span> <span class="toc-text">9. 网络相关</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-编程语言相关"><span class="toc-number">12.</span> <span class="toc-text">10. 编程语言相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-Java"><span class="toc-number">12.1.</span> <span class="toc-text">10.1 Java</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本知识点"><span class="toc-number">12.1.1.</span> <span class="toc-text">基本知识点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设计模式"><span class="toc-number">12.1.2.</span> <span class="toc-text">设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#集合"><span class="toc-number">12.1.3.</span> <span class="toc-text">集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程"><span class="toc-number">12.1.4.</span> <span class="toc-text">线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#锁机制"><span class="toc-number">12.1.5.</span> <span class="toc-text">锁机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM"><span class="toc-number">12.1.6.</span> <span class="toc-text">JVM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据库存储"><span class="toc-number">12.1.7.</span> <span class="toc-text">数据库存储</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-4-Python"><span class="toc-number">12.2.</span> <span class="toc-text">10.4 Python</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-中间件"><span class="toc-number">13.</span> <span class="toc-text">11. 中间件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1-tomcat"><span class="toc-number">13.1.</span> <span class="toc-text">11.1 tomcat</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-redis"><span class="toc-number">13.2.</span> <span class="toc-text">11.2 redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3-消息队列-MQ"><span class="toc-number">13.3.</span> <span class="toc-text">11.3 消息队列(MQ)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-4-nginx"><span class="toc-number">13.4.</span> <span class="toc-text">11.4 nginx</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-5-Netty"><span class="toc-number">13.5.</span> <span class="toc-text">11.5 Netty</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-6-Mybatis"><span class="toc-number">13.6.</span> <span class="toc-text">11.6 Mybatis</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-测试环境搭建CI和CD"><span class="toc-number">14.</span> <span class="toc-text">12. 测试环境搭建CI和CD</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-1-Jenkins"><span class="toc-number">14.1.</span> <span class="toc-text">12.1 Jenkins</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-devops（docker部署）"><span class="toc-number">14.2.</span> <span class="toc-text">12.2 devops（docker部署）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#镜像相关"><span class="toc-number">14.2.1.</span> <span class="toc-text">镜像相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#容器相关"><span class="toc-number">14.2.2.</span> <span class="toc-text">容器相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#仓库相关"><span class="toc-number">14.2.3.</span> <span class="toc-text">仓库相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#配置相关"><span class="toc-number">14.2.4.</span> <span class="toc-text">配置相关</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-Spring和Spring-Boot"><span class="toc-number">15.</span> <span class="toc-text">13. Spring和Spring Boot</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-微服务篇"><span class="toc-number">16.</span> <span class="toc-text">14. 微服务篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#dubbo"><span class="toc-number">16.1.</span> <span class="toc-text">dubbo</span></a></li></ol></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 12
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2024 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/11</span><a class="archive-post-title" href= "/2024/10/11/测试平台/" >测试平台</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2023 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/07</span><a class="archive-post-title" href= "/2023/03/07/测试开发面试题-new/" >测试开发面试题</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2021 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/07</span><a class="archive-post-title" href= "/2021/03/07/jvm/" >jvm</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/07</span><a class="archive-post-title" href= "/2021/03/07/redis/" >redis</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/07</span><a class="archive-post-title" href= "/2021/03/07/spring/" >spring</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/07</span><a class="archive-post-title" href= "/2021/03/07/java/" >java</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/07</span><a class="archive-post-title" href= "/2021/03/07/数据库/" >数据库</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/07</span><a class="archive-post-title" href= "/2021/03/07/多线程/" >多线程</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2020 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/11</span><a class="archive-post-title" href= "/2020/07/11/python-gunicorn高可用部署/" >python-gunicorn高可用部署.md</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/27</span><a class="archive-post-title" href= "/2020/02/27/vue项目部署到非根目录步骤/" >Vue项目部署到非根目录步骤.md</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2018 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/17</span><a class="archive-post-title" href= "/2018/12/17/Java-Rmi-md/" >Java-Rmi.md</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/22</span><a class="archive-post-title" href= "/2018/08/22/Maven构建jar包/" >Maven构建jar包</a>
        </li>
    
    </div>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6926466603839473"
             crossorigin="anonymous"></script>
  </div>

        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="python"><span class="iconfont-archer">&#xe606;</span>python</span>
    
        <span class="sidebar-tag-name" data-tags="redis"><span class="iconfont-archer">&#xe606;</span>redis</span>
    
        <span class="sidebar-tag-name" data-tags="vue"><span class="iconfont-archer">&#xe606;</span>vue</span>
    
        <span class="sidebar-tag-name" data-tags="数据库"><span class="iconfont-archer">&#xe606;</span>数据库</span>
    
        <span class="sidebar-tag-name" data-tags="测试"><span class="iconfont-archer">&#xe606;</span>测试</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
        <span class="sidebar-category-name" data-categories="后端"><span class="iconfont-archer">&#xe60a;</span>后端</span>
    
        <span class="sidebar-category-name" data-categories="前端"><span class="iconfont-archer">&#xe60a;</span>前端</span>
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6926466603839473"
             crossorigin="anonymous"></script>
</div>

    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "Mark M"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>
    
    </body>
    <!-- google ad     -->
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6926466603839473"
         crossorigin="anonymous"></script>
    <!-- recommend -->
    <ins class="adsbygoogle"
         style="display:block"
         data-ad-client="ca-pub-6926466603839473"
         data-ad-slot="8766565359"
         data-ad-format="auto"
         data-full-width-responsive="true"></ins>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-E798RBZ4M7"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-E798RBZ4M7');
    </script>
</html>


